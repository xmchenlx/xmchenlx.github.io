[{"title":"theWayToOpenNewPageByRouterLink","date":"2021-10-15T06:31:23.000Z","url":"/2021/10/15/theWayToOpenNewPageByRouterLink/","categories":[["undefined",""]]},{"title":"在antd的table里用vue-draggable-resizable进行列伸缩，数值变化了但视图没有更新的解决办法","date":"2021-08-05T09:11:32.000Z","url":"/2021/08/05/tableDraggableResizableChangeDataButViewNotUpdate/","tags":[["Vue","/tags/Vue/"],["Antd","/tags/Antd/"],["组件","/tags/%E7%BB%84%E4%BB%B6/"],["通信","/tags/%E9%80%9A%E4%BF%A1/"],["vue-draggable-resizable","/tags/vue-draggable-resizable/"]],"categories":[["undefined",""]],"content":"前言按照antd官网table组件的描述，table并没有集成伸缩功能，而是需要自己去下载依赖并配置相关的东西才可以。而在配好之后，通过控制台输出参数发现，宽度已经完成了更改，但是视图并没有更新。并且，自己去通过this.$forceUpdate()后发现，有变化。但我们需要根据用户的拉伸情况进行实时的变化。 做法因为使用vue-draggable-resizable这个插件需要配置一大堆参数。所以就集成在了一个外部的.js文件里。但不论有没有分开单独写，这些参数始终是没有在Vue实例里写。所以这里的思路是引入js的时候调用js的方法，并把Vue的this指针作为参数传递过去。这样外部的js在执行拖动事件时，能用这个指针另Vue能执行更新画面的功能。 这里主要说的是外部引用并相互调用的这个部分，集成进table表头的这个部分不再赘述。 代码如下。 Vue里： 在外部Js里： 参考"},{"title":"antd框架的table组件多次封装中的slot问题解决办法","date":"2021-08-03T09:58:23.000Z","url":"/2021/08/03/20210803antdtableslotinfo/","tags":[["antd","/tags/antd/"],["vue","/tags/vue/"],["vue-slot","/tags/vue-slot/"]],"categories":[["undefined",""]],"content":"涉及内容vue、slot、ant-degisn-vue、父子之间通信 问题概述一般来说，可以直接使用a-table组件对页面进行布局和使用。但由于这个需求，这个基础组件还需要自己去配置一些其他的参数，而且这种表格非常的多，就考虑到了自己封装组件的方式来简化一部分的代码。对于把表格弄进自己封装的组件，常规字符是没有问题，但遇到需要自定义某一列的数据格式的时候就不行了。如果没听懂我说什么，看一下效果图。【状态】列、【角色名称】列就是自定义的效果。 自定义内容指的是常规内容以外的内容，往往涉及到另外的标签代码。如： 数据库中的男女字段从0、1变成男、女； 操作列按钮 一些状态标签 时间格式化 本文约定的页面与数据传递的关系本文的页面叫index.vue； 页面包含了封装的组件queryFormTable.vue，在这简称Q吧； 封装的组件Q中使用到了封装atable组件，叫作MutiFunctionalTable.vue，这个组件包含了table本身的功能，还有排序、显示列、固定列等功能。简称M吧。 M所用到的参数分别是表头tableColumns和表数据tableData。这些数据会从index传入到Q，再由Q传到M。 碰壁过程在原本的a-table组件里，如果遇到自定义列的需求时，在table标签里填入&lt;template&gt;标签、并在column的信息里指定好相关的slot参数即可。 但是现在，因为封装成组件M了，这些slot相关的信息就没有办法直接填在这里。这些信息就需要由外头引入进来。 原本我的想法是，由在index里写个&lt;slot name=\"tableSlot\"/&gt;，把原本表格的slot列信息传递到Q里，再由Q传递到M。结果发现，不行。 接着，我就先不考虑父子孙的传递，考虑在子孙之间传递一下slot。所以我把index这边的信息丢到Q这里试一下，发现，不行。 然后，我又试着继续用父子孙进行传递，但是不传slot，传递普通的信息&lt;p&gt;hello&lt;/p&gt;，并且，在M里把接收的slot挪到表格外面来。看了一下效果，可以！ 也就是说这个那个。经过试验证明，**&lt;slot&gt;不能通过&lt;slot&gt;传递&lt;slot&gt;。** 父子孙传递可以用slot一级一级的传递，但是！好像slot不能嵌套slot。准确的说，是因为自己本身就借由插槽传东西了，传递的东西就不能是slot本身的信息。 但是稍微变一下思路，既然不能从1条高速路将东西传过去，那就自己开路把东西一级一级的传过去，有多少东西开多少路。也就是说，按照自定义的数量n，分别从index开n个插槽到Q；再由Q开插槽到M。再借由层层传递的数据表头循环出对应的插槽内容即可。 毕竟鲁迅曾经说过：世界上本没有路，没人说slot只能用1个，所以可以多个。 注：红色框起来的是涉及到的代码部分，看这边就行；黄色框是提示在哪一个标签里面及其标签内容的范围。 在index里声明了需要自定义内容的插槽信息。slot的字段要与最后表头信息里的slot字段要一致，不然一切都是白搭。slot-scope是回传的每一行的信息集合。因为自定义的内容往往都涉及到了对参数的格式更改或者其他的操作函数所需要的参数。函数的信息或者格式的规则都是写在index里的，所以需要知道每一行的信息才有办法进行格式或者是其他操作（起码需要知道主键信息，但我一般都选择回传整行的对象） 在Q 里，遍历一遍表头信息并开辟所需的插槽。传递给M的同时将表格数据遍历回传给index。 在M里接收传递过来的插槽信息并显示。 项目代码index.vue queryxxxxxx.vue table.vue 参考方法"},{"title":"封装多功能表格：Ant-design的table进行二次封装","date":"2021-07-30T03:01:14.000Z","url":"/2021/07/30/20210730fzzj/","tags":[["Vue","/tags/Vue/"],["Antd","/tags/Antd/"],["组件","/tags/%E7%BB%84%E4%BB%B6/"]],"categories":[["undefined",""]],"content":"Desc当编写一个页面时，可以直接按照需求摆放元素并编写逻辑；而当有很多页面都出现重复的需求的时候，就可以考虑一下自己封装组件并且调用。 首先首先，在某一个目录创建组件的文件夹。我这里是需要把ant-design的table改成可以伸缩，可以支持列表显示的表格。这里算是二次封装吧。名字就叫作mutiFunctionalTable。这个文件夹里头主要有两个文件，一个是mutiFunctionalTable.vue，另一个就是index.js。index主要是用于暴露我们的组件封装信息，另一个就是组件本身的文件啦~ 写组件本身留传入参数属性因为是个组件，所以无法逃避从外面接收参数这个问题。vue中可以利用props属性声明参数集合，里面放置参数名与参数类型就算是完成声明了。所以，这些信息不需要在data(){return{}}里再写一遍了（下方的computed()也是同理。我这里留了3个参数，如下。 填写template在template里放a-table组件，再把需要的属性填上去，并在data()里补填相应的变量。 如果表格中需要操作栏，就需要预留一个插槽让父组件来放置自己功能的操作栏按钮。在操作栏的表头上我还放置了一个可以控制表列显示与否的操作面板，这个面板来源于tableColumn里的设置。column的信息用两个变量来控制，一个是父组件传过来的原信息，另一个是我们处理用于显示表格的显示信息。面板的数据来源于原信息，表格的数据来自于面板出发改变后处理得到的表格信息。 关于表格列表伸缩在ant-design的文档里解释道，表格的伸缩需要依靠vue-draggable-resizable这个依赖。关于版本的问题，在往网上搜了大概后了解到，效果比较好的版本是2.1，所以安装时需要指定版本，命令就变成了npm install vue-draggable-resizable@2.1.0 --save。 安装完依赖后，还需要在组件中进行计算声明。在data()里直接放入下方代码（与return{}同级）。 这还没完，最后需要自己在column信息的变量中，对每一列进行宽度的赋值。这里只能放入数值，放入字符是无效的如px、vw、%等等，到时候照样没有伸缩效果。 对于column的计算前面说到展示的column和传回的column用的不是同一份数据（也有因为传入的prop不能直接更改的原因在里面），在computed里计算出用于展示的column数据。因为涉及到变更，所以需要自己分别写出get()和set()的方法。 index暴露组件组件封装好后，需要暴露出去，这样才可以在其他的地方使用它。 接着在main.js里进行全局引用。 使用在需要用的地方，放入封装组件的标签，并赋予他参数，在页面上就可以看到可以拖拽，可以自定义的表格啦~ 关于数据往回传的问题（Props）如果曾经尝试过直接修改Props里的属性可能就会发现报了以下的错误 Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-… 首先，这样子是肯定不能改的。因为Vue里的数据基本上都是单向数据流。 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 使用$emit(‘事件名称’,参数)方法,将子组件数据作为参数抛出给组件的事件(事件名称可自定义),在父级组件监听这个事件,并且在父组件写一个方法作为事件处理函数,则子组件抛出的数据将作为方法的第一个参数传入，然后在此方法内改变prop参数值即可。同时在组件上声明同名的事件名（字符@的那个） 实际上数据流向:子组件—-$emit触发事件抛出数据—-&gt;父组件—-监听事件改变prop—-&gt;子组件。 具体的写法如下。这里只给出涉及到的代码部分，是不能直接用的！！！，仅做参考。 子组件的内容如下 父组件如下。 组件完整代码"},{"title":"ant-design更改主题设置","date":"2021-07-05T09:13:21.000Z","url":"/2021/07/05/antdchangestyle/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["antd","/tags/antd/"]],"categories":[["undefined",""]],"content":"ant-design-vue是社区基于ant-design研发的UI框架；但，ant-design无法很直接的更改组件中的一些效果（如主题色、字体等样式）。官方也说明了通过less进行编译可以更改他们已提供的样式效果。 想更改样式的原因，除了换肤，还有一个原因是antd的组件中的字体好像都偏小。这里除了less替换外，还发现了一个特别好用的轮子。整理一下。 叫作 dynamic-antd-theme，链接： 。 利用Npm等工具导入依赖后，直接在操作的页面导包（不用导入组件），然后使用其提供的函数即可。 如果是更改颜色，在功能里直接使用changeAntdTheme 函数。需要提供的参数为(color,option)。 param: (color, options), change the antd theme. The options specific attributes are as follows： - storageName: This can be configured to set storageName when not using picker . - customCss: custom Css color就是需要更改主题颜色的颜色值；而option是一个对象。假设只需要额外更改css效果。将css代码组成合法的字符串后，封装到这个对象里即可。 啊嘞嘞，直接更改效果的话，可能会造成排版混乱，到时候要注意一下更改样式的组件与组件原生的样式相搭配。"},{"title":"vue中监听宽度变化并指导echarts重绘（自适应）","date":"2021-07-05T09:07:52.000Z","url":"/2021/07/05/20210730echartsresize/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["echarts","/tags/echarts/"]],"categories":[["undefined",""]],"content":"vue中，可以通过监听的方式感知浏览器窗口的变化。网上的教程很多，这里整理的是测试可用的方法。 vue里，不能直接对document元素属性进行监听。但可以在data()里先指明元素值，在通过mounted方法，对窗口宽度变化的值进行写入；再通过watch()感知变化后进行代码执行。 mouted中加入对document元素的监听。当宽度发生变化，会执行return体里的内容。 最后在watch里加入对需要做的内容的代码。加入timer的原因是为了避免浏览器宽度变化的期间，频繁的进行代码执行，加入timer的间隔后能节约一部分的计算资源，页面也不会看起来巨卡无比。搭配UI框架的加载控件或其余类似的蒙版使用效果更佳。代码要注意闭包问题。 "},{"title":"系统消息接收、阅读、处理——vue里的状态管理（store）的理解与相应应用","date":"2021-07-02T08:54:46.000Z","url":"/2021/07/02/vuestore/","tags":[["vue","/tags/vue/"],["vuex","/tags/vuex/"],["store","/tags/store/"]],"categories":[["undefined",""]],"content":"场景目前是有一个需要，大概是下面说的这些。 在首页中要能请求消息并挑选未读的消息显示数据； 在第二个组件中能预览状态为未读的消息列表； 在第三个组件中能预览到所有状态的消息列表； 第二个组件与第三个组件单击都能在第四个组件查阅详情，如果是未读状态的消息，需要设置成已读，首页的未读消息数量要减少； 第二个组件的维度消息列表要同步，读一条少一条； 已读状态再次打开阅读时，未阅读数值不应减少； … 还有一些其他的要求与细节，但与这次的文档主题无关，就不列了。 因为是同一份列表在多地点击并且能同步状态；显然每一个组件都发请求是不太可能的。所以需要在请求一次消息json后，先存到一个地方统一管理。那那那那，vue里刚好有这么一个地方，就是store。 准备首先需要准备一下这个地方。在src目录下新建一个文件夹store，里面创建一个index.js。 好了之后呢，在Vue挂载实例的地方引入sotre并挂进去（文件一般是main.js）。 store/index.js部分的设置重点就是这个sotre文件的配置了。先大概列一下sotre都有哪些东西。 一般我们使用action让他对其派发更新的操作。 这里的步骤是，先请求未读消息的api。得到返回的结果后，调用store派发，将res信息保存到store进行管理；而取数据就直接用最后一行代码就能达到效果。"},{"title":"echarts图表文本标签自定义设置","date":"2021-07-02T08:41:51.000Z","url":"/2021/07/02/echarts%E5%9B%BE%E8%A1%A8%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AE/","tags":[["vue","/tags/vue/"],["element","/tags/element/"],["ecarts","/tags/ecarts/"]],"categories":[["undefined",""]],"content":"场景 做法通常情况下，echarts中对于图像的设置是统一的；但也可以通过将参数放入data里的形式将每一个属性独立开来设置。 而我这里的需要是：将饼图不足以支撑文字放在里面的单元设置出来；所以就需要事先知道饼图的总数量与每一个单元的数量；两次循环是没有办法避免的。代码如下。 对于小于的阈值我这里设置的是0.2，可以根据自己的需要来调节。 附上最后的效果 "},{"title":"前端练习题","date":"2021-06-04T09:22:04.000Z","url":"/2021/06/04/qdlxt/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["练手","/tags/%E7%BB%83%E6%89%8B/"],["试题","/tags/%E8%AF%95%E9%A2%98/"]],"categories":[["undefined",""]],"content":"1、DOCTYPE 的作用是什么？标准模式与兼容模式各有什么区别？1、DOCTYPE是document type(文档类型)的简写，用于声明文档的解析类型(document.compatMode)，来告诉浏览器的解析器使用哪种HTML或XHTML规范解析页面。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 qurik mode 兼容模式（qurik mode），别称混杂模式、怪异模式，当 html 文档没有定义 &lt;!DOCTYPE&gt; 或者定义错误不能识别时， html 文档会变为兼容模式 页面以较宽松的向后兼容的形式呈现，以兼容各个浏览器 standard mode 标准模式（standard mode），别称严格模式 排版以及js运行模式以浏览器所支持的最高标准运行 判断文档解析类型 2、什么是行内元素、块级元素，行内元素与块级元素有什么区别区别？2、常见的元素有：a、b、span、img、strong、sub、sup、button、input、label、select、textarea。 常见的元素有：div、ul、ol、li、dl、dt、dd、h1~h6、p。 区别： 行内元素不会占据一行，会水平排列；而块级元素会占据一整行，成垂直排列。 块级元素可以包含行内元素和块级元素里面，但是行业元素不可以包含块级元素。 行内元素设置width、height是无效的，而且margin和padding的上下不生效，但左右生效。 3、HTML5 元素的分类3、HTML5元素主要分为7类： 类型 描述 元数据型（Metadata） 设置展示、行为、关联文档，或其他内容的元数据的元素（base、link、meta） 区块型（Sectioning） 定义区块内容范围的元素（rticle, aside, nav, section） 标题型（Heading） 定义区块内容标题的元素（h1~h6） 文档流型（Flow） 大部分文档body内的元素 语句型（Phrasing） 文档里的文字，还有在段落内标记这些文字的元素。一系列的语句型内容构成段落。（注意大部分语句型内容只能包含也是语句型内容的元素，不能包含文档流型元素)，有audio、video、img、select、input 内嵌型（Embedded） 在文档引入另一个资源的元素，或者插入文档的另一种语言，比如在HTML文档里的MathML（audio, video, img, canvas, svg, iframe, embed, object, math） 交互型（Interactive） 专门用于用户交互的元素（a, input, textarea, select） 一个元素可能有很多分类，也可能没有分类，比如html元素不属于任何一个分类。 4、页面渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）4、JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解 析文档。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的 原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 5、async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）5、（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。 （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。 （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执 行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。 6.CSS 优化、提高性能的方法有哪些？6、加载性能： （1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top0bottom0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。 选择器性能： （1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等； （2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。 （3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。 （4）尽量少的去对标签进行选择，而是用class。 （5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。 （6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。 渲染性能： （1）慎重使用高性能属性：浮动、定位。 （2）尽量减少页面重排、重绘。 （3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。 （4）属性值为0时，不加单位。 （5）属性值为浮动小数0.**，可以省略小数点之前的0。 （6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。 （7）不使用@import前缀，它会影响css的加载速度。 （8）选择器优化嵌套，尽量避免层级过深。 （9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，用时，优劣考虑清楚，再使用。 （10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。 （11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载webfonts时会阻塞页面渲染损伤性能。 可维护性、健壮性： （1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。 7、页面导入样式时，使用 link 和 @import 有什么区别？7、页面导入样式时，使用 link 和 @import 有什么区别 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，没有兼容问题; 8、介绍一下你对浏览器和浏览器内核的理解？8、介绍一下你对浏览器和浏览器内核的理解？ 主要分成两个部分：渲染引擎(Render Engine)和JS引擎。 渲染引擎：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎：解析和执行JavaScript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向与只指渲染引擎。 常见的浏览器内核比较 浏览器 内核 备注 IE Trident IE、猎豹安全、360极速浏览器、百度浏览器 firefox Gecko 这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 Safari webkit 从Safari推出之时起，它的渲染引擎就是Webkit，一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari。 chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 Opera blink 现在跟随chrome用blink内核。 9、常见浏览器所用内核9、常见浏览器所用内核 10、 JavaScript 有几种类型的值？描述一下他们的存储位置？10、JavaScript 有几种类型的值？描述一下他们的存储位置？ 11、什么是堆？什么是栈？它们之间有什么区别和联系？11、什么是堆？什么是栈？它们之间有什么区别和联系？ 12、浏览器的渲染原理？什么是重绘和回流？ 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 将CSS解析成 CSS Rule Tree 。 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。 注意：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 DOM Tree：浏览器将HTML解析成树形的数据结构。 CSS Rule Tree：浏览器将CSS解析成树形的数据结构。 Render Tree: DOM和CSSOM合并后生成Render Tree。 layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。 painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。 reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 注意：(1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。 (2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 (3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 13、什么是文档的预解析？（浏览器解析过程）Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加 载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析 过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。 14、用纯 CSS 创建一个三角形的原理是什么？x&nbsp;采用的是相邻边框连接处的均分原理。 将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。 15、操作符什么时候用于字符串的拼接？根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。 简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。 16、什么情况下会发生布尔值的隐式强制类型转换？（1） if (..) 语句中的条件判断表达式。（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。（3） while (..) 和 do..while(..) 循环中的条件判断表达式。（4） ? : 中的条件判断表达式。（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。 17、同步和异步的区别？同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。 异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。 18、[“1”, “2”, “3”].map(parseInt) 答案是多少？parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。 此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2” 因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。 19、说说有哪些方法可以实现水平和垂直的居中 20、CSS 优先级算法如何计算？ 21、关于伪类 LVHA 的解释? 22、null 和 undefined 的区别？ 23、 说几条写 JavaScript 的基本规范？ 24、Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"},{"title":"数据指标Vue项目代码交接说明","date":"2021-06-01T09:39:13.000Z","url":"/2021/06/01/bsjj/","categories":[["undefined",""]],"content":"使用到的技术本项目使用的技术是Vue-cli项目框架、Axios数据请求、Element UI框架、xlsx表格读取插件、echarts图标插件、moment时间格式化插件、drag-tree-table树形表格插件、d3高度自由图表插件、数字逐增动画插件等。 项目目录说明简要说明本项目的文件放置规范是不太符合目前行业里的文件存放共识的。 本项目的所有代码都存放于src/sjzb/里。 路由文件存放在src/router里。 静态文件（如字体、css全局样式）存放于src/assets里。 图片资源存放于src/img里。 api交互文件存放于src/api里。 项目的布局参考Axure原型图。链接为 在2021年的10月1日前，可以通过临时域名bishe.chenlx.top进行项目的预览。在这个时间过后，这个域名将会因为过期而撤销。 目录概要整体说明本项目的目录划分目前是按照Axure原型图的规划将文件存放于各个文件夹。也就是说，按照业务逻辑进行分类。但一开始并没有遵循该原则，所以有一部分的文件会存放在其他的地方。对于找不到的文件可以尝试通过路由文件的形式进行搜索，或者树形菜单文件进行查找，下方会进行说明。 项目的访问入口&amp;页面跳转的方法说明项目的入口在App.vue里。当项目开始运行后，通过App.vue进入Vue 项目，再通过index.vue进入项目的整体框架（导航栏、主栏、侧栏）。 导航栏即包含Logo的顶栏。 侧栏是侧边导航栏，目前包含4个按钮，倒数三个按钮目前没有规划。 主栏即主要内容，包含接下来要使用的树形菜单、页面详情。 所有的页面都通过&lt;router-view&gt;将每一个.vue组件中的内容进行切换显示。router-view标签类似iframe标签。能达到当前页面里只有某一个 区域的内容进行变化和渲染。 从index.vue里将进入dbView.vue。这里算是真正的数据指标项目的总框架页面。这个组件包含树形菜单以及页面内容。 树形菜单即页面左侧的树状菜单，包括菜单本身以及搜索框。单击菜单项可以进行页面跳转。 页面内容来自于接下来要说明的各个业务里的组件，通过src/router/index.js进行标明，并在src/sjzb/components/treenav.vue里提供跳转的功能。 Vue项目里，src目录是整个项目的页面资源目录，在代码里，可以通过@符号来代表/src目录。 所有文件夹的首目录一般都叫index.vue，或者xxxTable.vue。在早期时，文件都以业务+Table来标明这是xx业务的首页（如：物理模型的首页，就叫作modelTable.vue，但现在都已用index.vue进行表示。 命名方法文件夹的命名方法通常采用Axure提供的目录进行英文直译。如数据模型就会翻译成dataModel，概念模型就会翻译成concept。出现代码本身内容与文件名不一致的情况，可能是因为该文件在中途发生了逻辑上的变更。 文件更名注意事项基本上来说，每一个文件的文件名不能随意更改，否则其他文件的引用就会出现问题。如果更改了文件名，请统一整个项目的文件名，并批量替换。 Bus.js文件Bus文件是Vue项目里组件之间通信的桥梁。通过bus.$emit和bus.$on可以再不同的页面之间传递参数，在数据指标项目里最明显的效果，就是在物理模型的表格里，想查看C模型的详情信息时，跳转页面同时带上C模型这个参数。 main.jsmain文件是项目的配置文件，主要是对插件的全局引用和一些参数的配置。 publicFunc/index.js这个文件的用途是用来存放一些公共的函数，如：处理数字格式、获取固定的数据集合等等。 router/index.js这个文件存放着项目的路由信息。不论是直接输入url，或者是通过树形菜单点击菜单项，跳转的依据都从该路由文件查找获取。简单说明一下几个参数。 关于每个业务的详细解释数据模型首页（Default.vue）关于树形菜单的说明搜索菜单本身如何增添改用菜单的组件在src/sjzb/components/treenav.vue里。里头存储着菜单信息的对象数组。根据需要进行增删改。 关于图标图标的自动填充js程序里，对图标的某些条件下会进行自动填充。当前对象没有孩子，且没有指定图标时，会填充{}样式的图标。 图标的更换图标来源来自Element UI 以及iconfont网站。如果直接使用eleUI的图标，直接在变量值里填入网站内提供的iconNam计科（如，’+’号，就直接填入el-icon-plus）。如果使用iconfont字体图标，请多补充两个样式名称来进行调整（如添加数据库图标，则样式名要填入iconfont treeIcon icon-shujuku2）。treeIcon为后来临时协调的样式，如果在iconfont网站上寻找的图片比之前的还要偏大或者偏小，这个treeIcon可能协调的效果并不完美，就需要新写一个样式来与整体的图标的大小保持相同了。 关于页面布局的说明整体面包屑上方的总体区域搜索框&amp;热词搜索框一般存在于业务的首页里，如基本词类次、数值指标0-数据模型的首页。 统计卡片统计卡片放置在页面上方，以4种颜色循环显示。目前通过变量写死的方式进行展示。 表单表单的样式经过较为深度的更改，与三种class进行搭配组合出表单的效果。其中，small_input大约占用宽度的1/3；medium_input大约占用宽度的1/2；full_input占用一整行的宽度，更多的样式效果请参考上述说明的全局css文件中对于Input控件的表述。 复杂表单复杂表单就是在常规表单的基础上，与收缩栏进行结合现实的效果，其输入的表单项都归纳到了同一个变量属性里。一般这个变量叫作ikForm。如果有更多其他的表单项，在新建的同时，请把新表单项的属性放入ikForm，否则会因为Vue的数据双向绑定的原因，而无法输入。 标签【更多|···】操作按钮位于页面上方的更多按钮，都用id=\"moremenu\"来标识。借助eleUI的下拉菜单控件来达到呼出菜单的效果。 下方的数据区域标签页略。具体看代码注释。 常规表格略。具体看代码注释。 复杂表单复杂表单的运用情况主要是有收缩栏的布局情况下需要使用。其本质上就是在常规表格的外面再包一层收缩栏。 图形SVG目前这个部分的代码是直接引用生成的svg代码放入.vue组件中（也就是写死的）。项目里唯一有svg的代码，在概念模型-模型详情里的引导图组件中体现。 可拖拽的树形表格可拖拽的树形表格来源于 。其表格可以支持拖拽到其他的结点或者子节点里。但是操作栏只能支持标签，无法支持eleUi的呼出菜单。 另一款树形表格（二改）这一款树形表格控件来源于 这个控件的显示效果比上一款树形表格的显示效果好一些，但是不支持拖拽。且原来的表格树状表格的表头是写死的；为此进行了修改，可以支持props填入表头属性，propsCh填入表头标题达到组件化表格的目的。 常规表格里的【更多|···】操作按钮更多按钮目前统一是用Element Ui的下拉菜单控件，每一个菜单项都依靠当前组件的函数进行组合，一般这个函数叫作getRightClickMenu()或者类似的函数名称。 表格里的右键事件表格中的右击事件采用的是该作者提供的插件进行实现。链接：。该页面已有使用步骤，这里不再另外说明。 原生表格原生表格主要是应对横向表格的需求而使用的。目前使用databaseType样式来统一表示该应用场景的效果。 常规布局编写JSON布局自动生成意义解释在频繁迭代的Axure图里，总会出现非常相似的页面布局。所以这部分相似的页面布局，为了不重复写这些布局代码，就用JSON配置的方式，让页面在渲染时，通过v-for的方法生成页面的每一个控件。一般来说，用JSON生成页面的组件，开头都会有一段注释来进行说明。但这个自动生成的页面再后续开发是不适用的，目前只适用于为了产生DEMO快速开发的情况。 在组件中可能出现某一个div或者其他的标签里，标注着v-if=\"1==2\"，这是为了将这个标签不显示在页面上而进行的标注，v-if属性接收布尔值，从而决定该标签是否渲染到DOM上。而正常来讲，不需要用到的标签为了不让代码混乱，是需要删除的；但是在下一个迭代版本，这个标签里的内容可能又需要显示回来，充满不确定性，故先临时隐藏，等同于style=\"display:none\"。 cardData——上方·表单信息这个变量用于渲染上方表格的内容。 tabsData——下方·标签页信息这个变量用于显示页面下方的标签页的内容信息。如果有多个选项卡，请组成对象数组。 stasticList ——上方·统计卡片区域与上述类似，不再说明。 关于首页文字导入替换功能资产链的首页支持将各个区域的文字进行替换。功能的入口藏在了首页右上方的【···】按钮，单击自动化按钮进入替换操作的页面。借助Excel模板，可以将文字导入进系统进行替换。由于替换文字信息是借助sessionStorage进行存储的，所以替换的生效时段为替换成功后~浏览器关闭页面前。重新打开页面时，替换文字将还原为默认文字。导入的Excel文件需为一开始提供的模板。擅自更改模板填写的区域或其他变更会导致替换失败。 替换的组件路径是src/homepage/importExcel.vue 关于样式全局样式数据指标项目的全局样式基于ElementUI进行了较为深度的更改，为了避免冗余的代码，在src/assets/zbcss.css这个文件里，放入了对于空间样式更改的css内容。这个css文件的代码在全局都是生效的。如果没有特殊的需求，就尽量不要再去变动已存在的css代码。 当前页的样式当前页的样式都各自存在每一个.vue文件最下方的&lt;style scoped&gt;里。在scoped标识符标注的style标签，使得这个样式只在本.vue文件里生效。这个优先级会高于上述说的全局样式，有特殊的样式效果请在这里编写。 关于与后台进行数据交互在以往的版本，仍然有使用Vue+SpringBoot+Neo4j的形式进行数据交换，使用的是axios插件。但前端页面的版本反复迭代，并且目前没有显示真实数据库里的数据的需求，所以在后面的版本中，这个交互的代码被注释或者删除。后续有需求进行数据交互时，请在main.js中指定axios的请求url，并在/src/api目录新增js文件并编写交互请求的函数。 运行使用项目的运行依赖npm工具、node.js；使用vue-cli工具编写及维护项目；项目中使用到了axios、ElementUI、momentjs等的插件。在新环境运行前，需要先安装node软件（最新版本即可）、npm包管理工具（7.14.0）。 安装完后，请全局下载vue-cli脚手架工具。在cmd输入npm install vue-cli -g即可安装。 接着，需要下载项目插件依赖，这些依赖的包名都被统一到了package.json管理，安装完的插件包则会被放置到node_modules文件夹。项目包已内含node_modules，但如果运行失败，且原因可能是包丢失或版本不一致的话，可以再尝试npm install命令进行包安装。 如电脑环境已有上述安装，可忽略；如果运行碰到了其他的问题，可以尝试上网搜索一下，一般对于安装运行过程中的问题网上都会有解答。 解压项目到指定位置，根据不同环境的需求进行运行。 开发环境运行在开发环境，输入npm run dev进行启动。设定的访问地址为。根据实际端口占用的情况可能会变更（例如我这台电脑实际运行的端口是8081）。 打包文件打包出来的文件即可用Nginx等软件进行部署访问。首先输入npm run build命令，对项目进行打包。生成的文件夹叫作dist。访问index.html即可通过入口进入项目。但是！直接打开文件是无法访问的，一定要通过部署nginx、apache等软件才能使用。"},{"title":"毕业设计论文：基于javaEE的房屋租赁管理系统的设计与实现","date":"2021-05-27T07:54:15.000Z","url":"/2021/05/27/bysj/","tags":[["论文","/tags/%E8%AE%BA%E6%96%87/"],["毕业设计","/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"],["Vue","/tags/Vue/"],["JavaEE","/tags/JavaEE/"]],"categories":[["undefined",""]],"content":"福建工程学院本科毕业设计（论文）作者承诺保证书本人郑重承诺：本篇毕业设计（论文）的内容真实、可靠。如果存在弄虚作假、抄袭的情况，本人愿承担全部责任。 学生签名：2020 年 1 月 日 福建工程学院本科毕业设计（论文）指导教师承诺保证书本人郑重承诺：我已按有关规定对本篇毕业设计(论文)的选题与内容进行了指导和审核，且提交的毕业设计（论文）终稿与上传至“大学生论文管理系统”检测的电子文档相吻合，未发现弄虚作假、抄袭的现象，本人愿承担指导教师的相关责任。 指导教师签名：2020 年 月 日 目 录Md文件中忽略 基于javaEE的房屋租赁管理系统的设计与实现 摘 要在如今的互联网时代，传统繁琐的租赁流程已不太适用于当下忙碌而又快节奏的生活。租客想在工作的城市借居却很难即时发现自己最为心仪的房源；流动租客过多时也导致房东难以进行管理。因此，本课题借由这一社会现象设计并实现了一套房屋租赁管理系统。该课题的开发语言选择Vue与JavaEE，采用ElementUI、SSM等技术框架；使用Tomcat搭建服务器，以及使用MySQL数据库进行数据存储。系统拥有搜索房源、租赁房源、签订合同、支付账单等功能。通过本系统，租客可以直接在网页搜索查询自己想要的房屋信息；通过查阅房源的评分，租客能对房源的客观状态一目了然，同时，也支持租客在网站内完成预约上门看房、申请租房、签约合同、支付房租等功能；房东也可以在网站上直接对合同、账单、租客预约等进行便捷的处理。在处理租客的租房申请时，房东也能根据租客的评分来决定是否向租客出租以避免糟心的问题。系统可以简化租赁流程，直接在一个网站上存储相应的租赁内容并提供随时查阅。不论是租客还是房东，在租赁结束后都能为对方进行评价，形成一套简单的用户评价体系。系统完成后的测试结果表明，该系统运行状态良好，对各个功能进行了不同环境的测试，基本符合用户的良好体验。 关键字：房屋，租赁，Vue，J2EEDesign and Implementation of a House Rental Management System Based on JavaEE AbstractIn today’s Internet age, the traditional tedious rental process is no longer suitable for today’s busy and fast-paced life. Tenants want to live in the city where they work, but it ’s difficult to find their favorite property instantly; too many mobile tenants also make it difficult for landlords to manage. Therefore, the subject designs and implements a house rental management system based on this social phenomenon. Vue, SSM and other technologies were selected as the development language used in this system. Using Tomcat to build the server, and select MySQL database for data storage. The system has functions such as searching for listings, renting listings, contracts, and paying bills. Through this system, tenants can search for the desired housing information directly on the webpage. By checking the ratings of the listing and the landlord, the objective status of the listing or the landlord can be seen at a glance. Apply for rent online, read and sign the contract, pay rent bill. The landlord can also conveniently handle the contracts, the bills, the appointments and the bill directly on the website. When processing a housing application, you can decide whether to rent based on the tenant’s evaluation. Avoid bad experiences. The system can make most of the leasing process paperless, store the corresponding content directly on a website and can check it at any time. Both the tenant and the landlord can evaluate the other party after the lease ends, forming a simple user evaluation system. The test results after the completion of the system show that the system is running well, and various functions have been tested in different environments, which basically meets the user’s good experience. Keywords: House, Rent, Vue, J2EE 第一章 概述1.1 课题背景及意义近年来，我国的社会经济迅猛发展，工作机遇也越来越多，市场对于房屋租赁的需求也在不断增多[1]。大部分的年轻人喜欢到大城市去寻找工作，因此，伴随着这一现象的基础问题之一就是住宿。 中国之大，流动人口众多。在中国加入WTO后，房屋租赁行业受到国外竞争者的挑战[2]。如今，网络贯穿着我们生活的各个场景，人们越来越希望在繁琐重复的事情上节省更多的时间。传统的那种：租客四处寻、房东、房东用纸笔记录的方式已经不是那么得适用于目前的情况。而租客身在异乡人生地不熟，很难一时发现自己最为心仪的出租房；流动租客过多时，房东也很难进行便捷管理。本课题准备设计一个针对租客、房东两位核心角色，提供便捷寻房、租房和住房的平台。便捷二字，对于为生活奔波的租客、管理的房东来讲无疑是最重要的，所以，本课题的研究对于这两类角色有着减轻负担、节省时间、提升生活里的幸福感的意义。 1.2 国内外现状1.2.1国内现状同发达国家相比，我国的租赁公寓起步较晚，租赁政策较少，因此我国目前的租赁市场并不健全，传统的住房租赁市场主要为个体房东，机构参与者较少[11]。稀少的平台导致在某些区域里，租赁价格与实际价值有出入、价格不透明，从而存在不同的租客租赁同一间房源时，存在没有理由的价格差异的现象。 1.2.2国外现状与大多数发展国家而言，国外的房屋租赁率较高主要是一种分配制度造成的[3]。德国的首都柏林大约有22.5万套“社会住房”专供低收入者租住[4]；日本东京为了解决高昂的租房金问题政府制定一套完善策可以根据不同的收入缴纳租金[6]。国外的房屋租住政策使得国外的房屋市场发展迅猛。一是通过共享信息平台政策使得国外的房屋市场发展迅猛，或者房屋租赁软件来推广业务；二是通过先进的互联网技术提高数据处理效率，完全替代手工录用方式。[7][8] 第二章 相关技术2.1开发环境开发工具：IntelliJ IDEA 2019.1.1 数据库管理工具：Navicat for MySQL5.5 开发语言：Vue + JavaEE 2.2相关技术2.2.1 Vue技术Vue.js是一套构建用户界面的渐进式框架，他能够更方便的进行页面上数据的处理，并且实现单页面多内容渲染。 2.2.2 MySQLMySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 2.2.3 SSMSSM是SpringMVC + Spring + MyBatis的简称，它是目前比较主流的JavaEE企业级的后台框架。使用它能快速搭建起系统的后台功能。 第三章 系统需求分析3.1 系统概述本课题网站名称为“嘤嘤租房网”，主要的目的是实现以下功能：用户注册、用户登录、浏览房源、申请看房、申请租房等。 3.2 系统业务分析“嘤嘤租房网”的核心功能为租赁房源，所以本网站的角色一共有三位——分别是租客、房东和管理员。 租客的业务流程分析在访问“嘤嘤租房网”时，可先浏览网站上已经上架的房源信息，但无法进行后续的操作。租客在登录账号并实名认证通过后，才可以使用网站其余功能，如向房东发起看房预约、租房申请等。本网站租客的操作流程如图3-1所示。 图3-1 租客的业务流程活动图 房东的业务分析 房东 房东在登录账号，并且实名认证后，房东才可以使用网站其余的功能。房东可以发布自己的房源，处理看房预约，处理租房申请等。本网站房东的操作流程如图3-2所示。 图3-2 房东的业务流程活动图 管理员 网站的实名信息与房源的信息，都需要通过管理员进行审核。网站管理员的操作流程如图3-3所示。 图3-3 网站管理员的业务流程活动图 3.3 功能需求3.3.1 网站前端模块“嘤嘤租房网”的前端有网站欢迎页、搜索结果页、详情页、登录页、注册页、房东个人中心和租客个人中心，供用户完成以下功能： 搜索房源 不论浏览“嘤嘤租房网”的访问者是否登录，网站都支持房源的检索。访问者可以根据自己需要输入关键字检索特定范围内的房源信息。 查看房源详情 用户可以单击搜索结果页面的某一条信息，在详情页面查看更完整的房源信息。如：浏览地图位置、房源的介绍文案、房源的住后评价等信息。 用户注册与登录 当访问者想要操作网站的更多功能时，需要访问者拥有本网站的账号。访问者可以登录账号再进行操作，或者先注册再进行登录。 发起看房预约 当租客用户想要上门看房，并没有明确要租赁的情况时，可以提交线下上门看房的预约给房东用户。 发起租房申请 当租客用户想要租住房源时，可提交租房申请给房东。 合同功能 租客和房东在双方都意向租赁时，需要依靠合同模块达成租赁关系。租客向房东发起的租房申请，房东可以依据此申请发起租赁合同。合同功能是“嘤嘤租房网”其他功能的依据。 评价功能 租客和房东可以使用此功能为对方评价。“嘤嘤租房网”是基于实名的租房网站，为对方客观地评分对下一次租赁时起到了重要的参考作用。 实名功能 出于租赁的性质，用户使用网站时必须先进行实名再进行租赁。 房源功能 房东可以通过此功能发布和维护自己的房源信息。 在前台模块中，系统根据登录状态，将用户分为两种角色。各个角色的用例如下所描述。 网站租客用例 租客未登录时仍可访问“嘤嘤租房网”的展示页面，其可以检索房源、查看房源详情。租客也可根据需要使用注册和登录功能，拥有一个属于自己的账号。具体的用例如图3-4所示。 图3-4 网站租客用例图 用户发起看房预约功能的详细描述如表3-1所示。 表3-1 发起看房预约功能用例描述 名称 内容 用例编号： US01 用例名： 发起看房预约 参与者： 用户 触发因素： 用户想上门看房 输入信息： 填写预约时间；选填给房东的留言 结果： 预约提交成功 后置条件： 数据库中的上门看房预约表成功存储了该用户预约申请。 过程： 1）输入预约时间 2）提交预约，点击“预约”按钮 用户提交租房申请功能的详细描述如表3-2所示。 表3-2 提交租房申请功能用例描述 名称 内容 用例编号： US02 用例名： 发起租房申请 参与者： 用户 触发因素： 用户想申请租赁房源 输入信息： 填写租赁的开始日期和结束日期 结果： 申请提交成功 后置条件： 数据库中的租赁合同表成功存储了该用户租房申请。 过程： 1）输入租赁时间范围 2）提交预约，点击“提交申请”按钮 支付账单功能的详细描述如表3-3所示。 表3-3 支付账单功能用例描述 名称 内容 用例编号： US03 用例名： 支付账单 参与者： 租客用户 触发因素： 租客用户想要支付房东用户发起的账单 后置条件： 正确跳转到支付宝的支付页面 线下支付的提示框正确显示 订单状态正确更改 过程： 点击“支付宝线上支付”按钮或点击线下支付按钮 评价房源和房东的详细描述如表3-4所示。 表3-4 用户登录功能用例描述 名称 内容 用例编号： US04 用例名： 评价房东与房源 参与者： 租客用户 触发因素： 用户在合同结束后评价房源和房东 输入信息： 选定评分，输入评价内容 后置条件： 数据库的房源评价表成功新增一条评价信息 数据库的用户评价表成功新增一条评价信息 过程： 点击“我要评价TA”按钮 选择评价星级 点击“提交评价”按钮。 网站房东用户用例 房东角色的用户可以使用租赁流程所需要的功能，如：发起合同、发起账单等。具体的房东角色的用例图如图3-5所示。 图3-5 网站房东的用例图 处理看房预约功能的详细描述如表3-5所示。 表3-5处理看房预约功能用例描述 名称 内容 用例编号： US05 用例名： 处理看房预约 参与者： 房东用户 触发因素： 房东用户想处理租客用户发起的看房预约 结果： 通过预约/退回预约 续表3-5 后置条件： 存储在数据库预约表的预约信息的状态成功更改为拒绝状态/预约成功状态 过程： 选择房东处理选项 点击“提交处理”按钮 发起账单功能的详细描述如表3-6所示。 表3-6发起账单功能用例描述 名称 内容 用例编号： US06 用例名： 发起租赁账单 参与者： 房东用户 触发因素： 房东用户想对租客发起租赁账单 结果 账单成功创建，通知租客 输入信息： 选择收租的对象；填写最新房源水表与电表读数；输入调节费用和费用说明 后置条件： 数据库中的账单表成功存储该条账单信息 过程： 点击“发起账单”按钮 选择收租对象，填写租赁产生的费用信息和读数 核对信息并点击“完成发起”按钮 取消账单功能的详细描述如表3-7所示。 表3-7取消账单功能用例描述 名称 内容 用例编号： US07 用例名： 取消租赁账单 参与者： 房东用户 触发因素： 房东用户想取消账单的收租 结果 账单取消成功，租客无法支付 后置条件： 数据库中的账单表里对该账单信息的账单状态成功的更改为已取消状态； 数据库的房源表成功回滚到上一次的抄表数据 过程： 点击“查看”按钮 点击“取消这份账单”按钮 点击确认框的“确认”按钮 发布房源信息功能的详细描述如表3-8所示。 表3-8发布房源信息功能用例描述 名称 内容 用例编号： US08 续表3-8 用例名： 发布房源信息 参与者： 房东用户 触发因素： 房东用户想在网站发布自己的房源信息 结果 房源信息成功上传 输入信息： 输入房源宣传标题、房源相关属性、租赁价格、宣传图片、介绍内容等。 后置条件： 数据库中的房源表里成功存储该房源信息，等待管理员审核 过程： 点击“新增房源”菜单 输入介绍标题、房源楼层、面积、房屋租赁定价 输入坐落的省市区信息、详细地址、房屋的相关属性 上传房源图片，输入房源介绍内容 点击“提交房源信息新增”按钮 签约合同功能的详细描述如表3-9所示。 表3-9 签约合同功能用例描述 名称 内容 用例编号： US09 用例名： 签约合同 参与者： 租客用户 触发因素： 用户想租赁房源进行合同签约 后置条件： 数据库中的合同表里该申请信息的申请状态改已生效 过程： 点击“去签约”按钮 浏览并勾选“我同意签约合同”的复选框 点击“提交”按钮 提交实名信息功能的详细描述如表3-10所示。 表3-10 提交实名信息功能用例描述 名称 内容 用例编号： US10 用例名： 提交实名信息 参与者： 用户 触发因素： 用户想要在本网站进行实名认证 输入信息： 输入真实姓名、身份证号码；上传身份证国徽面、头像面和手持身份证的照片。 后置条件： 数据库的实名信息表成功插入用户数据。 过程： 输入姓名和身份证号码，上传证件照片 点击“提交”按钮 3.3.2 网站后端模块后端模块基于网站的租赁需求，设立了管理中心，其为网站管理员的管理平台。网站的房源信息、实名信息都需要先经过管理中心审核后，信息才能通过继续下一步的流程。具体的管理员角色的用例图如图3-6所示。 图3-6 管理员中心的用例图 审核房源信息功能的详细描述如表3-11所示。 表3-11 处理看房预约功能用例描述 名称 内容 用例编号： US11 用例名： 审核房源信息 参与者： 管理员 触发因素： 管理员想审核网站房东用户上传的房源信息 结果： 审核通过/审核退回 后置条件： 存储在数据库的房源表的信息的审核状态成功更改为审核通过/审核被驳回； 审核通过时，网站前端可以搜索到该房源。 过程： 点击“查看详情”按钮 选择管理员处理选项 点击“提交处理”按钮 第四章 系统设计4.1系统概要设计“嘤嘤租房网”是一个为用户提供在线房源租赁的网站。该网站为房东为用户提供在线发布房源的平台，使得租客用户可以足不出户就可以知晓到房东的房源信息；租客可以在线向房东发起看房预约和申请，也可以与房东在网站上签署合同、支付账单等。本网站具有从看房到合同、账单到评价等基本的租赁流程，使得租客和房东两大核心角色在租赁这件事情不再糟心，把更多的精力投入生活。 4.2功能模块设计“嘤嘤租房网”拥有租赁房源所需要的基本流程。网站的功能结构如图4-1所示。 图4-1 网站的功能结构图 4.2.1 公共前端模块公共前端模块包括了用户登录、用户注册、浏览信息、提交信息等功能。 用户注册功能 用户点击输入框下方的“登录/注册”按钮后，系统会跳转到登录界面。如果浏览者希望注册一个本网站的账号，可以接着单击“注册”按钮，系统会显示一个注册的表单供访问者填写。访问者需要填写手机号码、访问本网站的密码、登录角色和手机验证码功能。访问者点击注册后，系统会校验表单是否填写完全，校验手机格式，并且校验验证码是否正确。上述校验规则都通过后，系统会提示注册成功，并且自动返回到登录界面。注册流程如图4-2所示。 图4-2 用户注册活动图 发起上门看房预约/发起租房申请 访问者成为本网站用户后，可以进行租房的其他操作，如看房预约、租房申请等。在前端的房源详情页，如果浏览的房源状态为空闲时，页面会开放预约和租房的按钮供用户使用。用户只有实名通过的情况下可以使用这两个功能，否则无法使用。用户使用前端的功能活动如图4-3所示。 图4-3 用户发起看房预约和租房申请的活动图 4.2.2 个人中心模块个人中心模块包括了房东个人中心和租客中心两个中心。个人中心包括了实名功能、个人信息编辑功能，不同角色的预约管理功能、租房申请功能、合同功能、账单功能等。 修改密码功能 当用户想要修改自己的登录密码，需要先输入原始的密码，再输入新的密码才能完成更改。修改密码的活动如图4-4所示。 图4-4 用户修改密码的活动图 实名认证功能 用户需要提交自己的真实姓名、身份证号码、身份证的正反面和手持身份的照片上传到系统。等待系统的管理员审核。审核通过后方可使用网站的其他功能。 个人信息编辑功能 用户可以编辑自己的个人信息，如昵称、性别等。个人信息主要体现在房屋评价里。 租赁合同功能 用户可以在这里浏览有关于自己的合同的信息，所有的合同会以表格的形式展示给用户。根据用户的角色，系统会给出不同的操作按钮。房东可以处理租客发起的申请拉起一份合同发送给用户签约；租客也可以查看并签约拉起的合同。用户操作合同的活动如图4-5所示。 图4-5 租客与房东签约合同的泳道活动图 账单功能 租客在租赁期间产生的租赁费用，需要房东去向租客发起账单。发起后，租客将收到账单的信息。租客查看账单后可以选择支付方式，向房东支付账单。租客选择线上支付时，租客支付后，账单将变更为已支付状态；租客选择线下支付给房东后，房东需要手动选择房租已入账，账单才能结束。用户操作账单的活动如图4-6所示。 图4-6 房东与租客账单操作的泳道活动图 预约功能 用户可以在自己的中心里查看与自己有关的预约信息。所有的预约信息会以表格的形式呈现在页面里，并且根据角色和预约的状态提供操作按钮。用户可以对预约进行处理。 房源功能 房源功能主要提供给房东角色使用。房东可以利用房源功能新发布自己的房源信息、维护自己的房源信息。新增或维护后的房源信息。 4.2.3 管理员模块 房源信息审核功能 房东在上传房源信息，或者维护房源信息后，公共前端页面并不能直接搜索到房源的详情。只有管理员审核通过后，房源才允许被用户搜索并查看、租赁等。 实名认证信息审核功能 本网站的用户需要进行实名认证后才允许使用网站的其他功能。所有的实名信息都会被提交至管理员中心等待管理员审核。管理员审核实名信息的活动如图4-7所示。 图4-7 管理员审核信息的活动图 4.3数据库设计4.3.1 概要设计根据前期的调查与在分析，得出以下数据库的设计概念。ER图来描述本网站的概念结构如下图4-8所示。 图4-8 网站ER图 首先是用户实体图，如图4-9所示。它拥有用户手机号、用户登录密码、角色等属性，记载着用户的个人信息。 图4-9 用户实体图 其次，是用户的实名认证信息的实体图，如图4-10所示。他记载着用户的真实信息，包括身份证号码与证件照片等。 图4-10 用户实名信息实体图 用户在浏览的核心信息，房源的实体图，如图4-11所示。其记载着房源的所有信息。 图4-11 房源实体图 用户的租赁产生的费用账单，存储在租赁账单的实体里，如图4-12所示。 图4-12 租赁账单实体图 租客和房东签订的合同信息，存储在租赁合同的实体里，如图4-13所示。 图4-13 租赁合同实体图 管理员的实体里存储着管理员的登录信息，如图4-14所示。 图4-14 系统管理员实体图 4.3.2 物理设计根据本课题的需求分析后，归纳并设计出以下数据库表。都有：用户表，管理员表，房源信息表，房源评价表，用户评价表，租赁合同表，看房预约表，租赁账单表，用户实名信息表，中国省市区信息表，房源地图经纬度记录表。 用户表 用户表存放的是用户的信息列表，主要用于记录用户的手机号码、个人信息、登录密码和角色类型。用户表的设计结构图如表4-1所示。 表4-1 用户表(users) 代号 字段名 数据类型 大小 说明 空值 描述 1 u_id int 主键 否 用户表的ID 2 u_role int 否 用户角色 3 u_head_image varchar 255 是 用户头像 4 u_telephone varchar 11 否 电话 5 u_pwd varchar 30 否 密码 6 u_name varchar 25 否 昵称 7 u_sex int 是 性别 8 u_state int 否 用户状态 管理员表 管理员表存放的是管理人员的信息的数据表，包含了管理员的登录账号和登录密码。表结构如表4-2所示。 表4-2 管理员表(systemuser) 代号 字段名 数据类型 大小 说明 空值 描述 1 sysid int 主键 否 管理员表的ID 2 sysname varchar 25 否 管理员登录名 续表4-2 3 syspwd varchar 30 否 管理员密码 房源信息表 房源信息表储存了房东发布的房源信息，房源表同时还储存了房源的电表和水表，生成账单时，房源的表读数会同步更新数据。表结构如表4-3所示。 表4-3 房源信息表(house_infomation) 代号 字段名 数据类型 大小 说明 空值 描述 1 h_id int 主键 否 2 h_name varchar 255 是 房源宣传文案 3 h_address_city int 否 所属城市 4 h_address_detial varchar 50 否 房源地址 5 h_house_floor int 否 房源楼层 6 h_houst_information varchar 500 否 房源介绍 7 u_id int 否 房主ID 8 h_rent_price float 否 房租价格 9 h_image varchar 255 否 房屋图片 10 h_rent_state int 否 出租状态 11 h_water_number int 否 水表底数 12 h_electricity_number int 否 电表底数 13 h_audit_state int 否 房源上架审核状态 14 h_area_number float 否 房源面积 15 h_room_type int 否 房屋户型-几室几厅 16 h_decorate_situation int 否 房屋装修情况 17 h_post_time date 否 发布日期 18 h_pay_type int 否 意向押付方式 房源评价表 房源评价表是基于合同结束后，租客对房东的房源的一个评价。表的内容包含租客和房东的ID，房源的ID和评价星级等等字段。表结构如表4-4所示。 表4-4 房源评价表(house_evaluation) 代号 字段名 数据类型 大小 说明 空值 描述 1 he_id int 主键 否 2 u_id int 否 用户ID 3 h_id int 否 房源ID 续表4-4 4 c_id int 否 合同ID 5 he_date date 否 评价时间 6 he_content varchar 500 是 评价内容 7 he_sorce int 是 房屋评价星级（1-5） 8 he_anonymous int 否 是否匿名 用户评价表 租赁结束后，用户对用户的评价会储存在用户评价表里。表的结构如表4-5所示。 表4-5 用户评价表(user_evaluation) 代号 字段名 数据类型 大小 说明 空值 描述 1 ue_id int 主键 否 评价ID 2 c_id int 否 基于的合同号 3 u_id int 否 评价人ID 4 ue_date date 否 日期 5 ue_content varchar 255 是 内容 6 ue_sorce float 否 评分 7 ue_post_u_id int 否 评价对象ID 租赁合同表 租赁合同表是储存了当租客发起租房的申请，房东将合同信息补齐后，双方约定的合同信息。存储的字段可供系统生成完整的合同书，也可以提取大纲供用户查看一目了然。表结构如表4-6所示。 表4-6 租赁合同表(rent_contract) 代号 字段名 数据类型 大小 说明 空值 描述 1 c_id int 主键 否 合同ID 2 o_create_time datetime 否 创建时间 3 h_id int 否 房源ID 4 o_tenants_id int 否 租客id 5 o_master_id int 否 房东id 6 o_rent_money float 否 房租 7 o_rent_type int 否 押付类型 8 o_house_full_address varchar 255 否 房源完整地址 9 o_house_area float 否 面积 10 o_house_deposit float 否 押金 续表4-6 11 o_sign_time datetime 否 租客签约时间 12 c_perform_start_date date 否 合同开始日期 13 c_perform_end_date date 否 合同结束如期 14 c_contract_state int 否 合同状态 看房预约表 看房预约表是租客对某一房源感兴趣，想要是实地查看房源时向房东提交申请的数据表。主要的字段为租客ID、房源ID、预约时间、租客留言和房东回复等。表结构如表4-7所示。 表4-7 预约上门看房表(see_house_application) 代号 字段名 数据类型 大小 说明 空值 描述 1 sh_id int 主键 否 预约ID 2 o_tenants_id int 否 租客ID 3 h_id int 否 房源ID 4 o_master_id int 否 房东ID 5 sh_see_house_time datetime 否 预约时间 6 sh_tenants_message varchar 255 是 租客留言 7 sh_master_message varchar 255 是 房东回复 8 sh_state int 否 预约状态 租赁账单表 租赁账单表是用于存储租客在租赁期间产生的租赁费用需要结算的数据表。由于涉及支付，本表格的字段有相关的读表信息、收费单价、租客ID、房东ID、创建时间、支付时间、支付方式、支付状态等。表结构如表4-8所示。 表4-8 租赁账单表(rent_order) 代号 字段名 数据类型 大小 说明 空值 描述 1 o_id int 主键 否 账单ID 2 o_create_time datetime 否 账单创建时间 3 c_id int 否 合同ID 4 o_tenants_id int 否 租客ID 5 o_master_id int 否 房东ID 6 o_last_electric_number int 否 上一周期电表读数 7 o_now_electric_number int 否 本期电表读度 8 o_last_water_number int 否 上一周期水表读数 续表4-8 9 o_now_water_number int 否 本期水表读度 10 o_electric_price float 否 本期电费单价 11 o_water_price float 否 本期水费单价 12 o_house_rent_price float 否 租赁房租 13 o_adjust_price float 否 调节费 14 o_adjust_explain varchar 50 是 调节费备注 15 o_order_money float 否 账单总金额 16 o_pay_method int 否 支付方式 17 o_pay_state int 否 支付状态 18 o_pay_dead_line date 否 支付截止时间 19 o_pay_time datetime 否 租客支付时间 用户实名信息表 用户实名信息表顾名思义，存储着用户的实名数据。包括真实姓名，身份证号码等。表结构如表4-9所示。 表4-9 用户实名表(userverify) 代号 字段名 数据类型 大小 说明 空值 描述 1 v_id int 主键 否 实名ID 2 u_id int 否 用户ID 3 v_real_name varchar 5 否 用户真实姓名 4 v_id_card_number varchar 18 否 用户身份证号码 5 v_real_id_card_image1 varchar 55 否 身份证头像面图片地址 6 v_real_Id_card_image_2 varchar 55 否 身份证国标面图片地址 7 v_real_Id_card_image_with_person varchar 55 否 人手持身份证图片地址 8 v_upload_time datetime 否 用户上传更新时间 9 v_audit_time datetime 是 管理员审核时间 10 v_verify_state int 否 实名信息审核状态 第五章 系统实现5.1公共前台模块5.1.1 欢迎页面网站的前台模块默认从欢迎页开始显示，该页面提供了登录注册的入口和搜寻房源信息的输入框。输入搜寻内容点击按钮后，页面则会罗列出相关的房源信息。网站的欢迎页面如图5-1所示。 图5-1 “嘤嘤租房网”欢迎页 5.1.2 用户注册页用户在使用“嘤嘤租房网”时，需要注册一个自己的账号。本网站以手机号码作为登录账号。注册表单在提供用户输入信息的同时加入了校验规则。如：手机号码一定要为中国大陆手机的11位格式、密码和确认密码需要保持一致等。用户注册页面如图5-2所示。 图5-2 用户注册页面 注册的代码如下： 5.1.5 房源详情页当用户对其中某一条的房源信息有兴趣，可点击该条标题，系统会跳出新的页面，为租客展示房源的详情信息。页面主要分成房源信息、房源说明、房源评价三个部分。 第一部分为房源的信息介绍。内容包括房源的宣传标题、发布时间、房源的各类属性等。单击左边的图片，会全屏显示该房源的图片。此外，这个部分还有两个操作按钮，分别是预约上门看房和发起租房申请。详情页第一部分界面如图5-5所示。 图5-5 房源详情页第一部分界面 这两个功能使用的前提为用户已经登录，且已经通过实名认证。如果实名认证未提交、审核中或者被退回，均属于未实名状态，使用这两个功能时会被拦截，并给出相应的提示。其中，实名信息审核中的拦截通知如图5-6所示。 图5-6 使用功能被拦截的通知界面 使用功能的代码如下： 用户想要上门看房，点击预约上门看房按钮后，系统会显示一个表单给用户选择期望上门看房的时间和想对房东说的留言。输入完信息后点击确定后，该预约申请会发送到房东。发起看房预约的表单如图5-7所示。 图5-7 发起看房预约的表单界面 用户有意向租赁房源，点击发起租房申请按钮后，系统会显示申请的表单给用户填写期望入住的时间范围。对于时间范围提供了三个快捷选项。如果用户想租赁其他范围的时间，也可以自己选择租赁区间，且用户只能被允许选择未来时间。提交后，系统会将租房申请提交给房东。发起租房申请的表单如图5-8所示。 图5-8 发起租房申请的表单界面 房源详情页的第二部分主要有房源的介绍和房源的位置两个信息。房源介绍为房东录入的介绍信息，地图使用高德地图的接口，可以通过拖动、缩放等方式知晓房源周围的地理交通。详情页的第二部分的界面如图5-9所示。 租客发起租房申请的代码如下： 图5-9 房源详情页第二部分界面 第三部分为房源的评价部分。当租客结束租房后，系统会提供评价功能让租客去评价这个房源。评价的评价人昵称、分数和内容都会公开在这里。因为评价功能只对已经租赁过该房源、并且租赁已结束的租客开放，真实性相比较会提高很多，可以作为租客租赁房源的一大权衡依据。第三部分的界面如图5-10所示。 图5-10 房源详情页的第三部分界面 5.2 租客中心模块5.2.1 租客中心的欢迎页当租客登录成功后，系统会识别角色并跳转到租客中心。租客中心的界面为侧栏和主栏的布局。在没有使用租客中心的任何功能时，主栏为欢迎状态。租客可以通过侧栏选择需要使用的功能。租客中心提供的功能主要有：实名认证、修改密码、修改个人信息、查看合同、查看账单、查看预约等。租客中心的欢迎页如图5-11所示。 图5-11 租客中心的欢迎页 5.2.2 租客中心的实名认证功能用户使用点击实名认证后，主栏会显示实名认证的表单。如果用户没有实名信息，或者实名信息被退回，表单会提示用户重新输入相关的实名信息。表单也会显示用户提交的时间和管理员审核的时间，如果有提交实名信息记录，实名信息审核的状态会显示在表单的左上角以章戳的形式标注。用户实名认证的界面如图5-12所示。 图5-12 租客中心的欢迎页 用户提交实名信息的代码如下： 5.2.3 租客中心的密码修改功能用户点击修改密码功能后，主栏会显示相应的表单。该表单拥有基础的校验规则，在校验通过后，新的密码会以MD5加密后更新至数据库当中。修改密码的界面如图5-13所示。 图5-13 租客中心的密码修改界面 修改密码的主要代码如下： 5.2.4 租客中心的个人信息编辑功能用户想要编辑自己的个人信息时，可以使用此功能。表单可以及时更换头像、昵称、性别等字段。该信息主要用于显示在评论部分。个人信息编辑的界面如图5-14所示。 图5-14 租客中心的个人信息编辑界面 上传更新自己头像的主要代码如下： 5.2.5 我的合同功能当租客想要查看自己签约的和待签约的合同时，可以在这里预览。如果租客拥有待签约的合同，则可以点击操作列的签约按钮；如果租客想回顾查看自己的合同信息时，也可以点击详情操作进行预览。合同功能的界面如图5-15所示。 图5-15 租客中心的合同列表界面 租客点击详情后，系统会显示用于展示合同的主要信息的模态框。租客同样可以点击按钮查看合同详情。合同详情的界面如图5-16所示。 图5-16 合同详情的模态框界面 当租客想要提前退房，需要在合同的模态框里，点击退房的按钮。因为提前结束合同属于违约的操作，所以系统会提示租客该操作的后果。违约提示框如图5-16所示。 图5-16 租客违约退房的确认框 租客退房（违约）的主要代码如下： 5.2.6 我的账单功能租客查看自己的账单信息时，点击按钮后主栏会展示租客的所有账单信息。租客可以单击“详情”按钮查看账单的所有信息。我的账单界面如图5-17所示。 图5-17 租客账单列表界面 租客点击详情按钮后，系统会显示该条账单的所有信息。“嘤嘤租房网”已对接支付宝支付，如果该账单属于未支付状态的账单，系统会开放支付按钮供租客支付。账单详情的界面如图5-18所示。 图5-18 账单详情的界面 用户使用支付宝付款，发起页面的主要代码如下： 5.2.7 我的看房预约功能当租客想要查看自己预约申请，或者想要查看房东的回复时，需要在“我的看房预约”界面查看，界面如图5-19所示。 图5-19 看房预约列表界面 如果租客发起的看房预约未被房东处理，租客可以取消自己发起的预约；对于已经处理过的预约申请，系统仍然为租客保留查看的功能。界面如图5-20所示。 图5-20 预约详情的界面 5.3 房东中心模块5.3.1 房东中心的欢迎页当房东角色的用户登录成功后，系统会跳转到房东的个人中心页面，等待房东的下一步操作。 5.3.2 新增房源功能房东在实名通过后，可以根据自己的需要发布自己拥有的房源。在表单里，需要房东录入介绍标题、房源图片和租赁价格等租赁房源需要的相关信息。房东填写完点击提交按钮，表单对输入的信息校验通过后，则会把房源的信息上传至系统，等待管理员审核。新增房源信息的界面如图5-22所示。 图5-22 新增房源信息的界面 房东新增房源的主要代码如下： 5.3.3 房源列表功能房东想查看自己房源的信息或者更新自己的房源信息时，房东需要点击房源列表，主栏会显示自己拥有的房源信息的列表。列表界面的布局主要为表格和按钮。列表展示房东的房源信息，按钮为刷新数据按钮，如果数据没有更新至最新，房东可以手动更新。房东的房源列表的界面如图5-23所示。 图5-23房源列表界面 展示属于房东的房源列表的主要代码如下： 房东查看某一条房源信息的详情编辑按钮，系统会弹出一个模态框，模态框将会展示该条房源的详细信息。房东可以对这条房源进行信息的维护更新；如果房源处于出租状态，房源信息无法更新，需要等房源租赁结束，状态为空闲时，房东才被允许维护房源信息。房源详情编辑“辅助介绍”步骤的界面如图5-24所示。 图5-24 房源编辑详情的模态框界面 5.3.4 看房预约管理功能租客发起的看房预约都会被归纳到看房预约管理列表里。房东在侧栏单击预约管理按钮时，主栏会显示预约的信息列表。上门看房预约管理的界面如图5-25所示。 图5-25 上门看房预约管理列表的界面 系统会对不同状态的预约，开放相应的操作按钮。看房预约的处理的界面如图5-26所示。 图5-26预约详情的处理模态框界面 5.3.5 合同管理功能租客在网站向自己的房源发起的所有租房申请都会被归纳到房东中心的合同列表里。房东可以对合同进行进一步的处理。如，发起合同、查看合同。合同管理的界面如图5-27所示。 图5-27 房东中心的合同管理列表界面 房东可以对租客发起的申请进行处理。单击“发起合同”按钮后，系统将会显示租客的信息和房源的信息供房东进行二次确认，并提供本次合同的相关数据。房东也可以点击“拒绝发起签约”拒绝该申请。房东发起合同的模态框界面如图5-28所示。 图5-28 房东发起合同的模态框界面 房东发起合同的主要代码如下： 5.3.6 收租功能房东点击我的收租按钮后，主栏会显示收租的列表。列表会显示已经收租的账单数据。对于未支付的账单，房东可以对其进行处理；对于已支付或者已取消的账单，房东也可以对账单进行再次的查看。房东也可点击“发起收租账单”按钮向租客发起账单。收租管理的界面如图5-29所示。 图5-29 房东的收租管理功能 房东点击“发起收租账单”按钮后，系统会拉出一个收租抽屉界面。该界面把收租的流程分为4步。在第一步时，需要房东选择收租的对象。收租的对象为签约并正在执行期内合同的所有租客；如果某一租客还存在未入账的账单，则无法对该租客进行重复收租。选择收租对象后，系统会读取相关的数据显示在界面上。在后续的步骤里，需要房东填入租客在这一周期使用的电度、水度和选填的额外的调节费用。系统会计算出相应的房租。房东选择收租截止日期、点击提交账单后，系统会将新的抄表信息更新到房源信息数据里，并且会把账单信息发送至租客的手机号上提醒租客及时缴交。收租抽屉界面如图5-30所示。 图5-30 发起收租账单的操作界面 房东发起账单的主要代码如下： 房东除了发起收租外，也可以查看其他向自己入账的账单信息。对于已支付或者已关闭状态的账单，房东可以查看；对于未支付状态的账单，房东可以选择取消这份账单。取消账单并确认取消后，系统会还原之前的水表和电表的读数，并且该账单会拦截，不让租客支付。如果租客以线下其他方式向房东缴租，房东可以选择线下收到房租。其界面如图5-31所示。 图5-31 租客中心的个人信息编辑界面 5.3.7 房东中心的实名认证功能房东在注册完账号进入自己的个人中心后，需要进行实名认证。实名认证的操作流程与租客的操作流程一致。 5.3.8 房东中心的个人信息编辑功能房东可以在此页面修改自己的个人信息和头像。操作流程与租客的个人信息编辑功能一致。 5.3.9 房东中心的密码修改功能房东可以根据需要在此模块修改自己的登录密码。房东修改密码的流程与租客的密码修改流程一致。 5.4 管理员模块管理员从管理员登录页面输入账号，登录成功后会跳转到后台管理中心。 5.4.1 用户实名信息审核网站的用户在自己的个人中心提交的实名信息，都会归纳到管理中心等待管理员审核。显示管理员审核实名信息的界面如图5-32所示。 图5-32 实名审核信息列表界面 管理员可以审核并无限查看某条实名信息。管理员可以点击图片全屏查看证件信息。对于需要审核的信息，模态框会开放处理选项。管理员需要选择结果后提交处理。实名信息审核方算完成审核。展示实名信息详情的界面如图5-33所示。 图5-33 审核实名信息的详情界面 5.4.2 房源信息审核管理员需要审核用户发布的房源信息。通过审核的房源信息才可以在网站前端被用户搜索到。管理员的房源审核列表如图5-34所示。 图5-34 房源审核列表的界面 管理员点击房源详情时，会显示一个写着房源详情信息的模态框。如果是待审核的房源，模态框会开放处理选项供管理员处理。其如图5-35所示。 图5-35 管理员查看房源详情的界面 管理员审核房源信息的主要代码如下： 第六章 系统测试6.1 系统用例测试系统测试主要是功能测试，检测各功能模块是否能够正常运行，系统整体功能是否完善，运行过程是否顺利，界面是否整洁美观。 重置密码测试用例如表6-1所示。 表6-1 修改密码测试用例 名称 内容 用例编号： CS01 用例名： 用户修改密码 输入信息： 原密码、新密码、确认新密码 输出信息： 密码成功修改后，提示用户修改结果 过程： 1）用户进入自己的个人中心界面，点击修改密码。 2）用户输入原密码一次，输入新密码两次。 3）点击“保存修改”按钮修改密码，成功后提示用户修改结果，并清空输入框。 房东用户发起账单用例如表6-2所示。 表6-2 房东发起新账单测试用例 名称 内容 用例编号： CS02 用例名： 房东发起新账单 输入信息： 输入标题、介绍、房源属性、价格、押付类型、上传图片。 输出信息： 上传成功后，提示用户上传结果。 过程： 1）进入房东中心，点击“发布房源”按钮 2）输入标题、介绍、房源属性、价格、押付类型 3）上传图片 4）点击“保存”按钮，成功后返回上传结果。 用户发表文章评论测试用例如表6-3所示。 表6-3 租客评价房东测试用例 名称 内容 用例编号： CS03 续表6-3 用例名： 租客评价房东 输入信息： 输入评价内容，选择评价分 输出信息： 评价成功，可以在合同查看评价信息 过程： 1）合同结束后，点击“合同详情”，再点击“评价TAA”按钮 2）输入评价的内容，选择评价的分数 3）点击“提交评价”按钮，进行评价。 6.2 测试结果“嘤嘤租房网”的所有功能的测试结果如下： （1）前台。前台的用户登录、注册功能、搜索房源、提交申请与预约请求、实名认证、合同管理、预约管理、账单管理、租客、房源与房东评价、房源管理等模块均通过了测试。 （2）网站的管理员登录后台后，可以实现对房源的审核、实名信息的审核。以上模块均通过了测试。 总 结这一次毕业设计，是第三次自己规划并开发一个较为完整的网站。在开发“嘤嘤租房网”网站时，遇到了几个比较关键的问题。首先的是使用的技术。原本在构思课题时只考虑使用SSM框架，并以jsp页面进行内容的呈现；但在网络上搜集资料时，我逐渐发现前后端分离开发更加贴合现在主流的开发方式。在寻找前端时，发现了基于Vue技术的ElementUI框架。此框架简洁干净，也贴合租房这一商业性质网站的风格。综上所述，本课题的网站框架采用Vue与SSM，奠定了网站后续的开发方向。 有句话叫“万事开头难”。在网站的开发初期，没有接触过前后端分离开发的我遇到了瓶颈。比如：Vue里如何做到数据对接、数据没有及时到达页面造成排版异常等等。有些问题的原因单一，也有的问题原因多种多样；我无从下手，不知如何解决。在同学的指导下，我学会通过报错日志与浏览器控制台的报错信息来定位问题，从而寻找解决办法。 在后续的开发过程中，理所当然却也无可奈何地遇到了各式各样的问题。在解决这些问题时，最初只能求助网络，寻找类似问题的先例并在自己项目上逐步进行实践以解决当下的错误。长此以往，我发现，当相似的问题遇到一定量后，大脑内会形成一定的解决思路。这令我在往后遇到问题时能更有效率地去解决，我相信，这些经验在以后的工作实战里有着不小的帮助。 参考文献 王飞.论房屋租赁信息系统的设计与实现[J].电脑迷,2017(07):194-195. 罗树立.加入WTO给中国房地产业带来的挑战及应对措施[J].中共成都市委党校学报,2002(6):35~36. 巴民.国外的住房市场[J].重庆国土资源,2005(5):39~40. 吴浪,高际家.房屋租赁市场的中美比较分析[J].青年科学,2010(2):197~198. 沈克明.纽约政府如何补贴穷人住房[J].新财经,2006(8):80~81. 冯博.中国廉租房制度与日本公营住房政策的比较研究[D].山西财经大学,2010. 刘海洋,陈海.廉租房在国外[J].中州建设,2011(6):74~75. 隋琛琛.廉租房制度国内外比较与借鉴[J].上海房地,2009,14(7):22~25. 房屋租售管理系统的设计与实现[J].尹凌.计算机光盘软件与应用.2012(22) 武海龙,李国平.基于SpringBoot的房屋租赁系统设计[J].电脑与信息术,2019,27(03):76-78. 1 - 战松,郎妲妮.长租公寓现存问题分析及解决对策[J].辽宁经济,2019(11):70-71. Márcio Moraes Valença. Social rental housing in HK and the UK: Neoliberal policy divergence or the market in the making?[J]. Habitat International,2015,49. Barton, Barbara. Earning Extra Income With Rent Houses[J]. Ranch and Rural Living,2011,92(5). 致 谢本篇论文到了致谢部分，说明在自己的努力和大家的帮助下，我完成了论文的大部分内容。首先，我想感谢我的导师杨财英老师。毕业设计是第一次一个人独立完成一个较为完整的网站，从选题、设计数据库到开发，每一步都需要先慎重思考以避免无效努力。感谢她的指导，我才能更顺利地完成选题方面、逻辑方面等许多环节的任务；也感谢老师的督促，老师的负责也是我能按期完成网站不可少的要素。 接着，我想感谢我周围的同学与老师，感谢他们能在我碰到技术性的问题无法解决时，帮助我一起解决；也感谢我的朋友们能以使用者的角度给我提出使用的感想，让我能修改出目前最贴合生产环境里的操作界面与交互效果。也感谢他们在我碰到瓶颈时，能给我信心。在大学这段时间里，校园的视野让我能更投入地去学习自己的专业知识。感谢老师们这几年的教学，让我打下了一定的基础；在遇到问题时对比以往让我用不同的角度去看待并解决。 再次感谢大家的帮助与教诲。学无止境，今后走出象牙之塔，我仍会保持谦逊的态度，努力学习，提升自己，认真完成每一件事情！"},{"title":"React学习笔记","date":"2021-05-26T09:41:02.000Z","url":"/2021/05/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["React","/tags/React/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"1. React简介 轻量级的视图层库！A JavaScript library for building user interfaces React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；React 主要用于构建UI，可以简单地理解为React 将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。 1.1 组件化 什么是模块化：是从代码的角度来进行分析的；把一些可复用的代码，抽离为单个的模块；便于项目的维护和开发； 什么是组件化： 是从 UI 界面的角度 来进行分析的；把一些可复用的UI元素，抽离为单独的组件；便于项目的维护和开发； 组件化的好处：随着项目规模的增大，手里的组件越来越多；很方便就能把现有的组件，拼接为一个完整的页面； Vue是如何实现组件化的： 通过 .vue 文件，来创建对应的组件； template 结构 script 行为 style 样式 React如何实现组件化：大家注意，React中有组件化的概念，但是，并没有像vue这样的组件模板文件；React中，一切都是以js来表现的 1.2 移动APP Vue，结合 Weex 实现移动端App开发 React，结合 ReactNative 实现移动端App开发 2. React的虚拟DOM 真实DOM：是浏览器中的概念是用JS对象来表示页面上的元素，并提供了操作 DOM 对象的API。 虚拟DOM：是框架中的概念是用JS对象来模拟页面上的 DOM 和 DOM嵌套。 本质： 用JS对象，来模拟DOM元素和嵌套关系 目的： 就是为了实现页面元素的高效更新 React 高性能 React Fiber 3. React的特点和优势 虚拟DOM 组件系统 单向数据流 jsx语法 4. 快速构建React开发环境 使用 create-react-app脚手架 快速构建 React 开发环境 引入react、react-dom 创建DOM元素渲染 元素与组件 5. JSX的语法 jsx介绍 jsx 执行更快，因为它在编译为 JavaScript 代码后进行了优化。 它是类型安全的，在编译过程中就能发现错误。 使用 jsx编写模板更加简单快速。 jsx的使用 jsx语法中, 要把js代码写到{}号中 jsx中的注意事项 注释推荐使用{ /* 这是注释 */ } 在jsx创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹； 在 jsx 语法中，标签必须成对出现，如果是单标签，则必须自闭和 6. React中创建组件 组件的创建方式 函数式组件(首字母必须大写) class关键字组件 两种组件的区别: 用函数创建出来的组件：叫做“无状态组件” 用class关键字创建出来的组件：叫做“有状态组件” 这两种组件本质区别就是：有无state属性 组件之间的组合和嵌套 7. JSX原理 JS对象构建DOM结构 上面这个 HTML 所有的信息我们都可以用 JavaScript 对象来表示： React中构建DOM结构 React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、还有子元素等 编译之后将得到的代码: 8. 组件中DOM样式 行内样式 使用class classnames npm install classnames –save styled-components npm install styled-components –save 9. 组件的属性(props) class组件的属性和默认属性 函数组件的属性和默认属性 组件的props.children属性 使用props-type检查props 10. 组件的状态(state) 创建组件状态的两种方式 普通方式 继承方式 设置组件状态(setState) setState方法(有两个参数)设置状态 第一个参数可以是对象，也可以是方法return一个对象。 参数是对象 参数是方法 setState是异步的,所以想要获取最新的state, 没有办法获取,就有了第二个参数,这是一个可选的回调函数 渲染数据 条件渲染 列表渲染 dangerouslySetInnerHTML方法 11. 属性 VS 状态属性 props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。 它是外部传进来的配置参数，组件内部无法控制也无法修改。 除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。 状态 state 的主要作用是用于组件保存、控制、修改自己的可变状态。 state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。 state 是一个局部的、只能被组件自身控制的数据源。 state 中状态可以通过 this.setState方法进行更新，setState 会导致组件的重新渲染。 如果搞不清 state 和 props 的使用场景，记住一个简单的规则：**尽量少地用 state，多用 props**。 没有 state 的组件叫无状态组件，设置了 state 的叫做有状态组件。 组件的数据渲染是否被调用者传递的props完全控制，控制则为受控组件，否则非受控组件。 因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。 这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。 12. 事件 绑定事件 采用on+事件名的方式来绑定一个事件，React和原生的事件是有区别的，原生的事件全是小写onclick, React中的事件是驼峰onClick，React的事件并不是原生事件，而是合成事件。 事件用法 直接在render里写行内的箭头函数(不推荐) 在组件内使用箭头函数定义一个方法(推荐) 直接在组件内定义一个非箭头函数的方法，然后在render里直接使用onClick={this.handleClick.bind(this)}(不推荐) 直接在组件内定义一个非箭头函数的方法，然后在constructor里bind(this)(官方推荐) Event对象 和普通浏览器一样，事件handler会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致。不同的是 React中的 event 对象并不是浏览器提供的，而是它自己内部所构建的。它同样具有event.stopPropagation、event.preventDefault 这种常用的方法 事件的参数传递 在render里调用方法的地方外面包一层箭头函数 在render里通过this.handleEvent.bind(this, 参数)这样的方式来传递 13. 用户输入案例 创建用户输入组件 添加状态绑定事件 改变状态更新组件 14. 组件的生命周期React中组件也有生命周期，有很多钩子函数供我们使用, 组件的生命周期，分为四个阶段，初始化、运行中、销毁、错误处理(16.3之后) 初始化执行 constructor&nbsp; componentWillMount()&nbsp;/&nbsp;UNSAFE_componentWillMount() 组件被挂载到页面之前，自动被执行 render()&nbsp; 渲染组件 componentDidMount() 组件被挂载到页面之后，自动被执行 更新阶段props或state的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法： componentWillReceiveProps()&nbsp;/&nbsp;UNSAFE_componentWillReceiveProps()&nbsp; 子组件要从父组件接受参数，如果这个组件第一次存在于父组件中,不会执行 如果这个组件之前已经存在于父组件中，才会执行 shouldComponentUpdate()&nbsp; 组件被更新之前，自动执行返回true/false来决定 render是否更新 componentWillUpdate()&nbsp;/&nbsp;UNSAFE_componentWillUpdate()&nbsp; 组件被更新之前它会自动执行但是在shouldComponentUpdate之后执行 shouldComponentUpdate返回true它才会执行，如果返回false，这个函数就不会被执行 render()&nbsp; componentDidUpdate() 组件更新完成以后被执行 卸载阶段 componentWillUnmount() 组件即将被从页面中剔除的时候执行 15. ref属性React提供的这个ref属性，表示对组件真正实例的引用，其实就是ReactDOM.render()返回的组件实例,ref可以挂载到组件上也可以是dom元素上。 挂到组件(class声明的组件)上的ref表示对组件实例的引用。不能在函数式组件上使用 ref 属性，因为它们没有实例： 挂载到dom元素上时表示具体的dom元素节点。 16. 组件通信父组件与子组件通信 父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变 父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态,也可以调用子组件的方法 子组件与父组件通信 父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用。 跨组件通信在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系。react提供了context api来实现跨组件通信, React 16.3之后的contextapi较之前的好用。 练习实例，使用context 实现购物车中的加减功能 复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，在实际的工作中我们会使用flux、redux、mobx来实现 17. HOC(高阶组件) 高阶组件是一个函数接受一个组件作为参数，返回一个新的组件 18. React Router原理： React Router甚至大部分的前端路由都是依赖于history.js的，它是一个独立的第三方js库。可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。 老浏览器的history: 通过hash来存储在不同状态下的history信息，对应createHashHistory，通过检测location.hash的值的变化，使用location.replace方法来实现url跳转。通过注册监听window对象上的hashChange事件来监听路由的变化，实现历史记录的回退。 高版本浏览器: 利用HTML5里面的history，对应createBrowserHistory, 使用包括pushState， replaceState方法来进行跳转。通过注册监听window对象上的popstate事件来监听路由的变化，实现历史记录的回退。 node环境下: 在内存中进行历史记录的存储，对应createMemoryHistory。直接在内存里push和pop状态。 用法:React Router包含了四个包: 包名 Description react-router React Router核心api react-router-dom React Router的DOM绑定，在浏览器中运行不需要额外安装react-router react-router-native React Native 中使用，而实际的应用中，其实不会使用这个。 react-router-config 静态路由的配置 主要使用:react-router-dom 直接按照官网的demo就理解 路由的使用方式: HashRouter、BrowserRouter、Route、Link、exact、404页面处理、Switch、NavLink、params、link的属性（pathname、search、hash、state)、redirect、push、replace、withRouter、prompt HashRouter和BrowserRouter HashRouter:锚点链接 BrowserRouter:H5的新特性（history）如果上线之后，需要后台做一些处理:重定向处理404bug 19. redux传统MVC框架的缺陷什么是MVC？ MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。 V即View视图是指用户看到并与之交互的界面。 M即Model模型是管理数据 ，很多业务逻辑都在模型中完成。在MVC的三个部件中，模型拥有最多的处理任务。 C即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 MVC只是看起来很美 MVC框架的数据流很理想，请求先到Controller, 由Controller调用Model中的数据交给View进行渲染，但是在实际的项目中，又是允许Model和View直接通信的。然后就出现了这样的结果： ReduxReact 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。 代码结构 组件之间的通信 2013年 Facebook 提出了 Flux 架构的思想，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 如果你不知道是否需要 Redux，那就是不需要它 只有遇到 React 实在解决不了的问题，你才需要 Redux 简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用 WebSocket 视图层（View）只从单一来源获取数据 需要使用Redux的项目: 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 从组件层面考虑，什么样子的需要Redux： 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 Redux的设计思想： Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面（唯一数据源）。 注意：flux、redux都不是必须和react搭配使用的，因为flux和redux是完整的架构，在学习react的时候，只是将react的组件作为redux中的视图层去使用了。 Redux的使用的三大原则： Single Source of Truth(唯一的数据源) State is read-only(状态是只读的) Changes are made with pure function(数据的改变必须通过纯函数完成) 什么是纯函数: 纯函数指的是 给定固定的输入就一定会有固定的输出，而且不会有任何副作用。 不固定的话像日期对象、ajax请求、异步操作就不是纯函数了 副作用是对接受的参数进行修改。我们可以复制一份修改复制的 20. redux和react-redux区别 redux:js的状态管理 react-redux:为了在react中方便实用redux redux教程: createStore:(创建store) applyMiddleware:(处理中间件) 一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。 怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware） 引入react-thunk的异步操作（注意:异步一定要放在aciton操作) 注意:定时器、网络请求、事件监听、在组件被销毁前都应得到相应的处理 实战Redux实现TodoList 使用Antd搭建todoList 创建store 创建action和reducer实现添加功能 实现删除功能 actionTypes的拆分 使用actionCreators拆分action UI组件和容器组件 无状态组件 redux中使用异步 redux-thunk redux-sage react-redux:注意版本问题: Provider connect mapStateToProps（将state映射到 UI 组件的参数（props)) mapStateToProps是一个函数,它的作用是建立一个从（外部的）state对象到（UI 组件的props对象的映射关系,传入connect中相当于立即执行,返回一个对象,里面的每一个键值对就是一个映射 mapDispachToProps（输出逻辑，即将用户对 UI 组件的操作映射成 Action。） mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 mapDispatchToProps为函数的用法 mapDispatchToProps为对象的用法 bindActionCreators:（作用是将一个或多个action和dispatch组合起来生成mapDispatchToProps需要生成的内容） combineReducers:（合并多个reducer） reducer存放过多的数据 可能造成代码的不可维护 最好把reducer拆分 用redux内置的combinReducers函数进行拆分 21. React Hooks教程: 什么是hooks: ​ React一直都提倡使用函数组件，但是有时候需要使用 state 或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有. Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性. 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks. 凡是 use 开头的 React API 都是 Hooks. 1. useState useState可以让我们在函数式组件中定义一个state和一个用来修改state的方法 2. useContextContextContext 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。 有部分小伙伴应该使用props属性进行组件向下传值的操作。当多个组件嵌套时候。你就需要慢慢向上寻找最初的值是什么 React.createContext：创建一个上下文的容器(组件), defaultValue可以设置共享的默认数据 Provider(生产者): 和它的名字一样。用于生产共享数据的地方。生产什么呢？ 那就看value定义的是什么了。value:放置共享的数据。 Consumer(消费者):这个可以理解为消费者。 它是专门消费供应商(Provider 上面提到的)产生数据。Consumer需要嵌套在生产者下面。才能通过回调的方式拿到共享的数据源。当然也可以单独使用，那就只能消费到上文提到的defaultValue useContext 如果需要在组件之间共享状态，可以使用useContext()。 useContext 的入参是某个 Provider 提供的 context，如果 context 发生变化的话，返回值也会立即发生变化。 3. useReducerReact 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。 Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。 useReducers()钩子用来引入 Reducer 功能。 上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。 4. useEffectEffect Hook可以使得你在函数组件中执行一些带有副作用的方法。 数据获取，设置订阅以及手动更改React组件中的DOM都是副作用的示例。无论你是否习惯于将这些操作称为“副作用”（或仅仅是“效果”），但你之前可能已经在组件中执行了这些操作。 提示： 如果你熟悉React类生命周期方法，则可以将useEffect Hook视为componentDidMount，componentDidUpdate和componentWillUnmount的组合。 useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。 constructor(props)React组件的构造函数在挂载之前被调用。 在实现React.Component构造函数时，需要先在添加其他内容前，调用super(props)， 用来将父组件传来的props绑定到这个类中，使用this.props将会得到。 官方建议不要在constructor引入任何具有副作用和订阅功能的代码，这些应当使用componentDidMount()。 constructor中应当做些初始化的动作，如：初始化state，将事件处理函数绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。 当然也可以利用props初始化state，在之后修改state不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用redux统一进行状态管理。 static getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps 是react16.3之后新增，在组件实例化后，和接受新的props后被调用。他必须返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。 如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。 调用setState()不会触发getDerivedStateFromProps()。 之前这里都是使用constructor+componentWillRecieveProps完成相同的功能的 componentWillMount() / UNSAFE_componentWillMount()componentWillMount()将在React未来版本(官方说法 17.0)中被弃用。UNSAFE_componentWillMount()在组件挂载前被调用，在这个方法中调用setState()不会起作用，是由于他在render()前被调用。 为了避免副作用和其他的订阅，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。这个方法因为是在渲染之前被调用，也是惟一一个可以直接同步修改state的地方。 render()render()方法是必需的。当他被调用时，他将计算this.props和this.state，并返回以下一种类型： React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。&nbsp; 字符串或数字。他们将会以文本节点形式渲染到dom中。&nbsp; Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。&nbsp; null，什么也不渲染&nbsp; 布尔值。也是什么都不渲染。 render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果shouldComponentUpdate()返回false，render()不会被调用。 componentDidMountcomponentDidMount在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。 通常在这里进行ajax请求 如果要初始化第三方的dom库，也在这里进行初始化。只有到这里才能获取到真实的dom. componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)官方建议使用getDerivedStateFromProps函数代替componentWillReceiveProps。当组件挂载后，接收到新的props后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用this.setState()。 如果父组件会让这个组件重新渲染，即使props没有改变，也会调用这个方法。 React不会在组件初始化props时调用这个方法。调用this.setState也不会触发。 shouldComponentUpdate(nextProps, nextState)调用shouldComponentUpdate使React知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。 在渲染新的props或state前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在forceUpdate()时被调用。返回false不会阻止子组件在state更改时重新渲染。 如果shouldComponentUpdate()返回false，componentWillUpdate,render和componentDidUpdate不会被调用。 官方并不建议在shouldComponentUpdate()中进行深度查询或使用JSON.stringify()，他效率非常低，并且损伤性能。 UNSAFE_componentWillUpdate(nextProps, nextState)在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。 *不能在这里使用this.setState()*，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedStateFromProps。 getSnapshotBeforeUpdate()在react render()后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。 componentDidUpdate(prevProps, prevState, snapshot)在更新发生后立即调用componentDidUpdate()。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。 如果组件实现getSnapshotBeforeUpdate()生命周期，则它返回的值将作为第三个“快照”参数传递给componentDidUpdate()。否则，这个参数是undefined。 componentWillUnmount()在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount中创建的任何监听。 componentDidCatch(error, info)错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。 如果类组件定义了此生命周期方法，则它将成错误边界。在它中调用setState()可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复; 不要试图将它们用于控制流程。 错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。 PureComponentPureComponnet里如果接收到的新属性或者是更改后的状态和原属性、原状态相同的话，就不会去重新render了在里面也可以使用shouldComponentUpdate，而且。是否重新渲染以shouldComponentUpdate的返回值为最终的决定因素。 不错的文章: "},{"title":"教资中学科目一作文练手《以奋斗创造未来》","date":"2021-03-10T07:23:25.000Z","url":"/2021/03/10/zuowen/","tags":[["作文","/tags/%E4%BD%9C%E6%96%87/"],["教师资格证","/tags/%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81/"],["科目一","/tags/%E7%A7%91%E7%9B%AE%E4%B8%80/"]],"categories":[["undefined",""]],"content":"考题内容阅读下面的材料，按要求写作文。 【材料一】“人的一生应当这样度过，当他回首往事时，不因虚度年华而悔恨，也不因碌碌无为而羞耻……”《钢铁是怎样炼成的》主角保尔·柯察金以其钢铁般的意志和为理想而奋斗的精神，激励了一代代青年投身社会主义建设。 【材料二】“生活不能等待别人来安排，要自己去争取与奋斗！”，《平凡的世界》里的农村青年——孙少平，在苦难面前咬牙坚持，积极抗争，让一代代人从中获得精神的力量，增添了克服困难的勇气。 写作要求1、综合上述材料所引发的思考和感悟，写一篇论说文。 2、用规范的现代汉语写作，角度自选，立意自定，题目自拟。 【字数要求】小学800字，中学1000字。 练手作文详情《奋斗创造未来 》作者：chenlx古话说“少壮不努力，老大徒伤悲”，“长风破浪会有时，直挂云帆济沧海”。“奋斗”二字，从古至今都有文学写着关于这个词的描绘。对于我们来说，什么才是奋斗呢？ 奋斗，是一场考试前她的奋笔疾书认真备考，放榜时看到成绩的洋溢着喜悦的笑脸；奋斗，是农民在田野里辛勤地劳作挥洒着汗水，在火红的秋日里丰收时那捧在怀里的稻香；奋斗，是新中国成立后，先辈们通过艰苦拼搏反复尝试，后人们接力共同打造出如今的世界第二大经济体，让百姓可以安居乐业的生活。 为什么需要依靠奋斗来创造未来？我们所渴望、所期待的未来生活多姿多样。我们畅想着，在未来，我们不用害怕路上的危险，不用担心敌人的欺凌，不用担心吃不饱穿不暖，不用担心不能在知识的汪洋里遨游。但这一切离不开实力，离不开通过奋斗积累出的实力。 在西汉年代，有一位特别有学问的人名叫匡衡。可匡衡小时候非常的贫穷，家里连根照明的蜡烛都买不起。但匡衡为了在夜里也可以读书，他得知隔壁人家有光后，便在墙上凿了一个洞，以此偷光读书。后来，匡衡的这个举动感动了他的邻居。后来在大家的帮助下，小少年匡衡终于学有所成。在汉元帝时期，匡衡也被封为了郎中。 奋斗的故事在我们现代同样随处可见。2020 年，伴随着我国的北斗定位系统完成了最后一颗卫星的发射，至此，我国终于拥有了自己的全球定位系统。可是这一切，得来的并不容易。 在我们国家的科学家研发北斗系统之初，我们什么核心技术都没有掌握。在这个几乎等同于从零开始的情况之下，科学家们还必须在规定的时间之前先行发射一颗卫星上去使用定位系统的频段号，否则，国际组织就不承认这个频段号归属北斗所用。算法、硬件、原子钟…… 科学家们在有限的时间里艰苦奋斗，克服重重困难，终于发射出了中国的第一颗北斗。在往后的日子里，科学家们日以夜继，终于在去年完成了北斗系统的组网并成功投入使用。感动中国栏目中组曾这样评价道：“当第五十五颗吉星升上太空，北斗，照亮了中国人的梦”。 所以，美好的未来需要靠我们去努力奋斗。我们不必一口气再造出个北斗，也没有必要 凿光读书。在我们的生活中，每一件事情都值得去奋斗。我们可以勤加锻炼身体，保证奋斗 的基本；认真复习，迎接每一场考试。或者我们可以团结协作，夺得一份荣誉，也可以当志愿者服务百姓，为美好社会献上一份自己的力量。 需要奋斗的事情有很多很多，奋斗的方式也多种多样。奋斗的时间或许有长有短，但一定能通过自己的努力奋斗出满意的结果，创造出自己期望的美好的未来！ 作文点评预估分数：39写作亮点 本文立意清楚，开头结合诗词直接引出立意，首尾呼应。 结构上层层递进，结合例子，流畅有力。 写作不足 不知道是不是电脑显示问题，文章分了8段，段落有些多，基本在4-6就可以了，一般5段最为完美，太多分 段会感觉很分散，可以开头-奋斗是什么-为什么奋斗-怎么去奋斗-结尾分为这五段。 怎样奋斗可以运用排比句的方式，①奋斗是勤加锻炼身体，奋斗是读书储备知识，奋斗是为社会做贡献， 奋斗可以是任何一件小事，奋斗努力的过程，就是小事迸发出最大的力量的过程。 结尾可以联系下材料，②奋斗是匡衡、北斗、、、然后加上原文需要到未来这部分会更好。 "},{"title":"boot链接neo4j遇到的一些报错知识库","date":"2021-02-28T16:00:00.000Z","url":"/2021/03/01/boot%E9%93%BE%E6%8E%A5neo4j%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99%E7%9F%A5%E8%AF%86%E5%BA%93/","tags":[["SpringBoot","/tags/SpringBoot/"]],"categories":[["undefined",""]],"content":"org.springframework.data.mapping.MappingException: Error mapping Record Caused by: org.springframework.dao.TypeMismatchDataAccessException: Could not convert “” into java.util.List&lt;java.lang.String&gt;; nested exception is org.neo4j.driver.exceptions.value.NotMultiValued: STRING is not iterable Caused by: org.neo4j.driver.exceptions.value.NotMultiValued: STRING is not iterable 解决办法：将该字段类型改成Object即可。"}]