<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>毕业设计论文：基于javaEE的房屋租赁管理系统的设计与实现</title>
      <link href="2021/05/27/bysj/"/>
      <url>2021/05/27/bysj/</url>
      
        <content type="html"><![CDATA[<h1 id="福建工程学院本科毕业设计（论文）作者承诺保证书"><a href="#福建工程学院本科毕业设计（论文）作者承诺保证书" class="headerlink" title="福建工程学院本科毕业设计（论文）作者承诺保证书"></a>福建工程学院本科毕业设计（论文）作者承诺保证书</h1><p>本人郑重承诺：本篇毕业设计（论文）的内容真实、可靠。如果存在弄虚作假、抄袭的情况，本人愿承担全部责任。</p><p>学生签名：<br>2020 年 1 月 日</p><h1 id="福建工程学院本科毕业设计（论文）指导教师承诺保证书"><a href="#福建工程学院本科毕业设计（论文）指导教师承诺保证书" class="headerlink" title="福建工程学院本科毕业设计（论文）指导教师承诺保证书"></a>福建工程学院本科毕业设计（论文）指导教师承诺保证书</h1><p>本人郑重承诺：我已按有关规定对本篇毕业设计(论文)的选题与内容进行了指导和审核，且提交的毕业设计（论文）终稿与上传至“大学生论文管理系统”检测的电子文档相吻合，未发现弄虚作假、抄袭的现象，本人愿承担指导教师的相关责任。</p><p>指导教师签名：<br>2020 年 月 日</p><h1 id="目-录"><a href="#目-录" class="headerlink" title="目 录"></a>目 录</h1><p>Md文件中忽略</p><p>基于javaEE的房屋租赁管理系统的设计与实现</p><h1 id="摘-要"><a href="#摘-要" class="headerlink" title="摘 要"></a>摘 要</h1><p>在如今的互联网时代，传统繁琐的租赁流程已不太适用于当下忙碌而又快节奏的生活。租客想在工作的城市借居却很难即时发现自己最为心仪的房源；流动租客过多时也导致房东难以进行管理。因此，本课题借由这一社会现象设计并实现了一套房屋租赁管理系统。该课题的开发语言选择Vue与JavaEE，采用Element<br>UI、SSM等技术框架；使用Tomcat搭建服务器，以及使用MySQL数据库进行数据存储。系统拥有搜索房源、租赁房源、签订合同、支付账单等功能。通过本系统，租客可以直接在网页搜索查询自己想要的房屋信息；通过查阅房源的评分，租客能对房源的客观状态一目了然，同时，也支持租客在网站内完成预约上门看房、申请租房、签约合同、支付房租等功能；房东也可以在网站上直接对合同、账单、租客预约等进行便捷的处理。在处理租客的租房申请时，房东也能根据租客的评分来决定是否向租客出租以避免糟心的问题。系统可以简化租赁流程，直接在一个网站上存储相应的租赁内容并提供随时查阅。不论是租客还是房东，在租赁结束后都能为对方进行评价，形成一套简单的用户评价体系。系统完成后的测试结果表明，该系统运行状态良好，对各个功能进行了不同环境的测试，基本符合用户的良好体验。</p><p>关键字：房屋，租赁，Vue，J2EE<br>Design and Implementation of a House Rental Management System Based on JavaEE</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>In today’s Internet age, the traditional tedious rental process is no longer suitable for today’s busy and fast-paced life. Tenants want to live in the city  where they work, but it ’s difficult to find their favorite property instantly;  too many mobile tenants also make it difficult for landlords to manage.  Therefore, the subject designs and implements a house rental management system  based on this social phenomenon. Vue, SSM and other technologies were selected  as the development language used in this system. Using Tomcat to build the  server, and select MySQL database for data storage. The system has functions  such as searching for listings, renting listings, contracts, and paying bills.  Through this system, tenants can search for the desired housing information  directly on the webpage. By checking the ratings of the listing and the  landlord, the objective status of the listing or the landlord can be seen at a  glance. Apply for rent online, read and sign the contract, pay rent bill. The  landlord can also conveniently handle the contracts, the bills, the appointments  and the bill directly on the website. When processing a housing application, you  can decide whether to rent based on the tenant’s evaluation. Avoid bad  experiences. The system can make most of the leasing process paperless, store  the corresponding content directly on a website and can check it at any time.  Both the tenant and the landlord can evaluate the other party after the lease  ends, forming a simple user evaluation system. The test results after the  completion of the system show that the system is running well, and various  functions have been tested in different environments, which basically meets the  user’s good experience.</p><p>Keywords: House, Rent, Vue, J2EE</p><h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-1-课题背景及意义"><a href="#1-1-课题背景及意义" class="headerlink" title="1.1 课题背景及意义"></a>1.1 课题背景及意义</h2><p>近年来，我国的社会经济迅猛发展，工作机遇也越来越多，市场对于房屋租赁的需求也在不断增多[1]。大部分的年轻人喜欢到大城市去寻找工作，因此，伴随着这一现象的基础问题之一就是住宿。</p><p>中国之大，流动人口众多。在中国加入WTO后，房屋租赁行业受到国外竞争者的挑战[2]。如今，网络贯穿着我们生活的各个场景，人们越来越希望在繁琐重复的事情上节省更多的时间。传统的那种：租客四处寻、房东、房东用纸笔记录的方式已经不是那么得适用于目前的情况。而租客身在异乡人生地不熟，很难一时发现自己最为心仪的出租房；流动租客过多时，房东也很难进行便捷管理。本课题准备设计一个针对租客、房东两位核心角色，提供便捷寻房、租房和住房的平台。便捷二字，对于为生活奔波的租客、管理的房东来讲无疑是最重要的，所以，本课题的研究对于这两类角色有着减轻负担、节省时间、提升生活里的幸福感的意义。</p><h2 id="1-2-国内外现状"><a href="#1-2-国内外现状" class="headerlink" title="1.2 国内外现状"></a>1.2 国内外现状</h2><h3 id="1-2-1国内现状"><a href="#1-2-1国内现状" class="headerlink" title="1.2.1国内现状"></a>1.2.1国内现状</h3><p>同发达国家相比，我国的租赁公寓起步较晚，租赁政策较少，因此我国目前的租赁市场并不健全，传统的住房租赁市场主要为个体房东，机构参与者较少[11]。稀少的平台导致在某些区域里，租赁价格与实际价值有出入、价格不透明，从而存在不同的租客租赁同一间房源时，存在没有理由的价格差异的现象。</p><h3 id="1-2-2国外现状"><a href="#1-2-2国外现状" class="headerlink" title="1.2.2国外现状"></a>1.2.2国外现状</h3><p>与大多数发展国家而言，国外的房屋租赁率较高主要是一种分配制度造成的[3]。德国的首都柏林大约有22.5万套“社会住房”专供低收入者租住[4]；日本东京为了解决高昂的租房金问题政府制定一套完善策可以根据不同的收入缴纳租金[6]。国外的房屋租住政策使得国外的房屋市场发展迅猛。一是通过共享信息平台政策使得国外的房屋市场发展迅猛，或者房屋租赁软件来推广业务；二是通过先进的互联网技术提高数据处理效率，完全替代手工录用方式。[7][8]</p><h1 id="第二章-相关技术"><a href="#第二章-相关技术" class="headerlink" title="第二章 相关技术"></a>第二章 相关技术</h1><h2 id="2-1开发环境"><a href="#2-1开发环境" class="headerlink" title="2.1开发环境"></a>2.1开发环境</h2><p>开发工具：IntelliJ IDEA 2019.1.1</p><p>数据库管理工具：Navicat for MySQL5.5</p><p>开发语言：Vue + JavaEE</p><h2 id="2-2相关技术"><a href="#2-2相关技术" class="headerlink" title="2.2相关技术"></a>2.2相关技术</h2><h3 id="2-2-1-Vue技术"><a href="#2-2-1-Vue技术" class="headerlink" title="2.2.1 Vue技术"></a>2.2.1 Vue技术</h3><p>Vue.js是一套构建用户界面的渐进式框架，他能够更方便的进行页面上数据的处理，并且实现单页面多内容渲染。</p><h3 id="2-2-2-MySQL"><a href="#2-2-2-MySQL" class="headerlink" title="2.2.2 MySQL"></a>2.2.2 MySQL</h3><p>MySQL<br>是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><h3 id="2-2-3-SSM"><a href="#2-2-3-SSM" class="headerlink" title="2.2.3 SSM"></a>2.2.3 SSM</h3><p>SSM是SpringMVC + Spring + MyBatis的简称，它是目前比较主流的Java<br>EE企业级的后台框架。使用它能快速搭建起系统的后台功能。</p><h1 id="第三章-系统需求分析"><a href="#第三章-系统需求分析" class="headerlink" title="第三章 系统需求分析"></a>第三章 系统需求分析</h1><h2 id="3-1-系统概述"><a href="#3-1-系统概述" class="headerlink" title="3.1 系统概述"></a>3.1 系统概述</h2><p>本课题网站名称为“嘤嘤租房网”，主要的目的是实现以下功能：用户注册、用户登录、浏览房源、申请看房、申请租房等。</p><h2 id="3-2-系统业务分析"><a href="#3-2-系统业务分析" class="headerlink" title="3.2 系统业务分析"></a>3.2 系统业务分析</h2><p>“嘤嘤租房网”的核心功能为租赁房源，所以本网站的角色一共有三位——分别是租客、房东和管理员。</p><h3 id="租客的业务流程分析"><a href="#租客的业务流程分析" class="headerlink" title="租客的业务流程分析"></a>租客的业务流程分析</h3><p>在访问“嘤嘤租房网”时，可先浏览网站上已经上架的房源信息，但无法进行后续的操作。租客在登录账号并实名认证通过后，才可以使用网站其余功能，如向房东发起看房预约、租房申请等。本网站租客的操作流程如图3-1所示。</p><p>图3-1 租客的业务流程活动图</p><h3 id="房东的业务分析"><a href="#房东的业务分析" class="headerlink" title="房东的业务分析"></a>房东的业务分析</h3><ul><li>房东</li></ul><p>房东在登录账号，并且实名认证后，房东才可以使用网站其余的功能。房东可以发布自己的房源，处理看房预约，处理租房申请等。本网站房东的操作流程如图3-2所示。</p><p>图3-2 房东的业务流程活动图</p><ul><li>管理员</li></ul><p>网站的实名信息与房源的信息，都需要通过管理员进行审核。网站管理员的操作流程如图3-3所示。</p><p>图3-3 网站管理员的业务流程活动图</p><h2 id="3-3-功能需求"><a href="#3-3-功能需求" class="headerlink" title="3.3 功能需求"></a>3.3 功能需求</h2><h3 id="3-3-1-网站前端模块"><a href="#3-3-1-网站前端模块" class="headerlink" title="3.3.1 网站前端模块"></a>3.3.1 网站前端模块</h3><p>“嘤嘤租房网”的前端有网站欢迎页、搜索结果页、详情页、登录页、注册页、房东个人中心和租客个人中心，供用户完成以下功能：</p><ul><li>搜索房源</li></ul><p>不论浏览“嘤嘤租房网”的访问者是否登录，网站都支持房源的检索。访问者可以根据自己需要输入关键字检索特定范围内的房源信息。</p><ul><li>查看房源详情</li></ul><p>用户可以单击搜索结果页面的某一条信息，在详情页面查看更完整的房源信息。如：浏览地图位置、房源的介绍文案、房源的住后评价等信息。</p><ul><li>用户注册与登录</li></ul><p>当访问者想要操作网站的更多功能时，需要访问者拥有本网站的账号。访问者可以登录账号再进行操作，或者先注册再进行登录。</p><ul><li>发起看房预约</li></ul><p>当租客用户想要上门看房，并没有明确要租赁的情况时，可以提交线下上门看房的预约给房东用户。</p><ul><li>发起租房申请</li></ul><p>当租客用户想要租住房源时，可提交租房申请给房东。</p><ul><li>合同功能</li></ul><p>租客和房东在双方都意向租赁时，需要依靠合同模块达成租赁关系。租客向房东发起的租房申请，房东可以依据此申请发起租赁合同。合同功能是“嘤嘤租房网”其他功能的依据。</p><ul><li>评价功能</li></ul><p>租客和房东可以使用此功能为对方评价。“嘤嘤租房网”是基于实名的租房网站，为对方客观地评分对下一次租赁时起到了重要的参考作用。</p><ul><li>实名功能</li></ul><p>出于租赁的性质，用户使用网站时必须先进行实名再进行租赁。</p><ul><li>房源功能</li></ul><p>房东可以通过此功能发布和维护自己的房源信息。</p><p>在前台模块中，系统根据登录状态，将用户分为两种角色。各个角色的用例如下所描述。</p><ul><li>网站租客用例</li></ul><p>租客未登录时仍可访问“嘤嘤租房网”的展示页面，其可以检索房源、查看房源详情。租客也可根据需要使用注册和登录功能，拥有一个属于自己的账号。具体的用例如图3-4所示。</p><p>图3-4 网站租客用例图</p><p>用户发起看房预约功能的详细描述如表3-1所示。</p><p>表3-1 发起看房预约功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US01</td></tr><tr><td>用例名：</td><td>发起看房预约</td></tr><tr><td>参与者：</td><td>用户</td></tr><tr><td>触发因素：</td><td>用户想上门看房</td></tr><tr><td>输入信息：</td><td>填写预约时间；选填给房东的留言</td></tr><tr><td>结果：</td><td>预约提交成功</td></tr><tr><td>后置条件：</td><td>数据库中的上门看房预约表成功存储了该用户预约申请。</td></tr><tr><td>过程：</td><td>1）输入预约时间 2）提交预约，点击“预约”按钮</td></tr></tbody></table><p>用户提交租房申请功能的详细描述如表3-2所示。</p><p>表3-2 提交租房申请功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US02</td></tr><tr><td>用例名：</td><td>发起租房申请</td></tr><tr><td>参与者：</td><td>用户</td></tr><tr><td>触发因素：</td><td>用户想申请租赁房源</td></tr><tr><td>输入信息：</td><td>填写租赁的开始日期和结束日期</td></tr><tr><td>结果：</td><td>申请提交成功</td></tr><tr><td>后置条件：</td><td>数据库中的租赁合同表成功存储了该用户租房申请。</td></tr><tr><td>过程：</td><td>1）输入租赁时间范围 2）提交预约，点击“提交申请”按钮</td></tr></tbody></table><p>支付账单功能的详细描述如表3-3所示。</p><p>表3-3 支付账单功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US03</td></tr><tr><td>用例名：</td><td>支付账单</td></tr><tr><td>参与者：</td><td>租客用户</td></tr><tr><td>触发因素：</td><td>租客用户想要支付房东用户发起的账单</td></tr><tr><td>后置条件：</td><td>正确跳转到支付宝的支付页面 线下支付的提示框正确显示 订单状态正确更改</td></tr><tr><td>过程：</td><td>点击“支付宝线上支付”按钮或点击线下支付按钮</td></tr></tbody></table><p>评价房源和房东的详细描述如表3-4所示。</p><p>表3-4 用户登录功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US04</td></tr><tr><td>用例名：</td><td>评价房东与房源</td></tr><tr><td>参与者：</td><td>租客用户</td></tr><tr><td>触发因素：</td><td>用户在合同结束后评价房源和房东</td></tr><tr><td>输入信息：</td><td>选定评分，输入评价内容</td></tr><tr><td>后置条件：</td><td>数据库的房源评价表成功新增一条评价信息 数据库的用户评价表成功新增一条评价信息</td></tr><tr><td>过程：</td><td>点击“我要评价TA”按钮 选择评价星级 点击“提交评价”按钮。</td></tr></tbody></table><ul><li>网站房东用户用例</li></ul><p>房东角色的用户可以使用租赁流程所需要的功能，如：发起合同、发起账单等。具体的房东角色的用例图如图3-5所示。</p><p>图3-5 网站房东的用例图</p><p>处理看房预约功能的详细描述如表3-5所示。</p><p>表3-5处理看房预约功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US05</td></tr><tr><td>用例名：</td><td>处理看房预约</td></tr><tr><td>参与者：</td><td>房东用户</td></tr><tr><td>触发因素：</td><td>房东用户想处理租客用户发起的看房预约</td></tr><tr><td>结果：</td><td>通过预约/退回预约</td></tr><tr><td></td><td>续表3-5</td></tr><tr><td>后置条件：</td><td>存储在数据库预约表的预约信息的状态成功更改为拒绝状态/预约成功状态</td></tr><tr><td>过程：</td><td>选择房东处理选项 点击“提交处理”按钮</td></tr></tbody></table><p>发起账单功能的详细描述如表3-6所示。</p><p>表3-6发起账单功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US06</td></tr><tr><td>用例名：</td><td>发起租赁账单</td></tr><tr><td>参与者：</td><td>房东用户</td></tr><tr><td>触发因素：</td><td>房东用户想对租客发起租赁账单</td></tr><tr><td>结果</td><td>账单成功创建，通知租客</td></tr><tr><td>输入信息：</td><td>选择收租的对象；填写最新房源水表与电表读数；输入调节费用和费用说明</td></tr><tr><td>后置条件：</td><td>数据库中的账单表成功存储该条账单信息</td></tr><tr><td>过程：</td><td>点击“发起账单”按钮 选择收租对象，填写租赁产生的费用信息和读数 核对信息并点击“完成发起”按钮</td></tr></tbody></table><p>取消账单功能的详细描述如表3-7所示。</p><p>表3-7取消账单功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US07</td></tr><tr><td>用例名：</td><td>取消租赁账单</td></tr><tr><td>参与者：</td><td>房东用户</td></tr><tr><td>触发因素：</td><td>房东用户想取消账单的收租</td></tr><tr><td>结果</td><td>账单取消成功，租客无法支付</td></tr><tr><td>后置条件：</td><td>数据库中的账单表里对该账单信息的账单状态成功的更改为已取消状态； 数据库的房源表成功回滚到上一次的抄表数据</td></tr><tr><td>过程：</td><td>点击“查看”按钮 点击“取消这份账单”按钮 点击确认框的“确认”按钮</td></tr></tbody></table><p>发布房源信息功能的详细描述如表3-8所示。</p><p>表3-8发布房源信息功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US08</td></tr><tr><td></td><td>续表3-8</td></tr><tr><td>用例名：</td><td>发布房源信息</td></tr><tr><td>参与者：</td><td>房东用户</td></tr><tr><td>触发因素：</td><td>房东用户想在网站发布自己的房源信息</td></tr><tr><td>结果</td><td>房源信息成功上传</td></tr><tr><td>输入信息：</td><td>输入房源宣传标题、房源相关属性、租赁价格、宣传图片、介绍内容等。</td></tr><tr><td>后置条件：</td><td>数据库中的房源表里成功存储该房源信息，等待管理员审核</td></tr><tr><td>过程：</td><td>点击“新增房源”菜单 输入介绍标题、房源楼层、面积、房屋租赁定价 输入坐落的省市区信息、详细地址、房屋的相关属性 上传房源图片，输入房源介绍内容 点击“提交房源信息新增”按钮</td></tr></tbody></table><p>签约合同功能的详细描述如表3-9所示。</p><p>表3-9 签约合同功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US09</td></tr><tr><td>用例名：</td><td>签约合同</td></tr><tr><td>参与者：</td><td>租客用户</td></tr><tr><td>触发因素：</td><td>用户想租赁房源进行合同签约</td></tr><tr><td>后置条件：</td><td>数据库中的合同表里该申请信息的申请状态改已生效</td></tr><tr><td>过程：</td><td>点击“去签约”按钮 浏览并勾选“我同意签约合同”的复选框 点击“提交”按钮</td></tr></tbody></table><p>提交实名信息功能的详细描述如表3-10所示。</p><p>表3-10 提交实名信息功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US10</td></tr><tr><td>用例名：</td><td>提交实名信息</td></tr><tr><td>参与者：</td><td>用户</td></tr><tr><td>触发因素：</td><td>用户想要在本网站进行实名认证</td></tr><tr><td>输入信息：</td><td>输入真实姓名、身份证号码；上传身份证国徽面、头像面和手持身份证的照片。</td></tr><tr><td>后置条件：</td><td>数据库的实名信息表成功插入用户数据。</td></tr><tr><td>过程：</td><td>输入姓名和身份证号码，上传证件照片 点击“提交”按钮</td></tr></tbody></table><h3 id="3-3-2-网站后端模块"><a href="#3-3-2-网站后端模块" class="headerlink" title="3.3.2 网站后端模块"></a>3.3.2 网站后端模块</h3><p>后端模块基于网站的租赁需求，设立了管理中心，其为网站管理员的管理平台。网站的房源信息、实名信息都需要先经过管理中心审核后，信息才能通过继续下一步的流程。具体的管理员角色的用例图如图3-6所示。</p><p>图3-6 管理员中心的用例图</p><p>审核房源信息功能的详细描述如表3-11所示。</p><p>表3-11 处理看房预约功能用例描述</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>US11</td></tr><tr><td>用例名：</td><td>审核房源信息</td></tr><tr><td>参与者：</td><td>管理员</td></tr><tr><td>触发因素：</td><td>管理员想审核网站房东用户上传的房源信息</td></tr><tr><td>结果：</td><td>审核通过/审核退回</td></tr><tr><td>后置条件：</td><td>存储在数据库的房源表的信息的审核状态成功更改为审核通过/审核被驳回； 审核通过时，网站前端可以搜索到该房源。</td></tr><tr><td>过程：</td><td>点击“查看详情”按钮 选择管理员处理选项 点击“提交处理”按钮</td></tr></tbody></table><h1 id="第四章-系统设计"><a href="#第四章-系统设计" class="headerlink" title="第四章 系统设计"></a>第四章 系统设计</h1><h2 id="4-1系统概要设计"><a href="#4-1系统概要设计" class="headerlink" title="4.1系统概要设计"></a>4.1系统概要设计</h2><p>“嘤嘤租房网”是一个为用户提供在线房源租赁的网站。该网站为房东为用户提供在线发布房源的平台，使得租客用户可以足不出户就可以知晓到房东的房源信息；租客可以在线向房东发起看房预约和申请，也可以与房东在网站上签署合同、支付账单等。本网站具有从看房到合同、账单到评价等基本的租赁流程，使得租客和房东两大核心角色在租赁这件事情不再糟心，把更多的精力投入生活。</p><h2 id="4-2功能模块设计"><a href="#4-2功能模块设计" class="headerlink" title="4.2功能模块设计"></a>4.2功能模块设计</h2><p>“嘤嘤租房网”拥有租赁房源所需要的基本流程。网站的功能结构如图4-1所示。</p><p>图4-1 网站的功能结构图</p><h3 id="4-2-1-公共前端模块"><a href="#4-2-1-公共前端模块" class="headerlink" title="4.2.1 公共前端模块"></a>4.2.1 公共前端模块</h3><p>公共前端模块包括了用户登录、用户注册、浏览信息、提交信息等功能。</p><ul><li>用户注册功能</li></ul><p>用户点击输入框下方的“登录/注册”按钮后，系统会跳转到登录界面。如果浏览者希望注册一个本网站的账号，可以接着单击“注册”按钮，系统会显示一个注册的表单供访问者填写。访问者需要填写手机号码、访问本网站的密码、登录角色和手机验证码功能。访问者点击注册后，系统会校验表单是否填写完全，校验手机格式，并且校验验证码是否正确。上述校验规则都通过后，系统会提示注册成功，并且自动返回到登录界面。注册流程如图4-2所示。</p><p>图4-2 用户注册活动图</p><ul><li>发起上门看房预约/发起租房申请</li></ul><p>访问者成为本网站用户后，可以进行租房的其他操作，如看房预约、租房申请等。在前端的房源详情页，如果浏览的房源状态为空闲时，页面会开放预约和租房的按钮供用户使用。用户只有实名通过的情况下可以使用这两个功能，否则无法使用。用户使用前端的功能活动如图4-3所示。</p><p>图4-3 用户发起看房预约和租房申请的活动图</p><h3 id="4-2-2-个人中心模块"><a href="#4-2-2-个人中心模块" class="headerlink" title="4.2.2 个人中心模块"></a>4.2.2 个人中心模块</h3><p>个人中心模块包括了房东个人中心和租客中心两个中心。个人中心包括了实名功能、个人信息编辑功能，不同角色的预约管理功能、租房申请功能、合同功能、账单功能等。</p><ul><li>修改密码功能</li></ul><p>当用户想要修改自己的登录密码，需要先输入原始的密码，再输入新的密码才能完成更改。修改密码的活动如图4-4所示。</p><p>图4-4 用户修改密码的活动图</p><ul><li>实名认证功能</li></ul><p>用户需要提交自己的真实姓名、身份证号码、身份证的正反面和手持身份的照片上传到系统。等待系统的管理员审核。审核通过后方可使用网站的其他功能。</p><ul><li>个人信息编辑功能</li></ul><p>用户可以编辑自己的个人信息，如昵称、性别等。个人信息主要体现在房屋评价里。</p><ul><li>租赁合同功能</li></ul><p>用户可以在这里浏览有关于自己的合同的信息，所有的合同会以表格的形式展示给用户。根据用户的角色，系统会给出不同的操作按钮。房东可以处理租客发起的申请拉起一份合同发送给用户签约；租客也可以查看并签约拉起的合同。用户操作合同的活动如图4-5所示。</p><p>图4-5 租客与房东签约合同的泳道活动图</p><ul><li>账单功能</li></ul><p>租客在租赁期间产生的租赁费用，需要房东去向租客发起账单。发起后，租客将收到账单的信息。租客查看账单后可以选择支付方式，向房东支付账单。租客选择线上支付时，租客支付后，账单将变更为已支付状态；租客选择线下支付给房东后，房东需要手动选择房租已入账，账单才能结束。用户操作账单的活动如图4-6所示。</p><p>图4-6 房东与租客账单操作的泳道活动图</p><ul><li>预约功能</li></ul><p>用户可以在自己的中心里查看与自己有关的预约信息。所有的预约信息会以表格的形式呈现在页面里，并且根据角色和预约的状态提供操作按钮。用户可以对预约进行处理。</p><ul><li>房源功能</li></ul><p>房源功能主要提供给房东角色使用。房东可以利用房源功能新发布自己的房源信息、维护自己的房源信息。新增或维护后的房源信息。</p><h3 id="4-2-3-管理员模块"><a href="#4-2-3-管理员模块" class="headerlink" title="4.2.3 管理员模块"></a>4.2.3 管理员模块</h3><ul><li>房源信息审核功能</li></ul><p>房东在上传房源信息，或者维护房源信息后，公共前端页面并不能直接搜索到房源的详情。只有管理员审核通过后，房源才允许被用户搜索并查看、租赁等。</p><ul><li>实名认证信息审核功能</li></ul><p>本网站的用户需要进行实名认证后才允许使用网站的其他功能。所有的实名信息都会被提交至管理员中心等待管理员审核。管理员审核实名信息的活动如图4-7所示。</p><p>图4-7 管理员审核信息的活动图</p><h2 id="4-3数据库设计"><a href="#4-3数据库设计" class="headerlink" title="4.3数据库设计"></a>4.3数据库设计</h2><h3 id="4-3-1-概要设计"><a href="#4-3-1-概要设计" class="headerlink" title="4.3.1 概要设计"></a>4.3.1 概要设计</h3><p>根据前期的调查与在分析，得出以下数据库的设计概念。ER图来描述本网站的概念结构如下图4-8所示。</p><p>图4-8 网站ER图</p><p>首先是用户实体图，如图4-9所示。它拥有用户手机号、用户登录密码、角色等属性，记载着用户的个人信息。</p><p>图4-9 用户实体图</p><p>其次，是用户的实名认证信息的实体图，如图4-10所示。他记载着用户的真实信息，包括身份证号码与证件照片等。</p><p>图4-10 用户实名信息实体图</p><p>用户在浏览的核心信息，房源的实体图，如图4-11所示。其记载着房源的所有信息。</p><p>图4-11 房源实体图</p><p>用户的租赁产生的费用账单，存储在租赁账单的实体里，如图4-12所示。</p><p>图4-12 租赁账单实体图</p><p>租客和房东签订的合同信息，存储在租赁合同的实体里，如图4-13所示。</p><p>图4-13 租赁合同实体图</p><p>管理员的实体里存储着管理员的登录信息，如图4-14所示。</p><p>图4-14 系统管理员实体图</p><h3 id="4-3-2-物理设计"><a href="#4-3-2-物理设计" class="headerlink" title="4.3.2 物理设计"></a>4.3.2 物理设计</h3><p>根据本课题的需求分析后，归纳并设计出以下数据库表。都有：用户表，管理员表，房源信息表，房源评价表，用户评价表，租赁合同表，看房预约表，租赁账单表，用户实名信息表，中国省市区信息表，房源地图经纬度记录表。</p><ul><li>用户表</li></ul><p>用户表存放的是用户的信息列表，主要用于记录用户的手机号码、个人信息、登录密码和角色类型。用户表的设计结构图如表4-1所示。</p><p>表4-1 用户表(users)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>u_id</td><td>int</td><td></td><td>主键</td><td>否</td><td>用户表的ID</td></tr><tr><td>2</td><td>u_role</td><td>int</td><td></td><td></td><td>否</td><td>用户角色</td></tr><tr><td>3</td><td>u_head_image</td><td>varchar</td><td>255</td><td></td><td>是</td><td>用户头像</td></tr><tr><td>4</td><td>u_telephone</td><td>varchar</td><td>11</td><td></td><td>否</td><td>电话</td></tr><tr><td>5</td><td>u_pwd</td><td>varchar</td><td>30</td><td></td><td>否</td><td>密码</td></tr><tr><td>6</td><td>u_name</td><td>varchar</td><td>25</td><td></td><td>否</td><td>昵称</td></tr><tr><td>7</td><td>u_sex</td><td>int</td><td></td><td></td><td>是</td><td>性别</td></tr><tr><td>8</td><td>u_state</td><td>int</td><td></td><td></td><td>否</td><td>用户状态</td></tr></tbody></table><ul><li>管理员表</li></ul><p>管理员表存放的是管理人员的信息的数据表，包含了管理员的登录账号和登录密码。表结构如表4-2所示。</p><p>表4-2 管理员表(systemuser)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>sysid</td><td>int</td><td></td><td>主键</td><td>否</td><td>管理员表的ID</td></tr><tr><td>2</td><td>sysname</td><td>varchar</td><td>25</td><td></td><td>否</td><td>管理员登录名</td></tr><tr><td></td><td>续表4-2</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>syspwd</td><td>varchar</td><td>30</td><td></td><td>否</td><td>管理员密码</td></tr></tbody></table><ul><li>房源信息表</li></ul><p>房源信息表储存了房东发布的房源信息，房源表同时还储存了房源的电表和水表，生成账单时，房源的表读数会同步更新数据。表结构如表4-3所示。</p><p>表4-3 房源信息表(house_infomation)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>h_id</td><td>int</td><td></td><td>主键</td><td>否</td><td></td></tr><tr><td>2</td><td>h_name</td><td>varchar</td><td>255</td><td></td><td>是</td><td>房源宣传文案</td></tr><tr><td>3</td><td>h_address_city</td><td>int</td><td></td><td></td><td>否</td><td>所属城市</td></tr><tr><td>4</td><td>h_address_detial</td><td>varchar</td><td>50</td><td></td><td>否</td><td>房源地址</td></tr><tr><td>5</td><td>h_house_floor</td><td>int</td><td></td><td></td><td>否</td><td>房源楼层</td></tr><tr><td>6</td><td>h_houst_information</td><td>varchar</td><td>500</td><td></td><td>否</td><td>房源介绍</td></tr><tr><td>7</td><td>u_id</td><td>int</td><td></td><td></td><td>否</td><td>房主ID</td></tr><tr><td>8</td><td>h_rent_price</td><td>float</td><td></td><td></td><td>否</td><td>房租价格</td></tr><tr><td>9</td><td>h_image</td><td>varchar</td><td>255</td><td></td><td>否</td><td>房屋图片</td></tr><tr><td>10</td><td>h_rent_state</td><td>int</td><td></td><td></td><td>否</td><td>出租状态</td></tr><tr><td>11</td><td>h_water_number</td><td>int</td><td></td><td></td><td>否</td><td>水表底数</td></tr><tr><td>12</td><td>h_electricity_number</td><td>int</td><td></td><td></td><td>否</td><td>电表底数</td></tr><tr><td>13</td><td>h_audit_state</td><td>int</td><td></td><td></td><td>否</td><td>房源上架审核状态</td></tr><tr><td>14</td><td>h_area_number</td><td>float</td><td></td><td></td><td>否</td><td>房源面积</td></tr><tr><td>15</td><td>h_room_type</td><td>int</td><td></td><td></td><td>否</td><td>房屋户型-几室几厅</td></tr><tr><td>16</td><td>h_decorate_situation</td><td>int</td><td></td><td></td><td>否</td><td>房屋装修情况</td></tr><tr><td>17</td><td>h_post_time</td><td>date</td><td></td><td></td><td>否</td><td>发布日期</td></tr><tr><td>18</td><td>h_pay_type</td><td>int</td><td></td><td></td><td>否</td><td>意向押付方式</td></tr></tbody></table><ul><li>房源评价表</li></ul><p>房源评价表是基于合同结束后，租客对房东的房源的一个评价。表的内容包含租客和房东的ID，房源的ID和评价星级等等字段。表结构如表4-4所示。</p><p>表4-4 房源评价表(house_evaluation)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>he_id</td><td>int</td><td></td><td>主键</td><td>否</td><td></td></tr><tr><td>2</td><td>u_id</td><td>int</td><td></td><td></td><td>否</td><td>用户ID</td></tr><tr><td>3</td><td>h_id</td><td>int</td><td></td><td></td><td>否</td><td>房源ID</td></tr><tr><td></td><td>续表4-4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>c_id</td><td>int</td><td></td><td></td><td>否</td><td>合同ID</td></tr><tr><td>5</td><td>he_date</td><td>date</td><td></td><td></td><td>否</td><td>评价时间</td></tr><tr><td>6</td><td>he_content</td><td>varchar</td><td>500</td><td></td><td>是</td><td>评价内容</td></tr><tr><td>7</td><td>he_sorce</td><td>int</td><td></td><td></td><td>是</td><td>房屋评价星级（1-5）</td></tr><tr><td>8</td><td>he_anonymous</td><td>int</td><td></td><td></td><td>否</td><td>是否匿名</td></tr></tbody></table><ul><li>用户评价表</li></ul><p>租赁结束后，用户对用户的评价会储存在用户评价表里。表的结构如表4-5所示。</p><p>表4-5 用户评价表(user_evaluation)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>ue_id</td><td>int</td><td></td><td>主键</td><td>否</td><td>评价ID</td></tr><tr><td>2</td><td>c_id</td><td>int</td><td></td><td></td><td>否</td><td>基于的合同号</td></tr><tr><td>3</td><td>u_id</td><td>int</td><td></td><td></td><td>否</td><td>评价人ID</td></tr><tr><td>4</td><td>ue_date</td><td>date</td><td></td><td></td><td>否</td><td>日期</td></tr><tr><td>5</td><td>ue_content</td><td>varchar</td><td>255</td><td></td><td>是</td><td>内容</td></tr><tr><td>6</td><td>ue_sorce</td><td>float</td><td></td><td></td><td>否</td><td>评分</td></tr><tr><td>7</td><td>ue_post_u_id</td><td>int</td><td></td><td></td><td>否</td><td>评价对象ID</td></tr></tbody></table><ul><li>租赁合同表</li></ul><p>租赁合同表是储存了当租客发起租房的申请，房东将合同信息补齐后，双方约定的合同信息。存储的字段可供系统生成完整的合同书，也可以提取大纲供用户查看一目了然。表结构如表4-6所示。</p><p>表4-6 租赁合同表(rent_contract)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>c_id</td><td>int</td><td></td><td>主键</td><td>否</td><td>合同ID</td></tr><tr><td>2</td><td>o_create_time</td><td>datetime</td><td></td><td></td><td>否</td><td>创建时间</td></tr><tr><td>3</td><td>h_id</td><td>int</td><td></td><td></td><td>否</td><td>房源ID</td></tr><tr><td>4</td><td>o_tenants_id</td><td>int</td><td></td><td></td><td>否</td><td>租客id</td></tr><tr><td>5</td><td>o_master_id</td><td>int</td><td></td><td></td><td>否</td><td>房东id</td></tr><tr><td>6</td><td>o_rent_money</td><td>float</td><td></td><td></td><td>否</td><td>房租</td></tr><tr><td>7</td><td>o_rent_type</td><td>int</td><td></td><td></td><td>否</td><td>押付类型</td></tr><tr><td>8</td><td>o_house_full_address</td><td>varchar</td><td>255</td><td></td><td>否</td><td>房源完整地址</td></tr><tr><td>9</td><td>o_house_area</td><td>float</td><td></td><td></td><td>否</td><td>面积</td></tr><tr><td>10</td><td>o_house_deposit</td><td>float</td><td></td><td></td><td>否</td><td>押金</td></tr><tr><td></td><td>续表4-6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>11</td><td>o_sign_time</td><td>datetime</td><td></td><td></td><td>否</td><td>租客签约时间</td></tr><tr><td>12</td><td>c_perform_start_date</td><td>date</td><td></td><td></td><td>否</td><td>合同开始日期</td></tr><tr><td>13</td><td>c_perform_end_date</td><td>date</td><td></td><td></td><td>否</td><td>合同结束如期</td></tr><tr><td>14</td><td>c_contract_state</td><td>int</td><td></td><td></td><td>否</td><td>合同状态</td></tr></tbody></table><ul><li>看房预约表</li></ul><p>看房预约表是租客对某一房源感兴趣，想要是实地查看房源时向房东提交申请的数据表。主要的字段为租客ID、房源ID、预约时间、租客留言和房东回复等。表结构如表4-7所示。</p><p>表4-7 预约上门看房表(see_house_application)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>sh_id</td><td>int</td><td></td><td>主键</td><td>否</td><td>预约ID</td></tr><tr><td>2</td><td>o_tenants_id</td><td>int</td><td></td><td></td><td>否</td><td>租客ID</td></tr><tr><td>3</td><td>h_id</td><td>int</td><td></td><td></td><td>否</td><td>房源ID</td></tr><tr><td>4</td><td>o_master_id</td><td>int</td><td></td><td></td><td>否</td><td>房东ID</td></tr><tr><td>5</td><td>sh_see_house_time</td><td>datetime</td><td></td><td></td><td>否</td><td>预约时间</td></tr><tr><td>6</td><td>sh_tenants_message</td><td>varchar</td><td>255</td><td></td><td>是</td><td>租客留言</td></tr><tr><td>7</td><td>sh_master_message</td><td>varchar</td><td>255</td><td></td><td>是</td><td>房东回复</td></tr><tr><td>8</td><td>sh_state</td><td>int</td><td></td><td></td><td>否</td><td>预约状态</td></tr></tbody></table><ul><li>租赁账单表</li></ul><p>租赁账单表是用于存储租客在租赁期间产生的租赁费用需要结算的数据表。由于涉及支付，本表格的字段有相关的读表信息、收费单价、租客ID、房东ID、创建时间、支付时间、支付方式、支付状态等。表结构如表4-8所示。</p><p>表4-8 租赁账单表(rent_order)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>o_id</td><td>int</td><td></td><td>主键</td><td>否</td><td>账单ID</td></tr><tr><td>2</td><td>o_create_time</td><td>datetime</td><td></td><td></td><td>否</td><td>账单创建时间</td></tr><tr><td>3</td><td>c_id</td><td>int</td><td></td><td></td><td>否</td><td>合同ID</td></tr><tr><td>4</td><td>o_tenants_id</td><td>int</td><td></td><td></td><td>否</td><td>租客ID</td></tr><tr><td>5</td><td>o_master_id</td><td>int</td><td></td><td></td><td>否</td><td>房东ID</td></tr><tr><td>6</td><td>o_last_electric_number</td><td>int</td><td></td><td></td><td>否</td><td>上一周期电表读数</td></tr><tr><td>7</td><td>o_now_electric_number</td><td>int</td><td></td><td></td><td>否</td><td>本期电表读度</td></tr><tr><td>8</td><td>o_last_water_number</td><td>int</td><td></td><td></td><td>否</td><td>上一周期水表读数</td></tr><tr><td></td><td>续表4-8</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>o_now_water_number</td><td>int</td><td></td><td></td><td>否</td><td>本期水表读度</td></tr><tr><td>10</td><td>o_electric_price</td><td>float</td><td></td><td></td><td>否</td><td>本期电费单价</td></tr><tr><td>11</td><td>o_water_price</td><td>float</td><td></td><td></td><td>否</td><td>本期水费单价</td></tr><tr><td>12</td><td>o_house_rent_price</td><td>float</td><td></td><td></td><td>否</td><td>租赁房租</td></tr><tr><td>13</td><td>o_adjust_price</td><td>float</td><td></td><td></td><td>否</td><td>调节费</td></tr><tr><td>14</td><td>o_adjust_explain</td><td>varchar</td><td>50</td><td></td><td>是</td><td>调节费备注</td></tr><tr><td>15</td><td>o_order_money</td><td>float</td><td></td><td></td><td>否</td><td>账单总金额</td></tr><tr><td>16</td><td>o_pay_method</td><td>int</td><td></td><td></td><td>否</td><td>支付方式</td></tr><tr><td>17</td><td>o_pay_state</td><td>int</td><td></td><td></td><td>否</td><td>支付状态</td></tr><tr><td>18</td><td>o_pay_dead_line</td><td>date</td><td></td><td></td><td>否</td><td>支付截止时间</td></tr><tr><td>19</td><td>o_pay_time</td><td>datetime</td><td></td><td></td><td>否</td><td>租客支付时间</td></tr></tbody></table><ul><li>用户实名信息表</li></ul><p>用户实名信息表顾名思义，存储着用户的实名数据。包括真实姓名，身份证号码等。表结构如表4-9所示。</p><p>表4-9 用户实名表(userverify)</p><table><thead><tr><th>代号</th><th>字段名</th><th>数据类型</th><th>大小</th><th>说明</th><th>空值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>v_id</td><td>int</td><td></td><td>主键</td><td>否</td><td>实名ID</td></tr><tr><td>2</td><td>u_id</td><td>int</td><td></td><td></td><td>否</td><td>用户ID</td></tr><tr><td>3</td><td>v_real_name</td><td>varchar</td><td>5</td><td></td><td>否</td><td>用户真实姓名</td></tr><tr><td>4</td><td>v_id_card_number</td><td>varchar</td><td>18</td><td></td><td>否</td><td>用户身份证号码</td></tr><tr><td>5</td><td>v_real_id_card_image1</td><td>varchar</td><td>55</td><td></td><td>否</td><td>身份证头像面图片地址</td></tr><tr><td>6</td><td>v_real_Id_card_image_2</td><td>varchar</td><td>55</td><td></td><td>否</td><td>身份证国标面图片地址</td></tr><tr><td>7</td><td>v_real_Id_card_image_with_person</td><td>varchar</td><td>55</td><td></td><td>否</td><td>人手持身份证图片地址</td></tr><tr><td>8</td><td>v_upload_time</td><td>datetime</td><td></td><td></td><td>否</td><td>用户上传更新时间</td></tr><tr><td>9</td><td>v_audit_time</td><td>datetime</td><td></td><td></td><td>是</td><td>管理员审核时间</td></tr><tr><td>10</td><td>v_verify_state</td><td>int</td><td></td><td></td><td>否</td><td>实名信息审核状态</td></tr></tbody></table><h1 id="第五章-系统实现"><a href="#第五章-系统实现" class="headerlink" title="第五章 系统实现"></a>第五章 系统实现</h1><h2 id="5-1公共前台模块"><a href="#5-1公共前台模块" class="headerlink" title="5.1公共前台模块"></a>5.1公共前台模块</h2><h3 id="5-1-1-欢迎页面"><a href="#5-1-1-欢迎页面" class="headerlink" title="5.1.1 欢迎页面"></a>5.1.1 欢迎页面</h3><p>网站的前台模块默认从欢迎页开始显示，该页面提供了登录注册的入口和搜寻房源信息的输入框。输入搜寻内容点击按钮后，页面则会罗列出相关的房源信息。网站的欢迎页面如图5-1所示。</p><p>图5-1 “嘤嘤租房网”欢迎页</p><h3 id="5-1-2-用户注册页"><a href="#5-1-2-用户注册页" class="headerlink" title="5.1.2 用户注册页"></a>5.1.2 用户注册页</h3><p>用户在使用“嘤嘤租房网”时，需要注册一个自己的账号。本网站以手机号码作为登录账号。注册表单在提供用户输入信息的同时加入了校验规则。如：手机号码一定要为中国大陆手机的11位格式、密码和确认密码需要保持一致等。用户注册页面如图5-2所示。</p><p>图5-2 用户注册页面</p><p>注册的代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">RegisterFromUser(regform).then(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.data.success == <span class="literal">true</span>) {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$notify.success({</span><br><span class="line"></span><br><span class="line"><span class="attr">title</span>: <span class="string">"注册成功"</span>,</span><br><span class="line"></span><br><span class="line"><span class="attr">message</span>: <span class="string">"账号已注册成功！请牢记您的密码！"</span></span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$notify.error({</span><br><span class="line"></span><br><span class="line"><span class="attr">title</span>: <span class="string">"登录失败"</span>,</span><br><span class="line"></span><br><span class="line"><span class="attr">message</span>: <span class="string">"用户账号或密码输入错误！"</span></span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.loicon = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">5.1</span><span class="number">.3</span> 用户登录页</span><br><span class="line"></span><br><span class="line">用户需要输入自己的手机号码和登录密码进行登录。当登陆成功后，系统会识别用户的角色类型，跳转到对应的个人中心页面。登录页面如图<span class="number">5</span>-<span class="number">3</span>所示。</span><br><span class="line"></span><br><span class="line">图<span class="number">5</span>-<span class="number">3</span> 用户登录页面</span><br><span class="line"></span><br><span class="line">### <span class="number">5.1</span><span class="number">.4</span> 搜索结果页</span><br><span class="line"></span><br><span class="line">当用户在欢迎页输入关键字搜索、或者查看全部房源信息，系统会将相应的房源信息检索出来罗列在搜索结果页面里。该页面会显示房源的图片、房源宣传标题、房源的信息、租赁的价格和所在的省市区信息，供用户进行简易的查看。搜索结果页面如图<span class="number">5</span>-<span class="number">4</span>所示。</span><br><span class="line"></span><br><span class="line">图<span class="number">5</span>-<span class="number">4</span> 搜索结果页面</span><br><span class="line"></span><br><span class="line">搜索的主要代码如下：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">this.isLoad = true;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">getHouseBySearchKey({// 获取房源所在的区级ID</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">key: this.searchKey,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pageSize:this.pageSize</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}).then(res =\&gt; {//获取模糊查询结果集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">this.TEMPsearchHouseInfo = res.data.data;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for (let i = 0; i \&lt; this.TEMPsearchHouseInfo.length; i++) {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">getFullCityAdd({//根据城市代码拼凑成完整的省市区字符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cbId: this.TEMPsearchHouseInfo[i].hAddressCity</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}).then(res =\&gt; {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let citytext = res.data.data[2] + "省-" + res.data.data[1] + "市" +</span></span><br><span class="line"><span class="string">res.data.data[0] + "区";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">this.searchHouseInfo.push(</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.assign(this.TEMPsearchHouseInfo[i], { cityinfo: citytext })</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">) });}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">});</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-1-5-房源详情页"><a href="#5-1-5-房源详情页" class="headerlink" title="5.1.5 房源详情页"></a>5.1.5 房源详情页</h3><p>当用户对其中某一条的房源信息有兴趣，可点击该条标题，系统会跳出新的页面，为租客展示房源的详情信息。页面主要分成房源信息、房源说明、房源评价三个部分。</p><p>第一部分为房源的信息介绍。内容包括房源的宣传标题、发布时间、房源的各类属性等。单击左边的图片，会全屏显示该房源的图片。此外，这个部分还有两个操作按钮，分别是预约上门看房和发起租房申请。详情页第一部分界面如图5-5所示。</p><p>图5-5 房源详情页第一部分界面</p><p>这两个功能使用的前提为用户已经登录，且已经通过实名认证。如果实名认证未提交、审核中或者被退回，均属于未实名状态，使用这两个功能时会被拦截，并给出相应的提示。其中，实名信息审核中的拦截通知如图5-6所示。</p><p>图5-6 使用功能被拦截的通知界面</p><p>使用功能的代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">checkIsUserAuth</span>(<span class="params"></span>)</span> {</span><br><span class="line"></span><br><span class="line">checkIsAuth(sessionStorage.getItem(<span class="string">"userid"</span>)).then(res =\&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.data.success == <span class="literal">false</span>) {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.\$alert(<span class="string">"原因："</span> + res.data.data, <span class="string">"抱歉，您无法使用此功能"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">});<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用户想要上门看房，点击预约上门看房按钮后，系统会显示一个表单给用户选择期望上门看房的时间和想对房东说的留言。输入完信息后点击确定后，该预约申请会发送到房东。发起看房预约的表单如图5-7所示。</p><p>图5-7 发起看房预约的表单界面</p><p>用户有意向租赁房源，点击发起租房申请按钮后，系统会显示申请的表单给用户填写期望入住的时间范围。对于时间范围提供了三个快捷选项。如果用户想租赁其他范围的时间，也可以自己选择租赁区间，且用户只能被允许选择未来时间。提交后，系统会将租房申请提交给房东。发起租房申请的表单如图5-8所示。</p><p>图5-8 发起租房申请的表单界面</p><p>房源详情页的第二部分主要有房源的介绍和房源的位置两个信息。房源介绍为房东录入的介绍信息，地图使用高德地图的接口，可以通过拖动、缩放等方式知晓房源周围的地理交通。详情页的第二部分的界面如图5-9所示。</p><p>租客发起租房申请的代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("insertOneApplicationForContract")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">PostRentHouseApplication</span><span class="params">(<span class="meta">@RequestBody</span> RentContractDO applicate)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = rentImpl.PostRentHouseApplication(applicate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i\&gt;<span class="number">0</span>){</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(<span class="keyword">true</span>,i);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(<span class="keyword">false</span>,i);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>图5-9 房源详情页第二部分界面</p><p>第三部分为房源的评价部分。当租客结束租房后，系统会提供评价功能让租客去评价这个房源。评价的评价人昵称、分数和内容都会公开在这里。因为评价功能只对已经租赁过该房源、并且租赁已结束的租客开放，真实性相比较会提高很多，可以作为租客租赁房源的一大权衡依据。第三部分的界面如图5-10所示。</p><p>图5-10 房源详情页的第三部分界面</p><h2 id="5-2-租客中心模块"><a href="#5-2-租客中心模块" class="headerlink" title="5.2 租客中心模块"></a>5.2 租客中心模块</h2><h3 id="5-2-1-租客中心的欢迎页"><a href="#5-2-1-租客中心的欢迎页" class="headerlink" title="5.2.1 租客中心的欢迎页"></a>5.2.1 租客中心的欢迎页</h3><p>当租客登录成功后，系统会识别角色并跳转到租客中心。租客中心的界面为侧栏和主栏的布局。在没有使用租客中心的任何功能时，主栏为欢迎状态。租客可以通过侧栏选择需要使用的功能。租客中心提供的功能主要有：实名认证、修改密码、修改个人信息、查看合同、查看账单、查看预约等。<br>租客中心的欢迎页如图5-11所示。</p><p>图5-11 租客中心的欢迎页</p><h3 id="5-2-2-租客中心的实名认证功能"><a href="#5-2-2-租客中心的实名认证功能" class="headerlink" title="5.2.2 租客中心的实名认证功能"></a>5.2.2 租客中心的实名认证功能</h3><p>用户使用点击实名认证后，主栏会显示实名认证的表单。如果用户没有实名信息，或者实名信息被退回，表单会提示用户重新输入相关的实名信息。表单也会显示用户提交的时间和管理员审核的时间，如果有提交实名信息记录，实名信息审核的状态会显示在表单的左上角以章戳的形式标注。用户实名认证的界面如图5-12所示。</p><p>图5-12 租客中心的欢迎页</p><p>用户提交实名信息的代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("postUserAuthInfo")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">insertUserAuthInfomation</span><span class="params">(<span class="meta">@RequestBody</span> UserVerifyDO userAuthInfo)</span></span>{</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"用户提交了身份认证请求："</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(userAuthInfo.toString());</span><br><span class="line"></span><br><span class="line">userAuthInfo.setvUploadTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">System.out.println(userAuthInfo.getvUploadTime());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = userVerifyImpl.insertUserAuthInfo(userAuthInfo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(i);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-3-租客中心的密码修改功能"><a href="#5-2-3-租客中心的密码修改功能" class="headerlink" title="5.2.3 租客中心的密码修改功能"></a>5.2.3 租客中心的密码修改功能</h3><p>用户点击修改密码功能后，主栏会显示相应的表单。该表单拥有基础的校验规则，在校验通过后，新的密码会以MD5加密后更新至数据库当中。修改密码的界面如图5-13所示。</p><p>图5-13 租客中心的密码修改界面</p><p>修改密码的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping("updateUserPwd")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">setUserNewPwd</span><span class="params">(<span class="meta">@RequestBody</span> UsersDO user)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = userImpl.updateUserNewPwd(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-4-租客中心的个人信息编辑功能"><a href="#5-2-4-租客中心的个人信息编辑功能" class="headerlink" title="5.2.4 租客中心的个人信息编辑功能"></a>5.2.4 租客中心的个人信息编辑功能</h3><p>用户想要编辑自己的个人信息时，可以使用此功能。表单可以及时更换头像、昵称、性别等字段。该信息主要用于显示在评论部分。个人信息编辑的界面如图5-14所示。</p><p>图5-14 租客中心的个人信息编辑界面</p><p>上传更新自己头像的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("addUserHeadPortrait")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">uploadUserHeadImage</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line"></span><br><span class="line">String picPath = <span class="string">"E:\\\\vue-test\\\\src\\\\img\\\\userHead\\\\"</span>;<span class="comment">//本地路径</span></span><br><span class="line"></span><br><span class="line">String fileName=file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">String suffix = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line"></span><br><span class="line">String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">"_"</span>);</span><br><span class="line"></span><br><span class="line">String newFileName= <span class="string">"pic"</span>+uuid+suffix;</span><br><span class="line"></span><br><span class="line">file.transferTo(<span class="keyword">new</span> File(picPath,newFileName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(newFileName);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-5-我的合同功能"><a href="#5-2-5-我的合同功能" class="headerlink" title="5.2.5 我的合同功能"></a>5.2.5 我的合同功能</h3><p>当租客想要查看自己签约的和待签约的合同时，可以在这里预览。如果租客拥有待签约的合同，则可以点击操作列的签约按钮；如果租客想回顾查看自己的合同信息时，也可以点击详情操作进行预览。合同功能的界面如图5-15所示。</p><p>图5-15 租客中心的合同列表界面</p><p>租客点击详情后，系统会显示用于展示合同的主要信息的模态框。租客同样可以点击按钮查看合同详情。合同详情的界面如图5-16所示。</p><p>图5-16 合同详情的模态框界面</p><p>当租客想要提前退房，需要在合同的模态框里，点击退房的按钮。因为提前结束合同属于违约的操作，所以系统会提示租客该操作的后果。违约提示框如图5-16所示。</p><p>图5-16 租客违约退房的确认框</p><p>租客退房（违约）的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">let formdata = {</span><br><span class="line"></span><br><span class="line">cId: <span class="keyword">this</span>.contractInfo.cId,</span><br><span class="line"></span><br><span class="line">cContractState: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">tenantsCancelContractApplication(formdata).then(res =\&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.data.success == <span class="keyword">true</span>) {</span><br><span class="line"></span><br><span class="line">Bus.\$emit(<span class="string">"tenantsCancelRCApp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.\$message({</span><br><span class="line"></span><br><span class="line">type: <span class="string">"warning"</span>,</span><br><span class="line"></span><br><span class="line">message: <span class="string">"您的请求已经发送给房东，该合同已被冻结!"</span></span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.\$message({</span><br><span class="line"></span><br><span class="line">type: <span class="string">"info"</span>,</span><br><span class="line"></span><br><span class="line">message: <span class="string">"退房申请异常。"</span></span><br><span class="line"></span><br><span class="line">});}});</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-6-我的账单功能"><a href="#5-2-6-我的账单功能" class="headerlink" title="5.2.6 我的账单功能"></a>5.2.6 我的账单功能</h3><p>租客查看自己的账单信息时，点击按钮后主栏会展示租客的所有账单信息。租客可以单击“详情”按钮查看账单的所有信息。我的账单界面如图5-17所示。</p><p>图5-17 租客账单列表界面</p><p>租客点击详情按钮后，系统会显示该条账单的所有信息。“嘤嘤租房网”已对接支付宝支付，如果该账单属于未支付状态的账单，系统会开放支付按钮供租客支付。账单详情的界面如图5-18所示。</p><p>图5-18 账单详情的界面</p><p>用户使用支付宝付款，发起页面的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("launchToAlipay")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">luanchOrderToALiPay</span><span class="params">(<span class="meta">@RequestParam(value = "oId")</span> Integer oId,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@RequestParam(value = "oOrderMoney")</span> Float oOrderMoney,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@RequestParam(value = "info")</span> String info)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt;   <span class="keyword">throws</span> AlipayApiException </span>{</span><br><span class="line"></span><br><span class="line">String subject=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">subject =<span class="keyword">new</span> String(info.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">}<span class="keyword">catch</span> (UnsupportedEncodingException e){</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> orderImpl.alipay( <span class="keyword">new</span> ALiPayDO()</span><br><span class="line"></span><br><span class="line">.setOut_trade_no(oId.toString())</span><br><span class="line"></span><br><span class="line">.setTotal_amount(<span class="keyword">new</span> StringBuffer().append(oOrderMoney))</span><br><span class="line"></span><br><span class="line">.setSubject(subject));</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-7-我的看房预约功能"><a href="#5-2-7-我的看房预约功能" class="headerlink" title="5.2.7 我的看房预约功能"></a>5.2.7 我的看房预约功能</h3><p>当租客想要查看自己预约申请，或者想要查看房东的回复时，需要在“我的看房预约”界面查看，界面如图5-19所示。</p><p>图5-19 看房预约列表界面</p><p>如果租客发起的看房预约未被房东处理，租客可以取消自己发起的预约；对于已经处理过的预约申请，系统仍然为租客保留查看的功能。界面如图5-20所示。</p><p>图5-20 预约详情的界面</p><h2 id="5-3-房东中心模块"><a href="#5-3-房东中心模块" class="headerlink" title="5.3 房东中心模块"></a>5.3 房东中心模块</h2><h3 id="5-3-1-房东中心的欢迎页"><a href="#5-3-1-房东中心的欢迎页" class="headerlink" title="5.3.1 房东中心的欢迎页"></a>5.3.1 房东中心的欢迎页</h3><p>当房东角色的用户登录成功后，系统会跳转到房东的个人中心页面，等待房东的下一步操作。</p><h3 id="5-3-2-新增房源功能"><a href="#5-3-2-新增房源功能" class="headerlink" title="5.3.2 新增房源功能"></a>5.3.2 新增房源功能</h3><p>房东在实名通过后，可以根据自己的需要发布自己拥有的房源。在表单里，需要房东录入介绍标题、房源图片和租赁价格等租赁房源需要的相关信息。房东填写完点击提交按钮，表单对输入的信息校验通过后，则会把房源的信息上传至系统，等待管理员审核。新增房源信息的界面如图5-22所示。</p><p>图5-22 新增房源信息的界面</p><p>房东新增房源的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("addHouseInfo")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">insertHouseInfomation</span><span class="params">(<span class="meta">@RequestBody</span> HouseInfomationDO house)</span></span>{</span><br><span class="line"></span><br><span class="line">house.sethPostTime((<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = houseimpl.insertHouseInfo(house);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i\&gt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(<span class="keyword">true</span>,i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(<span class="keyword">false</span>,i);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-3-房源列表功能"><a href="#5-3-3-房源列表功能" class="headerlink" title="5.3.3 房源列表功能"></a>5.3.3 房源列表功能</h3><p>房东想查看自己房源的信息或者更新自己的房源信息时，房东需要点击房源列表，主栏会显示自己拥有的房源信息的列表。列表界面的布局主要为表格和按钮。列表展示房东的房源信息，按钮为刷新数据按钮，如果数据没有更新至最新，房东可以手动更新。房东的房源列表的界面如图5-23所示。</p><p>图5-23房源列表界面</p><p>展示属于房东的房源列表的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("getMastersHouse")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getMasterAllHouse</span><span class="params">(Integer uid)</span></span>{</span><br><span class="line"></span><br><span class="line">List\&lt;HouseInfomationDO\&gt; houselist = houseimpl.getMasterAllHouse(uid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(houselist);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>房东查看某一条房源信息的详情编辑按钮，系统会弹出一个模态框，模态框将会展示该条房源的详细信息。房东可以对这条房源进行信息的维护更新；如果房源处于出租状态，房源信息无法更新，需要等房源租赁结束，状态为空闲时，房东才被允许维护房源信息。房源详情编辑“辅助介绍”步骤的界面如图5-24所示。</p><p>图5-24 房源编辑详情的模态框界面</p><h3 id="5-3-4-看房预约管理功能"><a href="#5-3-4-看房预约管理功能" class="headerlink" title="5.3.4 看房预约管理功能"></a>5.3.4 看房预约管理功能</h3><p>租客发起的看房预约都会被归纳到看房预约管理列表里。房东在侧栏单击预约管理按钮时，主栏会显示预约的信息列表。上门看房预约管理的界面如图5-25所示。</p><p>图5-25 上门看房预约管理列表的界面</p><p>系统会对不同状态的预约，开放相应的操作按钮。看房预约的处理的界面如图5-26所示。</p><p>图5-26预约详情的处理模态框界面</p><h3 id="5-3-5-合同管理功能"><a href="#5-3-5-合同管理功能" class="headerlink" title="5.3.5 合同管理功能"></a>5.3.5 合同管理功能</h3><p>租客在网站向自己的房源发起的所有租房申请都会被归纳到房东中心的合同列表里。房东可以对合同进行进一步的处理。如，发起合同、查看合同。合同管理的界面如图5-27所示。</p><p>图5-27 房东中心的合同管理列表界面</p><p>房东可以对租客发起的申请进行处理。单击“发起合同”按钮后，系统将会显示租客的信息和房源的信息供房东进行二次确认，并提供本次合同的相关数据。房东也可以点击“拒绝发起签约”拒绝该申请。房东发起合同的模态框界面如图5-28所示。</p><p>图5-28 房东发起合同的模态框界面</p><p>房东发起合同的主要代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">MasterUpdateContract</span>(<span class="params"></span>)</span>{</span><br><span class="line">masterPutContractInfo(updateformdata).then( res =\&gt; {</span><br><span class="line"><span class="keyword">if</span>(res.data.success == <span class="literal">true</span>){</span><br><span class="line"><span class="built_in">this</span>.\$message.success(<span class="string">"合同创建完成！等待租客阅读并同意签约合同！"</span>);</span><br><span class="line">Bus.\$emit(<span class="string">"launchNewContract"</span>,<span class="string">"success"</span>)</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">this</span>.\$message(<span class="string">"合同创建出现了问题"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">this</span>.isContractFormShow = <span class="literal">false</span>;</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-6-收租功能"><a href="#5-3-6-收租功能" class="headerlink" title="5.3.6 收租功能"></a>5.3.6 收租功能</h3><p>房东点击我的收租按钮后，主栏会显示收租的列表。列表会显示已经收租的账单数据。对于未支付的账单，房东可以对其进行处理；对于已支付或者已取消的账单，房东也可以对账单进行再次的查看。房东也可点击“发起收租账单”按钮向租客发起账单。收租管理的界面如图5-29所示。</p><p>图5-29 房东的收租管理功能</p><p>房东点击“发起收租账单”按钮后，系统会拉出一个收租抽屉界面。该界面把收租的流程分为4步。在第一步时，需要房东选择收租的对象。收租的对象为签约并正在执行期内合同的所有租客；如果某一租客还存在未入账的账单，则无法对该租客进行重复收租。选择收租对象后，系统会读取相关的数据显示在界面上。在后续的步骤里，需要房东填入租客在这一周期使用的电度、水度和选填的额外的调节费用。系统会计算出相应的房租。房东选择收租截止日期、点击提交账单后，系统会将新的抄表信息更新到房源信息数据里，并且会把账单信息发送至租客的手机号上提醒租客及时缴交。收租抽屉界面如图5-30所示。</p><p>图5-30 发起收租账单的操作界面</p><p>房东发起账单的主要代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">toNextStep</span>(<span class="params"></span>)</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.cId == <span class="string">""</span>) {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.\$message.warning(<span class="string">"请先选择收租的对象哦"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.launchBillStep == <span class="number">3</span>) {</span><br><span class="line"></span><br><span class="line">launchOrderInfo(<span class="built_in">this</span>.billform).then(res =\&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.data.data \&gt; <span class="number">0</span>) {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.launchSMSInfo();<span class="comment">//发送短信</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.updateHouseInfomation(); <span class="comment">//更新房屋水电信息</span></span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.\$message(<span class="string">"发起账单可能出现了问题，发起失败！"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.isPreBtnDisabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (++<span class="built_in">this</span>.launchBillStep == <span class="number">3</span>) {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.btnLaunchName = <span class="string">"发起账单给租客"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算账单,(本次抄表-上次抄表)\*单价+其他费用</span></span><br><span class="line"></span><br><span class="line">oOrderMoney = ((oNowElectricNumber - oLastElectricNumber) \* oElectricPrice )+</span><br><span class="line">((oNowWaterNumber -oLastWaterNumber) \* oWaterPrice) + oHouseRentPrice +</span><br><span class="line"><span class="built_in">this</span>.billform.oAdjustFee;</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.btnLaunchName = <span class="string">"下一步"</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>房东除了发起收租外，也可以查看其他向自己入账的账单信息。对于已支付或者已关闭状态的账单，房东可以查看；对于未支付状态的账单，房东可以选择取消这份账单。取消账单并确认取消后，系统会还原之前的水表和电表的读数，并且该账单会拦截，不让租客支付。如果租客以线下其他方式向房东缴租，房东可以选择线下收到房租。其界面如图5-31所示。</p><p>图5-31 租客中心的个人信息编辑界面</p><h3 id="5-3-7-房东中心的实名认证功能"><a href="#5-3-7-房东中心的实名认证功能" class="headerlink" title="5.3.7 房东中心的实名认证功能"></a>5.3.7 房东中心的实名认证功能</h3><p>房东在注册完账号进入自己的个人中心后，需要进行实名认证。实名认证的操作流程与租客的操作流程一致。</p><h3 id="5-3-8-房东中心的个人信息编辑功能"><a href="#5-3-8-房东中心的个人信息编辑功能" class="headerlink" title="5.3.8 房东中心的个人信息编辑功能"></a>5.3.8 房东中心的个人信息编辑功能</h3><p>房东可以在此页面修改自己的个人信息和头像。操作流程与租客的个人信息编辑功能一致。</p><h3 id="5-3-9-房东中心的密码修改功能"><a href="#5-3-9-房东中心的密码修改功能" class="headerlink" title="5.3.9 房东中心的密码修改功能"></a>5.3.9 房东中心的密码修改功能</h3><p>房东可以根据需要在此模块修改自己的登录密码。房东修改密码的流程与租客的密码修改流程一致。</p><h2 id="5-4-管理员模块"><a href="#5-4-管理员模块" class="headerlink" title="5.4 管理员模块"></a>5.4 管理员模块</h2><p>管理员从管理员登录页面输入账号，登录成功后会跳转到后台管理中心。</p><h3 id="5-4-1-用户实名信息审核"><a href="#5-4-1-用户实名信息审核" class="headerlink" title="5.4.1 用户实名信息审核"></a>5.4.1 用户实名信息审核</h3><p>网站的用户在自己的个人中心提交的实名信息，都会归纳到管理中心等待管理员审核。显示管理员审核实名信息的界面如图5-32所示。</p><p>图5-32 实名审核信息列表界面</p><p>管理员可以审核并无限查看某条实名信息。管理员可以点击图片全屏查看证件信息。对于需要审核的信息，模态框会开放处理选项。管理员需要选择结果后提交处理。实名信息审核方算完成审核。展示实名信息详情的界面如图5-33所示。</p><p>图5-33 审核实名信息的详情界面</p><h3 id="5-4-2-房源信息审核"><a href="#5-4-2-房源信息审核" class="headerlink" title="5.4.2 房源信息审核"></a>5.4.2 房源信息审核</h3><p>管理员需要审核用户发布的房源信息。通过审核的房源信息才可以在网站前端被用户搜索到。管理员的房源审核列表如图5-34所示。</p><p>图5-34 房源审核列表的界面</p><p>管理员点击房源详情时，会显示一个写着房源详情信息的模态框。如果是待审核的房源，模态框会开放处理选项供管理员处理。其如图5-35所示。</p><p>图5-35 管理员查看房源详情的界面</p><p>管理员审核房源信息的主要代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping("adminProcessHouseAuditState")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">adminProcessHouseAuditState</span><span class="params">(<span class="meta">@RequestBody</span> HouseInfomationDO</span></span></span><br><span class="line"><span class="params"><span class="function">record)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = houseimpl.updateHouseInfo(record);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.create(i);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="第六章-系统测试"><a href="#第六章-系统测试" class="headerlink" title="第六章 系统测试"></a>第六章 系统测试</h1><h2 id="6-1-系统用例测试"><a href="#6-1-系统用例测试" class="headerlink" title="6.1 系统用例测试"></a>6.1 系统用例测试</h2><p>系统测试主要是功能测试，检测各功能模块是否能够正常运行，系统整体功能是否完善，运行过程是否顺利，界面是否整洁美观。</p><p>重置密码测试用例如表6-1所示。</p><p>表6-1 修改密码测试用例</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>CS01</td></tr><tr><td>用例名：</td><td>用户修改密码</td></tr><tr><td>输入信息：</td><td>原密码、新密码、确认新密码</td></tr><tr><td>输出信息：</td><td>密码成功修改后，提示用户修改结果</td></tr><tr><td>过程：</td><td>1）用户进入自己的个人中心界面，点击修改密码。 2）用户输入原密码一次，输入新密码两次。 3）点击“保存修改”按钮修改密码，成功后提示用户修改结果，并清空输入框。</td></tr></tbody></table><p>房东用户发起账单用例如表6-2所示。</p><p>表6-2 房东发起新账单测试用例</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>CS02</td></tr><tr><td>用例名：</td><td>房东发起新账单</td></tr><tr><td>输入信息：</td><td>输入标题、介绍、房源属性、价格、押付类型、上传图片。</td></tr><tr><td>输出信息：</td><td>上传成功后，提示用户上传结果。</td></tr><tr><td>过程：</td><td>1）进入房东中心，点击“发布房源”按钮 2）输入标题、介绍、房源属性、价格、押付类型 3）上传图片 4）点击“保存”按钮，成功后返回上传结果。</td></tr></tbody></table><p>用户发表文章评论测试用例如表6-3所示。</p><p>表6-3 租客评价房东测试用例</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>用例编号：</td><td>CS03</td></tr><tr><td></td><td>续表6-3</td></tr><tr><td>用例名：</td><td>租客评价房东</td></tr><tr><td>输入信息：</td><td>输入评价内容，选择评价分</td></tr><tr><td>输出信息：</td><td>评价成功，可以在合同查看评价信息</td></tr><tr><td>过程：</td><td>1）合同结束后，点击“合同详情”，再点击“评价TAA”按钮 2）输入评价的内容，选择评价的分数 3）点击“提交评价”按钮，进行评价。</td></tr></tbody></table><h2 id="6-2-测试结果"><a href="#6-2-测试结果" class="headerlink" title="6.2 测试结果"></a>6.2 测试结果</h2><p>“嘤嘤租房网”的所有功能的测试结果如下：</p><p>（1）前台。前台的用户登录、注册功能、搜索房源、提交申请与预约请求、实名认证、合同管理、预约管理、账单管理、租客、房源与房东评价、房源管理等模块均通过了测试。</p><p>（2）网站的管理员登录后台后，可以实现对房源的审核、实名信息的审核。以上模块均通过了测试。</p><h1 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h1><p>这一次毕业设计，是第三次自己规划并开发一个较为完整的网站。在开发“嘤嘤租房网”网站时，遇到了几个比较关键的问题。首先的是使用的技术。原本在构思课题时只考虑使用SSM框架，并以jsp页面进行内容的呈现；但在网络上搜集资料时，我逐渐发现前后端分离开发更加贴合现在主流的开发方式。在寻找前端时，发现了基于Vue技术的Element<br>UI框架。此框架简洁干净，也贴合租房这一商业性质网站的风格。综上所述，本课题的网站框架采用Vue与SSM，奠定了网站后续的开发方向。</p><p>有句话叫“万事开头难”。在网站的开发初期，没有接触过前后端分离开发的我遇到了瓶颈。比如：Vue里如何做到数据对接、数据没有及时到达页面造成排版异常等等。有些问题的原因单一，也有的问题原因多种多样；我无从下手，不知如何解决。在同学的指导下，我学会通过报错日志与浏览器控制台的报错信息来定位问题，从而寻找解决办法。</p><p>在后续的开发过程中，理所当然却也无可奈何地遇到了各式各样的问题。在解决这些问题时，最初只能求助网络，寻找类似问题的先例并在自己项目上逐步进行实践以解决当下的错误。长此以往，我发现，当相似的问题遇到一定量后，大脑内会形成一定的解决思路。这令我在往后遇到问题时能更有效率地去解决，我相信，这些经验在以后的工作实战里有着不小的帮助。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>王飞.论房屋租赁信息系统的设计与实现[J].电脑迷,2017(07):194-195.</li></ul><ol start="2"><li><p> 罗树立.加入WTO给中国房地产业带来的挑战及应对措施[J].中共成都市委党校学报,2002(6):35~36.</p></li><li><p> 巴民.国外的住房市场[J].重庆国土资源,2005(5):39~40.</p></li><li><p> 吴浪,高际家.房屋租赁市场的中美比较分析[J].青年科学,2010(2):197~198.</p></li><li><p> 沈克明.纽约政府如何补贴穷人住房[J].新财经,2006(8):80~81.</p></li><li><p> 冯博.中国廉租房制度与日本公营住房政策的比较研究[D].山西财经大学,2010.</p></li><li><p> 刘海洋,陈海.廉租房在国外[J].中州建设,2011(6):74~75.</p></li><li><p> 隋琛琛.廉租房制度国内外比较与借鉴[J].上海房地,2009,14(7):22~25.</p></li><li><p> 房屋租售管理系统的设计与实现[J].尹凌.计算机光盘软件与应用.2012(22)</p></li><li><p> 武海龙,李国平.基于SpringBoot的房屋租赁系统设计[J].电脑与信息术,2019,27(03):76-78.</p></li></ol><p>1 - 战松,郎妲妮.长租公寓现存问题分析及解决对策[J].辽宁经济,2019(11):70-71.</p><ol start="12"><li><p>Márcio Moraes Valença. Social rental housing in HK and the UK: Neoliberal<br> policy divergence or the market in the making?[J]. Habitat<br> International,2015,49.</p></li><li><p>Barton, Barbara. Earning Extra Income With Rent Houses[J]. Ranch and Rural<br> Living,2011,92(5).</p></li></ol><h1 id="致-谢"><a href="#致-谢" class="headerlink" title="致 谢"></a>致 谢</h1><p>本篇论文到了致谢部分，说明在自己的努力和大家的帮助下，我完成了论文的大部分内容。首先，我想感谢我的导师杨财英老师。毕业设计是第一次一个人独立完成一个较为完整的网站，从选题、设计数据库到开发，每一步都需要先慎重思考以避免无效努力。感谢她的指导，我才能更顺利地完成选题方面、逻辑方面等许多环节的任务；也感谢老师的督促，老师的负责也是我能按期完成网站不可少的要素。</p><p>接着，我想感谢我周围的同学与老师，感谢他们能在我碰到技术性的问题无法解决时，帮助我一起解决；也感谢我的朋友们能以使用者的角度给我提出使用的感想，让我能修改出目前最贴合生产环境里的操作界面与交互效果。也感谢他们在我碰到瓶颈时，能给我信心。在大学这段时间里，校园的视野让我能更投入地去学习自己的专业知识。感谢老师们这几年的教学，让我打下了一定的基础；在遇到问题时对比以往让我用不同的角度去看待并解决。</p><p>再次感谢大家的帮助与教诲。学无止境，今后走出象牙之塔，我仍会保持谦逊的态度，努力学习，提升自己，认真完成每一件事情！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 毕业设计 </tag>
            
            <tag> Vue </tag>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记</title>
      <link href="2021/05/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/05/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-React简介"><a href="#1-React简介" class="headerlink" title="1. React简介"></a>1. React简介</h2><blockquote><p>轻量级的视图层<strong>库</strong>！<em>A JavaScript library for building user interfaces</em></p><p>React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；React 主要用于构建UI，可以简单地理解为React 将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。</p></blockquote><h3 id="1-1-组件化"><a href="#1-1-组件化" class="headerlink" title="1.1 组件化"></a>1.1 组件化</h3><ol><li><p><strong>什么是模块化：</strong>是从<strong>代码</strong>的角度来进行分析的；把一些可复用的代码，抽离为单个的模块；便于项目的维护和开发；</p></li><li><p><strong>什么是组件化：</strong> 是从 <strong>UI 界面</strong>的角度 来进行分析的；把一些可复用的UI元素，抽离为单独的组件；便于项目的维护和开发；</p><p><strong>组件化的好处：</strong>随着项目规模的增大，手里的组件越来越多；很方便就能把现有的组件，拼接为一个完整的页面；</p></li><li><p><strong>Vue是如何实现组件化的：</strong> 通过 <code>.vue</code> 文件，来创建对应的组件；</p><ul><li>template  结构</li><li>script        行为</li><li>style          样式</li></ul></li></ol><ol start="5"><li><strong>React如何实现组件化</strong>：大家注意，React中有组件化的概念，但是，并没有像vue这样的组件模板文件；React中，一切都是以js来表现的</li></ol><h3 id="1-2-移动APP"><a href="#1-2-移动APP" class="headerlink" title="1.2 移动APP"></a>1.2 移动APP</h3><ul><li>Vue，结合 Weex 实现移动端App开发</li><li>React，结合 ReactNative 实现移动端App开发</li></ul><h2 id="2-React的虚拟DOM"><a href="#2-React的虚拟DOM" class="headerlink" title="2. React的虚拟DOM"></a>2. React的虚拟DOM</h2><ul><li><p><strong>真实DOM：</strong>是浏览器中的概念是用JS对象来表示页面上的元素，并提供了操作 DOM 对象的API。</p></li><li><p><strong>虚拟DOM</strong>：是框架中的概念是用JS对象来模拟页面上的 DOM 和 DOM嵌套。</p><p><strong>本质：</strong> 用JS对象，来模拟DOM元素和嵌套关系</p><p><strong>目的：</strong> 就是为了实现页面元素的高效更新</p></li><li><p>React 高性能</p></li></ul><ul><li>React Fiber</li></ul><h2 id="3-React的特点和优势"><a href="#3-React的特点和优势" class="headerlink" title="3. React的特点和优势"></a>3. React的特点和优势</h2><ul><li><p>虚拟DOM</p></li><li><p>组件系统</p></li><li><p>单向数据流</p></li><li><p>jsx语法</p></li></ul><h2 id="4-快速构建React开发环境"><a href="#4-快速构建React开发环境" class="headerlink" title="4. 快速构建React开发环境"></a>4. 快速构建React开发环境</h2><ol><li><p>使用 create-react-app脚手架 快速构建 React 开发环境</p></li><li><p>引入react、react-dom</p></li><li><p>创建DOM元素渲染</p></li><li><p>元素与组件</p></li></ol><h2 id="5-JSX的语法"><a href="#5-JSX的语法" class="headerlink" title="5. JSX的语法"></a>5. JSX的语法</h2><ol><li>jsx介绍<ul><li>jsx 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 jsx编写模板更加简单快速。</li></ul></li><li>jsx的使用<ul><li>jsx语法中, 要把js代码写到{}号中</li></ul></li><li>jsx中的注意事项<ul><li>注释推荐使用<code>{ /* 这是注释 */ }</code></li><li>在jsx创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</li><li>在 jsx 语法中，标签必须成对出现，如果是单标签，则必须自闭和</li></ul></li></ol><h2 id="6-React中创建组件"><a href="#6-React中创建组件" class="headerlink" title="6. React中创建组件"></a>6. React中创建组件</h2><ol><li><p>组件的创建方式</p><ol><li>函数式组件(<strong>首字母必须大写</strong>)</li><li>class关键字组件</li></ol></li><li><p> 两种组件的区别:</p></li></ol><ul><li><p>用<strong>函数</strong>创建出来的组件：叫做“无状态组件”</p></li><li><p>用<strong>class关键字</strong>创建出来的组件：叫做“有状态组件”</p></li><li><p>这两种组件<strong>本质区别</strong>就是：有无state属性</p></li></ul><ol start="3"><li>组件之间的组合和嵌套</li></ol><h2 id="7-JSX原理"><a href="#7-JSX原理" class="headerlink" title="7. JSX原理"></a>7. JSX原理</h2><ol><li><p>JS对象构建DOM结构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'app'</span> id=<span class="string">'root'</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">'title'</span>&gt;</span>铁蛋儿很帅<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    昌平小白龙</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>上面这个 HTML 所有的信息我们都可以用 JavaScript 对象来表示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">'div'</span>,</span><br><span class="line">  <span class="attr">attrs</span>: { <span class="attr">className</span>: <span class="string">'app'</span>, <span class="attr">id</span>: <span class="string">'root'</span>},</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">'h1'</span>,</span><br><span class="line">      <span class="attr">attrs</span>: { <span class="attr">className</span>: <span class="string">'title'</span> },</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">'铁蛋很帅'</span>]</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">'p'</span>,</span><br><span class="line">      <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">'昌平小白龙'</span>]</span><br><span class="line">    },</span><br><span class="line">    <span class="string">'123'</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>React中构建DOM结构</p><p>React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、还有子元素等</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  render () {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'app'</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">'title'</span>&gt;</span>欢迎铁蛋儿<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">         昌平小白龙</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>编译之后将得到的代码:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  render () {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      React.createElement(</span><br><span class="line">        <span class="string">"div"</span>,</span><br><span class="line">        {</span><br><span class="line">          <span class="attr">className</span>: <span class="string">'app'</span>,</span><br><span class="line">          <span class="attr">id</span>: <span class="string">'root'</span></span><br><span class="line">        },</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">"h1"</span>,</span><br><span class="line">          { <span class="attr">className</span>: <span class="string">'title'</span> },</span><br><span class="line">          <span class="string">"铁蛋很帅"</span></span><br><span class="line">        ),</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">"p"</span>,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          <span class="string">"昌平小白龙"</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">React.createElement(App),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="8-组件中DOM样式"><a href="#8-组件中DOM样式" class="headerlink" title="8. 组件中DOM样式"></a>8. 组件中DOM样式</h2><ol><li><p>行内样式</p></li><li><p>使用class</p></li><li><p>classnames</p><blockquote><p>npm  install  classnames –save</p></blockquote></li><li><p>styled-components</p><blockquote><p>npm  install  styled-components –save</p></blockquote></li></ol><h2 id="9-组件的属性-props"><a href="#9-组件的属性-props" class="headerlink" title="9. 组件的属性(props)"></a>9. 组件的属性(props)</h2><ol start="2"><li>class组件的属性和默认属性</li><li>函数组件的属性和默认属性</li><li>组件的props.children属性</li><li>使用props-type检查props</li></ol><h2 id="10-组件的状态-state"><a href="#10-组件的状态-state" class="headerlink" title="10. 组件的状态(state)"></a>10. 组件的状态(state)</h2><ol><li><p>创建组件状态的两种方式</p><ul><li>普通方式</li><li>继承方式</li></ul></li><li><p>设置组件状态(setState)</p><p>setState方法(有两个参数)设置状态</p><ul><li><p>第一个参数可以是对象，也可以是方法return一个对象。</p><ul><li>参数是对象</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState({</span><br><span class="line">  <span class="attr">isBool</span>: !<span class="built_in">this</span>.state.isBool</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>参数是方法</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1是上一次的state, 参数2是props</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">isBool</span>: !prevState.isBool</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li><p>setState是异步的,所以想要获取最新的state, 没有办法获取,就有了第二个参数,这是一个可选的回调函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">isBool</span>: !prevState.isBool</span><br><span class="line">  }</span><br><span class="line">}, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'回调里的'</span>,<span class="built_in">this</span>.state.isBool)</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setState外部的'</span>,<span class="built_in">this</span>.state.isBool)</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>渲染数据</p><ul><li>条件渲染</li><li>列表渲染</li><li>dangerouslySetInnerHTML方法</li></ul></li></ol><h2 id="11-属性-VS-状态"><a href="#11-属性-VS-状态" class="headerlink" title="11. 属性 VS 状态"></a>11. 属性 VS 状态</h2><p><strong>属性</strong></p><p><code>props</code> 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。</p><p>它是外部传进来的配置参数，组件内部无法控制也无法修改。</p><p>除非外部组件主动传入新的 <code>props</code>，否则组件的 <code>props</code> 永远保持不变。</p><p><strong>状态</strong>    </p><p> <code>state</code> 的主要作用是用于组件保存、控制、修改自己的可变状态。</p><p> <code>state</code> 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。</p><p> <code>state</code> 是一个局部的、只能被组件自身控制的数据源。</p><p> <code>state</code> 中状态可以通过 <code>this.setState</code>方法进行更新，<code>setState</code> 会导致组件的重新渲染。 </p><blockquote><p>如果搞不清 <code>state</code> 和 <code>props</code> 的使用场景，记住一个简单的规则：**尽量少地用 <code>state</code>，多用 <code>props</code>**。</p><p>没有 state 的组件叫<strong>无状态组件</strong>，设置了 state 的叫做<strong>有状态组件</strong>。</p><p>组件的数据渲染是否被调用者传递的<code>props</code>完全控制，控制则为<strong>受控组件</strong>，否则<strong>非受控组件</strong>。</p><p>因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。</p><p>这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p></blockquote><h2 id="12-事件"><a href="#12-事件" class="headerlink" title="12. 事件"></a>12. 事件</h2><ol><li><p>绑定事件</p><blockquote><p>采用on+事件名的方式来绑定一个事件，React和原生的事件是有区别的，原生的事件全是小写<code>onclick</code>, React中的事件是驼峰<code>onClick</code>，<strong>React的事件并不是原生事件，而是合成事件</strong>。</p></blockquote></li><li><p>事件用法</p><ul><li>直接在render里写行内的箭头函数(不推荐)</li><li>在组件内使用箭头函数定义一个方法(推荐)</li><li>直接在组件内定义一个非箭头函数的方法，然后在render里直接使用<code>onClick={this.handleClick.bind(this)}</code>(不推荐) </li><li>直接在组件内定义一个非箭头函数的方法，然后在constructor里bind(this)(官方推荐)</li></ul></li><li><p>Event对象</p><blockquote><p>和普通浏览器一样，事件handler会被自动传入一个 <code>event</code> 对象，这个对象和普通的浏览器 <code>event</code> 对象所包含的方法和属性都基本一致。不同的是 React中的 <code>event</code> 对象并不是浏览器提供的，而是它自己内部所构建的。它同样具有<code>event.stopPropagation</code>、<code>event.preventDefault</code> 这种常用的方法</p></blockquote></li><li><p>事件的参数传递</p><ul><li>在<code>render</code>里调用方法的地方外面包一层箭头函数 </li><li>在<code>render</code>里通过<code>this.handleEvent.bind(this, 参数)</code>这样的方式来传递</li></ul></li></ol><h2 id="13-用户输入案例"><a href="#13-用户输入案例" class="headerlink" title="13. 用户输入案例"></a>13. 用户输入案例</h2><ol><li>创建用户输入组件</li><li>添加状态绑定事件</li><li>改变状态更新组件</li></ol><h2 id="14-组件的生命周期"><a href="#14-组件的生命周期" class="headerlink" title="14. 组件的生命周期"></a>14. 组件的生命周期</h2><p>React中组件也有生命周期，有很多钩子函数供我们使用, 组件的生命周期，分为四个阶段，初始化、运行中、销毁、错误处理(16.3之后)</p><h4 id="初始化执行"><a href="#初始化执行" class="headerlink" title="初始化执行"></a>初始化执行</h4><ol><li><p>constructor&nbsp;</p></li><li><p>componentWillMount()&nbsp;/&nbsp;UNSAFE_componentWillMount()</p><ul><li> 组件被挂载到页面之前，自动被执行</li></ul></li><li><p>render()&nbsp; </p><ul><li>渲染组件</li></ul></li><li><p>componentDidMount() </p><ul><li>组件被挂载到页面之后，自动被执行</li></ul></li></ol><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p><code>props</code>或<code>state</code>的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法：</p><ol><li><p>componentWillReceiveProps()&nbsp;/&nbsp;UNSAFE_componentWillReceiveProps()&nbsp;</p><ul><li><p>子组件要从父组件接受参数，如果这个组件第一次存在于父组件中,不会执行</p><p>如果这个组件之前已经存在于父组件中，才会执行</p></li></ul></li><li><p>shouldComponentUpdate()&nbsp; </p><ul><li>组件被更新之前，自动执行返回true/false来决定 render是否更新  </li></ul></li><li><p>componentWillUpdate()&nbsp;/&nbsp;UNSAFE_componentWillUpdate()&nbsp;</p><ul><li><p>组件被更新之前它会自动执行但是在shouldComponentUpdate之后执行</p><p>shouldComponentUpdate返回true它才会执行，如果返回false，这个函数就不会被执行</p></li></ul></li><li><p>render()&nbsp;</p></li><li><p>componentDidUpdate()</p><ul><li>组件更新完成以后被执行</li></ul></li></ol><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><ol><li>componentWillUnmount()<ul><li>组件即将被从页面中剔除的时候执行</li></ul></li></ol><h2 id="15-ref属性"><a href="#15-ref属性" class="headerlink" title="15. ref属性"></a>15. ref属性</h2><p>React提供的这个<code>ref</code>属性，表示对组件真正实例的引用，其实就是<code>ReactDOM.render()</code>返回的组件实例,<code>ref</code>可以挂载到组件上也可以是dom元素上。</p><ul><li>挂到组件(<code>class</code>声明的组件)上的ref表示对组件实例的引用。<strong>不能</strong>在函数式组件上使用 ref 属性，因为它们没有实例：</li><li>挂载到dom元素上时表示具体的dom元素节点。</li></ul><h2 id="16-组件通信"><a href="#16-组件通信" class="headerlink" title="16. 组件通信"></a>16. 组件通信</h2><h4 id="父组件与子组件通信"><a href="#父组件与子组件通信" class="headerlink" title="父组件与子组件通信"></a>父组件与子组件通信</h4><ul><li>父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</li><li>父组件利用<code>ref</code>对子组件做标记，通过调用子组件的方法以更改子组件的状态,也可以调用子组件的方法</li></ul><h4 id="子组件与父组件通信"><a href="#子组件与父组件通信" class="headerlink" title="子组件与父组件通信"></a>子组件与父组件通信</h4><ul><li>父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过<code>this.props</code>接收到父组件的方法后调用。</li></ul><h4 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h4><p>在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系。react提供了<code>context</code> api来实现跨组件通信, React 16.3之后的<code>context</code>api较之前的好用。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>实例，使用<code>context</code> 实现购物车中的加减功能</p><blockquote><p>复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，在实际的工作中我们会使用flux、redux、mobx来实现</p></blockquote><h2 id="17-HOC-高阶组件"><a href="#17-HOC-高阶组件" class="headerlink" title="17. HOC(高阶组件)"></a>17. HOC(高阶组件)</h2><blockquote><p>高阶组件是一个函数接受一个组件作为参数，返回一个新的组件</p></blockquote><h2 id="18-React-Router"><a href="#18-React-Router" class="headerlink" title="18. React Router"></a>18. React Router</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>React Router甚至大部分的前端路由都是依赖于<a href="https://github.com/browserstate/history.js"><code>history.js</code></a>的，它是一个独立的第三方js库。可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。</p><ul><li>老浏览器的history: 通过<code>hash</code>来存储在不同状态下的<code>history</code>信息，对应<code>createHashHistory</code>，通过检测<code>location.hash</code>的值的变化，使用<code>location.replace</code>方法来实现url跳转。通过注册监听<code>window</code>对象上的<code>hashChange</code>事件来监听路由的变化，实现历史记录的回退。</li><li>高版本浏览器: 利用HTML5里面的history，对应<code>createBrowserHistory</code>, 使用包括<code>pushState</code>， <code>replaceState</code>方法来进行跳转。通过注册监听<code>window</code>对象上的<code>popstate</code>事件来监听路由的变化，实现历史记录的回退。</li><li>node环境下: 在内存中进行历史记录的存储，对应<code>createMemoryHistory</code>。直接在内存里<code>push</code>和<code>pop</code>状态。</li></ul></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><p>React Router包含了四个包:</p><table><thead><tr><th>包名</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router"><code>react-router</code></a></td><td>React Router核心api</td></tr><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom"><code>react-router-dom</code></a></td><td>React Router的DOM绑定，在浏览器中运行不需要额外安装<code>react-router</code></td></tr><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-native"><code>react-router-native</code></a></td><td><a href="https://facebook.github.io/react-native/">React Native</a> 中使用，而实际的应用中，其实不会使用这个。</td></tr><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-config"><code>react-router-config</code></a></td><td>静态路由的配置</td></tr></tbody></table><p><strong>主要使用:</strong><code>react-router-dom</code> </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom --save  <span class="comment">// 5.x的版本主要是针对React Hook做更好的支持</span></span><br></pre></td></tr></tbody></table></figure><p>直接按照<a href="https://reacttraining.com/react-router/web/guides/quick-start">官网</a>的demo就理解 路由的使用方式:</p><blockquote><p>HashRouter、BrowserRouter、Route、Link、exact、404页面处理、Switch、NavLink、params、link的属性（pathname、search、hash、state)、redirect、push、replace、withRouter、prompt</p></blockquote><p>HashRouter和BrowserRouter</p><ul><li>HashRouter:锚点链接</li><li>BrowserRouter:H5的新特性（history）如果上线之后，需要后台做一些处理:<strong>重定向处理404bug</strong></li></ul><h2 id="19-redux"><a href="#19-redux" class="headerlink" title="19. redux"></a>19. redux</h2><h3 id="传统MVC框架的缺陷"><a href="#传统MVC框架的缺陷" class="headerlink" title="传统MVC框架的缺陷"></a>传统MVC框架的缺陷</h3><p><strong>什么是MVC？</strong></p><p><img src="img/mvc-base.png"></p><p><code>MVC</code>的全名是<code>Model View Controller</code>，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。</p><p><code>V</code>即View视图是指用户看到并与之交互的界面。</p><p><code>M</code>即Model模型是管理数据 ，很多业务逻辑都在模型中完成。在MVC的三个部件中，模型拥有最多的处理任务。</p><p><code>C</code>即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p><p><strong>MVC只是看起来很美</strong></p><p>MVC框架的数据流很理想，请求先到Controller, 由Controller调用Model中的数据交给View进行渲染，但是在实际的项目中，又是允许Model和View直接通信的。然后就出现了这样的结果：</p><p><img src="img/defect-of-mvc.png"></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。</p><ul><li>代码结构 </li><li>组件之间的通信</li></ul><p>2013年 Facebook 提出了 Flux 架构的思想，引发了很多的实现。2015年，Redux 出现，将 Flux 与<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">函数式编程</a>结合一起，很短时间内就成为了最热门的前端架构。</p><p>如果你不知道是否需要 Redux，那就是不需要它</p><p>只有遇到 React 实在解决不了的问题，你才需要 Redux</p><p>简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。</p><ul><li>用户的使用方式非常简单</li><li>用户之间没有协作</li><li>不需要与服务器大量交互，也没有使用 WebSocket</li><li>视图层（View）只从单一来源获取数据</li></ul><p><strong>需要使用Redux的项目:</strong></p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p><strong>从组件层面考虑，什么样子的需要Redux：</strong></p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><p><strong>Redux的设计思想：</strong></p><ol><li>Web 应用是一个状态机，视图与状态是一一对应的。</li><li>所有的状态，保存在一个对象里面（唯一数据源）。</li></ol><blockquote><p>注意：flux、redux都不是必须和react搭配使用的，因为flux和redux是完整的架构，在学习react的时候，只是将react的组件作为redux中的视图层去使用了。</p></blockquote><p><strong>Redux的使用的三大原则：</strong></p><ul><li><p>Single Source of Truth(唯一的数据源)</p></li><li><p>State is read-only(状态是只读的)</p></li><li><p>Changes are made with pure function(数据的改变必须通过纯函数完成)</p><blockquote><p>什么是纯函数:</p><p>纯函数指的是 给定固定的输入就一定会有固定的输出，而且不会有任何副作用。</p><p>不固定的话像日期对象、ajax请求、异步操作就不是纯函数了</p><p>副作用是对接受的参数进行修改。我们可以复制一份修改复制的</p></blockquote></li></ul><h2 id="20-redux和react-redux区别"><a href="#20-redux和react-redux区别" class="headerlink" title="20. redux和react-redux区别"></a>20. redux和react-redux区别</h2><blockquote><p>redux:js的状态管理</p><p>react-redux:为了在react中方便实用redux</p></blockquote><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>教程:<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p><p><img src="img/3.jpeg"></p><ul><li><p>createStore:(创建store)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createStore} <span class="keyword">from</span> <span class="string">"redux"</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(Reducer)</span><br></pre></td></tr></tbody></table></figure></li><li><p>applyMiddleware:(处理中间件)</p><blockquote><p>一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</p><p>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span> <span class="comment">// 处理异步的中间件</span></span><br><span class="line"><span class="keyword">const</span>  store = createStore(Reducer, applyMiddleware(thunk)</span><br></pre></td></tr></tbody></table></figure><ul><li>引入react-thunk的异步操作（注意:异步一定要放在aciton操作)</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入react-thunk模块</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'react-thunk'</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,applyMiddleware(thunk))</span><br><span class="line"><span class="comment">// action里的异步操作 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function"><span class="params">num</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// 因为是一个对象就不用return</span></span><br><span class="line">      dispatch({</span><br><span class="line">        <span class="attr">type</span>: <span class="string">"DECREMENT"</span>,</span><br><span class="line">        num</span><br><span class="line">      });</span><br><span class="line">    }, <span class="number">1000</span>);</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意:定时器、网络请求、事件监听、在组件被销毁前都应得到相应的处理</p></li></ul><h3 id="实战Redux实现TodoList"><a href="#实战Redux实现TodoList" class="headerlink" title="实战Redux实现TodoList"></a>实战Redux实现TodoList</h3><ol><li>使用Antd搭建todoList</li><li>创建store</li><li>创建action和reducer实现添加功能</li><li>实现删除功能 </li><li>actionTypes的拆分</li><li>使用actionCreators拆分action</li><li>UI组件和容器组件</li><li>无状态组件</li><li>redux中使用异步</li><li>redux-thunk</li><li>redux-sage</li></ol><h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux:"></a>react-redux:</h3><p>注意版本问题:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"react"</span>: <span class="string">"^16.12.0"</span>,</span><br><span class="line"><span class="string">"react-dom"</span>: <span class="string">"^16.12.0"</span>,</span><br><span class="line"><span class="string">"react-redux"</span>: <span class="string">"^7.1.3"</span>,</span><br><span class="line"><span class="string">"react-scripts"</span>: <span class="string">"3.4.0"</span>,</span><br><span class="line"><span class="string">"redux"</span>: <span class="string">"^4.0.5"</span>,</span><br></pre></td></tr></tbody></table></figure><ul><li><p>Provider</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createStore} <span class="keyword">from</span> <span class="string">"redux"</span></span><br><span class="line"><span class="keyword">import</span> { Provider } <span class="keyword">from</span> <span class="string">"react-redux"</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">{</span> <span class="attr">store</span> }&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Children</span> /&gt;</span>   // 子组件就可以接受store到 但是还不能直接用 </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></tbody></table></figure></li><li><p>connect</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> { connect } <span class="keyword">from</span> <span class="string">"react-redux"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 连接高级组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispachToProps)(Children) </span><br></pre></td></tr></tbody></table></figure><ul><li><p>mapStateToProps（将state映射到 UI 组件的参数（props))</p><blockquote><p>mapStateToProps是一个函数,它的作用是建立一个从（外部的）state对象到（UI 组件的props对象的映射关系,传入connect中相当于立即执行,返回一个对象,里面的每一个键值对就是一个映射</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapStateToProps 可以传入两个参数state、ownProps（本组件的props）</span></span><br><span class="line"><span class="comment">// 第一个参数</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">todoList</span>: state.todoList</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第二个参数</span></span><br><span class="line"><span class="comment">//    &lt;FilterLink filter="All"&gt;</span></span><br><span class="line"><span class="comment">//      All</span></span><br><span class="line"><span class="comment">//    &lt;/FilterLink&gt;</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">active</span>: ownProps.filter === state.filter</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>mapDispachToProps（输出逻辑，即将用户对 UI 组件的操作映射成 Action。）</p><blockquote><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p></blockquote><ol><li><p>mapDispatchToProps为函数的用法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params"> dispatch, ownProps</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">          <span class="attr">onClick</span>: <span class="function">() =&gt;</span> {</span><br><span class="line">            dispatch({ <span class="comment">// action</span></span><br><span class="line">              <span class="attr">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">              <span class="attr">filter</span>: ownProps.filter</span><br><span class="line">            });</span><br><span class="line">          }</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>mapDispatchToProps为对象的用法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = {</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> {</span><br><span class="line">    <span class="attr">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">    <span class="attr">filter</span>: filter</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">import</span> {onClick} <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,{onClick})(App);</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ul></li><li><p>bindActionCreators:（作用是将一个或多个action和dispatch组合起来生成mapDispatchToProps需要生成的内容）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {increment,decrement}  <span class="keyword">from</span> <span class="string">"./actions"</span>;</span><br><span class="line"><span class="keyword">import</span> { bindActionCreators } <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">const</span> mapDispatchProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> {</span><br><span class="line">   <span class="comment">// 单个用法</span></span><br><span class="line">   <span class="comment">//return {</span></span><br><span class="line">      <span class="attr">increment</span>:bindActionCreators(increment,dispatch),</span><br><span class="line">      <span class="attr">decrement</span>:bindActionCreators(decrement,dispatch)</span><br><span class="line">  <span class="comment">// }</span></span><br><span class="line">  <span class="comment">// 多个用法</span></span><br><span class="line">  <span class="keyword">return</span> bindActionCreators({increment,decrement},dispatch)</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 注意：事件触发函数直接调用不用加() 假如要传递参数 事件要多加一层然后执行传入参数（参数）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>combineReducers:（合并多个reducer）</p><blockquote><p>reducer存放过多的数据 可能造成代码的不可维护 最好把reducer拆分</p><p>用redux内置的combinReducers函数进行拆分</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入函数</span></span><br><span class="line"><span class="keyword">import</span> { combineReducers } <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="comment">// 合并reducer</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers({</span><br><span class="line">  reducer1,</span><br><span class="line">  reducer2</span><br><span class="line">});</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer; <span class="comment">// 导出</span></span><br><span class="line"><span class="comment">// 传入state合并好的reducer</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"><span class="comment">// 在组件中调用reducer</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">counter</span>: state.reducer1,</span><br><span class="line">    <span class="attr">user</span>: state.reducer2</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="21-React-Hooks"><a href="#21-React-Hooks" class="headerlink" title="21. React Hooks"></a>21. React Hooks</h2><p>教程:<a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html?tdsourcetag=s_pctim_aiomsg">http://www.ruanyifeng.com/blog/2019/09/react-hooks.html?tdsourcetag=s_pctim_aiomsg</a></p><p><strong>什么是hooks:</strong></p><blockquote><p>​    React一直都提倡使用函数组件，但是有时候需要使用 state 或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有.</p><p>Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性.</p><p>如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks. 凡是 use 开头的 React API 都是 Hooks.</p></blockquote><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h3><p>  <code>useState</code>可以让我们在函数式组件中定义一个state和一个用来修改state的方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count状态、setCount修改状态、useState(默认值)</span></span><br><span class="line"><span class="keyword">let</span> [ count,setCount ] = useState( count的初始值 )</span><br></pre></td></tr></tbody></table></figure><h3 id="2-useContext"><a href="#2-useContext" class="headerlink" title="2. useContext"></a>2. useContext</h3><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。<br> 有部分小伙伴应该使用props属性进行组件向下传值的操作。当多个组件嵌套时候。你就需要慢慢向上寻找最初的值是什么</p><p><strong>React.createContext：</strong>创建一个上下文的容器(组件), defaultValue可以设置共享的默认数据</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {Provider, Consumer} = React.<span class="built_in">createContext</span>(defaultValue);</span><br></pre></td></tr></tbody></table></figure><p><strong>Provider(生产者)</strong>: 和它的名字一样。用于生产共享数据的地方。生产什么呢？ 那就看value定义的是什么了。value:放置共享的数据。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider <span class="keyword">value</span>={<span class="comment">/*共享的数据*/</span>}&gt;</span><br><span class="line">    <span class="comment">/*里面可以渲染对应的内容*/</span></span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>Consumer(消费者)</strong>:这个可以理解为消费者。 它是专门消费供应商(<strong>Provider</strong> 上面提到的)产生数据。Consumer需要嵌套在生产者下面。才能通过回调的方式拿到共享的数据源。当然也可以单独使用，那就只能消费到上文提到的defaultValue</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">  {<span class="keyword">value</span> =&gt; <span class="comment">/*根据上下文  进行渲染相应内容*/</span>}</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>useContext</strong></p><p>如果需要在组件之间共享状态，可以使用<code>useContext()</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> locale = useContext(LocaleContext);</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>useContext 的入参是某个 Provider 提供的 context，如果 context 发生变化的话，返回值也会立即发生变化。</p><h3 id="3-useReducer"><a href="#3-useReducer" class="headerlink" title="3. useReducer"></a>3. useReducer</h3><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p><p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是<code>(state, action) =&gt; newState</code>。</p><p><code>useReducers()</code>钩子用来引入 Reducer 功能。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></tbody></table></figure><p>上面是<code>useReducer()</code>的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的<code>dispatch</code>函数。</p><h3 id="4-useEffect"><a href="#4-useEffect" class="headerlink" title="4. useEffect"></a>4. useEffect</h3><p><code>Effect Hook</code>可以使得你在函数组件中执行一些带有副作用的方法。</p><blockquote><p>数据获取，设置订阅以及手动更改<code>React</code>组件中的<code>DOM</code>都是副作用的示例。无论你是否习惯于将这些操作称为“副作用”（或仅仅是“效果”），但你之前可能已经在组件中执行了这些操作。</p><p><strong>提示：</strong> 如果你熟悉<code>React</code>类生命周期方法，则可以将<code>useEffect Hook</code>视为<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的组合。</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()  =&gt;</span>  {</span><br><span class="line">  <span class="comment">// Async Action</span></span><br><span class="line">}, [dependencies])</span><br></pre></td></tr></tbody></table></figure><p><code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p><h3 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h3><p>React组件的构造函数在挂载之前被调用。</p><p>在实现<code>React.Component</code>构造函数时，需要先在添加其他内容前，调用<code>super(props)</code>，</p><p>用来将父组件传来的<code>props</code>绑定到这个类中，使用<code>this.props</code>将会得到。</p><p>官方建议不要在<code>constructor</code>引入任何具有副作用和订阅功能的代码，这些应当使用<code>componentDidMount()</code>。</p><p><code>constructor</code>中应当做些初始化的动作，如：初始化<code>state</code>，将事件处理函数绑定到类实例上，但也不要使用<code>setState()</code>。如果没有必要初始化state或绑定方法，则不需要构造<code>constructor</code>，或者把这个组件换成纯函数写法。</p><p>当然也可以利用<code>props</code>初始化<code>state</code>，在之后修改<code>state</code>不会对<code>props</code>造成任何修改，但仍然建议大家提升状态到父组件中，或使用<code>redux</code>统一进行状态管理。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> {</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">this</span>.state = {</span><br><span class="line">    <span class="attr">isBool</span>: props.isBool</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h3><p><code>getDerivedStateFromProps</code> 是react16.3之后新增，在组件实例化后，和接受新的<code>props</code>后被调用。他必须返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。</p><p>如果是由于父组件的<code>props</code>更改，所带来的重新渲染，也会触发此方法。</p><p>调用<code>setState()</code>不会触发<code>getDerivedStateFromProps()</code>。</p><p>之前这里都是使用<code>constructor</code>+<code>componentWillRecieveProps</code>完成相同的功能的</p><h3 id="componentWillMount-UNSAFE-componentWillMount"><a href="#componentWillMount-UNSAFE-componentWillMount" class="headerlink" title="componentWillMount() / UNSAFE_componentWillMount()"></a>componentWillMount() / UNSAFE_componentWillMount()</h3><p><code>componentWillMount()</code>将在React未来版本(官方说法 17.0)中被弃用。<code>UNSAFE_componentWillMount()</code>在组件挂载前被调用，在这个方法中调用<code>setState()</code>不会起作用，是由于他在<code>render()</code>前被调用。</p><p>为了避免副作用和其他的订阅，官方都建议使用<code>componentDidMount()</code>代替。这个方法是用于在服务器渲染上的唯一方法。这个方法因为是在渲染之前被调用，也是惟一一个可以直接同步修改state的地方。</p><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p>render()方法是必需的。当他被调用时，他将计算<code>this.props</code>和<code>this.state</code>，并返回以下一种类型：</p><ol><li>React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。&nbsp;</li><li>字符串或数字。他们将会以文本节点形式渲染到dom中。&nbsp;</li><li>Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。&nbsp;</li><li>null，什么也不渲染&nbsp;</li><li>布尔值。也是什么都不渲染。</li></ol><p><code>render()</code>方法必须是一个纯函数，他不应该改变<code>state</code>，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 </p><p>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>render()</code>不会被调用。</p><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p><code>componentDidMount</code>在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。</p><p><strong>通常在这里进行ajax请求</strong></p><p>如果要初始化第三方的dom库，也在这里进行初始化。只有到这里才能获取到真实的dom.</p><h3 id="componentWillReceiveProps-UNSAFE-componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-UNSAFE-componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)</h3><p>官方建议使用<code>getDerivedStateFromProps</code>函数代替<code>componentWillReceiveProps</code>。当组件挂载后，接收到新的<code>props</code>后会被调用。如果需要更新<code>state</code>来响应<code>props</code>的更改，则可以进行<code>this.props</code>和<code>nextProps</code>的比较，并在此方法中使用<code>this.setState()</code>。</p><p>如果父组件会让这个组件重新渲染，即使<code>props</code>没有改变，也会调用这个方法。</p><p>React不会在组件初始化props时调用这个方法。调用<code>this.setState</code>也不会触发。</p><h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>调用<code>shouldComponentUpdate</code>使React知道，组件的输出是否受<code>state</code>和<code>props</code>的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。</p><p>在渲染新的<code>props</code>或<code>state</code>前，<code>shouldComponentUpdate</code>会被调用。默认为<code>true</code>。这个方法不会在初始化时被调用，也不会在<code>forceUpdate()</code>时被调用。返回<code>false</code>不会阻止子组件在<code>state</code>更改时重新渲染。</p><p>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>componentWillUpdate</code>,<code>render</code>和<code>componentDidUpdate</code>不会被调用。</p><blockquote><p>官方并不建议在<code>shouldComponentUpdate()</code>中进行深度查询或使用<code>JSON.stringify()</code>，他效率非常低，并且损伤性能。</p></blockquote><h3 id="UNSAFE-componentWillUpdate-nextProps-nextState"><a href="#UNSAFE-componentWillUpdate-nextProps-nextState" class="headerlink" title="UNSAFE_componentWillUpdate(nextProps, nextState)"></a>UNSAFE_componentWillUpdate(nextProps, nextState)</h3><p>在渲染新的<code>state</code>或<code>props</code>时，<code>UNSAFE_componentWillUpdate</code>会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。</p><p>*不能在这里使用this.setState()*，也不能做会触发视图更新的操作。如果需要更新<code>state</code>或<code>props</code>，调用<code>getDerivedStateFromProps</code>。</p><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a>getSnapshotBeforeUpdate()</h3><p>在react <code>render()</code>后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。</p><h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h3><p>在更新发生后立即调用<code>componentDidUpdate()</code>。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。</p><p>如果组件实现<code>getSnapshotBeforeUpdate()</code>生命周期，则它返回的值将作为第三个“快照”参数传递给<code>componentDidUpdate()</code>。否则，这个参数是<code>undefined</code>。</p><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p>在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在<code>componentDidMount</code>中创建的任何监听。</p><h3 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a>componentDidCatch(error, info)</h3><p>错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。</p><p>如果类组件定义了此生命周期方法，则它将成错误边界。在它中调用<code>setState()</code>可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复; 不要试图将它们用于控制流程。</p><p>错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p><code>PureComponnet</code>里如果接收到的新属性或者是更改后的状态和原属性、原状态相同的话，就不会去重新render了<br>在里面也可以使用<code>shouldComponentUpdate</code>，而且。是否重新渲染以<code>shouldComponentUpdate</code>的返回值为最终的决定因素。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { PureComponent } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>{</span><br><span class="line">  ……</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不错的文章: <a href="https://www.jianshu.com/p/514fe21b9914">https://www.jianshu.com/p/514fe21b9914</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个时间吃不胖</title>
      <link href="2021/05/26/zgsjcbp/"/>
      <url>2021/05/26/zgsjcbp/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：『饮食时间』是瘦身的关键"><a href="#第一章：『饮食时间』是瘦身的关键" class="headerlink" title="第一章：『饮食时间』是瘦身的关键"></a>第一章：『饮食时间』是瘦身的关键</h1><h2 id="01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！"><a href="#01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！" class="headerlink" title="01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！"></a>01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！</h2><p>一听说穷只卷心菜的热量低，你就立刻订购，一旦是相交成的瘦身减肥的流行趋势，你就大量的购买香蕉，每天不停地吃。尽管试验了很多种减肥的方法，但都没能坚持长久，刚刚瘦了一点点，马上又反弹，简直就陷入无止境的反复中。</p><p>其实，你的这些努力反而正在故意的增肥呢。人体原本自身拥有一套系统，能够维持健壮而不肥胖的体质，如果违反了这套系统中的运行规律，将会在体内储存多余的脂肪。再加上不合理的减肥方法，长此以往将会变成易胖体质，这简直就是一种恶性循环。</p><p>那么在这里我有一个问题要问问你。</p><p>今天早上你吃早餐了吗？不会是一个星期有一半以上的时间都没吃早餐吧？</p><p>来自日本卫生部的数据显示，20<del>30岁，30</del>40岁的女性中，不吃早餐的人数比例呈现逐年上升的趋势。与20年前相比，不吃早餐或者只是简单吃点营养品和饮料来代替早餐的人数大幅度增加。特别是20~30岁的女性，不吃早餐的人数增加了一成以上。也就是大概四个人中就会有一个人没有认真吃早餐。</p><h3 id="遵循身体自身的生理规律就不会发胖"><a href="#遵循身体自身的生理规律就不会发胖" class="headerlink" title="遵循身体自身的生理规律就不会发胖"></a>遵循身体自身的生理规律就不会发胖</h3><p>早在上古时代，人类的身体自身就牢牢地记在了一定的生理规律清晨睁开双眼。真心开始了一天的劳作，从白天到傍晚，身体的活动量达到顶点，日落之后，慢慢的进入了休息状态，最后进入梦乡。只要遵循这种自然的生理规律，保持劳作与休息的平衡，那么从食物中获取的能量与劳动中消耗的能量也就能保持一种平衡的关系。</p><p>造成肥胖的原因可以理解为从食物中获取的能量没有被彻底的消耗掉，它们在体内形成脂肪后被储存起来。身体自身所记载的生理规律一旦遭到破坏，摄入的能量和消耗的能量就无法达到“收支平衡”，结果造成了肥胖。</p><p>把握身体生理规律的关键就是<strong>吃早餐</strong>。这一点请一定要牢记哦。</p><h3 id="晚上9点以后才开始吃晚餐的人要注意啦"><a href="#晚上9点以后才开始吃晚餐的人要注意啦" class="headerlink" title="晚上9点以后才开始吃晚餐的人要注意啦"></a>晚上9点以后才开始吃晚餐的人要注意啦</h3><p>同样是来自日本卫生部的数据，他们分别对吃早餐的人群和不吃早餐的人群的晚餐时间进行了调查，其结果显示：真正与后者相比，晚餐的时间相对较早。30-40岁的女性人群中，吃早餐的人大部分在晚上8点之前结束当日的晚餐。而在不吃早餐的人群中，有两成左右的人在晚上9点以后才吃晚餐。在20岁至30岁的女性人群中，这个比例占到三成左右。在10-50岁不吃早餐的男性人群中，有三层以上的人在晚上9点以后才吃晚餐。</p><p>对于工作或者娱乐的原因，不知不觉中回家的时间被向后拖延了，享用完姗姗来迟的晚餐之后，已是别接近晚上11点了。在整理一下随身的物品，洗澡，身体护理，写写博客等等，一晃也就到了凌晨一两点钟。像这样的事情早已司空见惯，这样以来，次日早晨早早的起床，好好的吃个早饭简直是不可能的。</p><p>不吃早餐→拖延晚餐时间→次日仍旧不吃早餐，这已经形成了一种恶性循环，身体自身的生理规律遭到了实质性的破坏，晚睡导致了晚起不吃早餐又造成了身体能量不充足，最后导致整个上午的活动量无法提升。并且由于饥饿感在午餐时间达到了顶点，所以午餐容易吃的过多。</p><p>拖延了晚餐时间，不仅仅打破了身体自身的生理规律，同时也成为导致肥胖的直接原因。<strong>晚餐时间与就寝时间相隔太近的话，即使身体吸收的营养转化为能量了，也没有时间再去把它消耗掉</strong>。无家可归的能量被脂肪细胞所接收，从而形成的脂肪贮存在了人体的内部。</p><p>不仅如此，与就寝时间无关，单单是晚餐时间被拖延也会导致体内脂肪的堆积，后面我会对此再进行详细的说明。即便是同样的菜单，同样热量的晚餐越早食用越不容易发胖。</p><p>自己肯定不是一个很能吃的人，可是稍不留神立刻就会变胖，更何况自己平时就是一个很注意热量摄入值的人，对油腻的食物或者甜品的摄入都很节制，然而还是瘦不下来。如果你觉得自己属于这样的人群，那么就要请你回想一下，这个星期每天都是几点吃的晚餐呢？</p><h3 id="轮班工作者容易发胖，原因是什么呢？"><a href="#轮班工作者容易发胖，原因是什么呢？" class="headerlink" title="轮班工作者容易发胖，原因是什么呢？"></a>轮班工作者容易发胖，原因是什么呢？</h3><p>最后是等昼夜交替的轮班工作者和仅在白天工作的人的肥胖指数进行了调查和对比。我们得到一个耐人寻味的数据结果。以身高和体重比例计算得出的肥胖指数BMI（Body Mass Index）中19~22表示标准体重，25以上认定为肥胖。 将调查数据进行比较之后，我们看到轮班工作者的BMI达到26以上的比例是仅在白天工作的人的比例的五倍以上。通过这个数据，基本上证明了<strong>昼夜颠倒且不规律的作息时间增加了，成为肥胖体质的概率</strong>。</p><p>作息时间的变化,当然不仅仅是轮班制工作者所独有的问题，日本NHK电视台曾经作过的一项调查结果显示，夜间11点就请的人数从1970年占日本人口的70%~2005年占40%左右，比例大幅下降。就请时间向后拖延，对就餐时间也产生了影响，使得身体自身的生理规律遭到破坏，变得容易发胖。</p><p>记载人体每天的生理规律的载体，我们称之为生物钟。它并不是用来让人们知晓时间的，而是具有自主的记载一定的生育规律并督促细胞按时进行活动的作用。同时，生物钟也发挥着调节各种激素分泌量的作用。因此，即便是在没有时钟的环境下，也可以与平时一样，在相同的时间睡觉，在相同的时间起床。</p><h3 id="身体的时差反应导致人体容易发胖"><a href="#身体的时差反应导致人体容易发胖" class="headerlink" title="身体的时差反应导致人体容易发胖"></a>身体的时差反应导致人体容易发胖</h3><p>生物钟在正常运转的情况下，各种蛋白质就会向细胞传达讯息，使得人那样代谢得到提升，并在运动中形成必要的肌肉，大脑活动也就被进一步激活。这种运转机制已经在近期的研究中得到了证实。燃鹅，如果生物中所记载的生理规律错乱的话，就会导致与上述情况相反的结果。身体代谢变缓，体力下降，思维混乱，简直就像陷入了时差反应的状态。</p><p>拖延晚餐且不吃早餐的生活方式迫使身体全年处于倒时差的状态之中，因此无论怎么控制摄入体内的热量，都很难达到减肥的效果。实际上肥胖的原因与其在于说“吃什么”，还不如说在于“什么时间吃”。</p><h2 id="02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。"><a href="#02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。" class="headerlink" title="02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。"></a>02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。</h2><p>睡眠、觉醒等这些被人体生物钟牢牢记载的生理规律被称为“昼夜节律”。“昼夜节律”于拉丁语表示大约一天的意思。如果以一天为单位来看，身体状态不断上升，逐渐达到顶点，然后慢慢下降。一切身体活动都是受生物钟所记载的昼夜节律所控制的，例如体温在下午3点左右达到最高值，运动能力，肺活量等在傍晚时分能达到顶点。</p><p>人体为什么需要这种生理规律呢？我们认为这是人体为了适应由地球自转引起的生活环境变化而形成的规律。昼夜节律就是生物题与地球自转同步的生理规律。生物钟是人体为了适应环境而保留下来的财富，是生物自身逐步进化得到的运转系统。</p><p>如果你的生活习惯与这种生理规律背道而驰，就会使身体产生各种不适。人体的肥胖现象就是这类不适反应的一种。</p><h3 id="生物中遗传因子掌握着开启生物钟的钥匙"><a href="#生物中遗传因子掌握着开启生物钟的钥匙" class="headerlink" title="生物中遗传因子掌握着开启生物钟的钥匙"></a>生物中遗传因子掌握着开启生物钟的钥匙</h3><p>生物钟系统在各个领域都备受瞩目，特别是生物钟与饮食的关系。已经逐步成为一门学问，被称为“时间营养学”。其在饮食教育、预防医学，健康科学等众多领域都被广泛研究。</p><p>给大家介绍一下生物钟是怎样运转的吧。</p><p>大约在十年前，人类发现了一种蛋白物质，称之为“生物中遗传因子”，经研究发现，它在人体内发挥着推动生物钟运转的作用，大脑视神经交叉的地方，也就是在被称为“视交叉上核”的部位上存在着主要生物中遗传因子。主要生物中遗传因子自主地记载着以大约25小时为周期的昼夜节律，从早晨起床时睁开眼睛，接受到第一缕阳光的讯息，开始自动地与地球自转的24小时周期相结合。人体每日沐浴阳光，并由此来调整每一天的体内生物钟。如果长期在黑暗中生活的话，主要生物中遗传因子就会一直按照25小时的周期来不断运转。人体的生理规律相对于地球的自转周期就会一直向后推延。</p><p>此外，在末梢部位也存在着生物中遗传因子，同时存在于肝脏，心脏，肾脏，肺，肌肉等人体的各个部位，分别记载着各自的生理规律，并且并不是光线在调节这些生物中因子，而是人们平时的饮食。早晨起床后一个小时内吃早餐可以调整末梢部位的生物中遗传因子，使其主要的生物中遗传因子同步。  </p><p>全身的生物中遗传因子如果得不到很好的调整，就会各自随意的运转，例如大脑已经清醒而身体还在沉睡之中，所以吃早餐是调节人体生理规律所不可缺少的一项。</p><h3 id="吃早餐会使代谢能力自动增强"><a href="#吃早餐会使代谢能力自动增强" class="headerlink" title="吃早餐会使代谢能力自动增强"></a>吃早餐会使代谢能力自动增强</h3><p>由于食物的刺激，末梢部位的生物中遗传因子一旦开始计算时间，就会增加体内的某种蛋白质，这种蛋白质能够增加用来消耗能量的细胞中的小器官——线粒体，使其促进肌肉合成。它是一种能够提高代谢效率的重要蛋白质。并且，不是白天，也不是夜晚，而是早餐的刺激才能激活起自身的作用。</p><p>也就是说，不吃早餐就不能调节末梢部位的生物中遗传因子，因此身体代谢效率下降，逐渐变成了容易肥胖的体质。</p><h3 id="蛋白质的增减调节着生物钟的节奏"><a href="#蛋白质的增减调节着生物钟的节奏" class="headerlink" title="蛋白质的增减调节着生物钟的节奏"></a>蛋白质的增减调节着生物钟的节奏</h3><p>让我们更加详细的看一下生物中遗传因子的运转机制吧。</p><p>大脑的视交叉上核里存在的主要生物中遗传因子里存在着Clock蛋白和Bmall蛋白，然后产生叫做Per蛋白和Cry蛋白的物质。而实际上Per蛋白和Cry蛋白又是妨碍Clock蛋白和Bmal;蛋白运转的物质。</p><p>Per蛋白和Cry蛋白的增加会削弱Clock蛋白和Bmall的蛋白的作用，这种削弱同时也会使per蛋白和Cry蛋白的含量减少。Bmall蛋白和Clock蛋白又被再次激活。这样看来，他们的运转机制就像拔河运动一样。在这些物质中，描绘增减曲线的主要物质是Bmall蛋白。据研究发现，这种物质能够起到促进脂肪合成的作用，在下午2点~4点这个时间段数量最少，而在夜间的10点到第二天凌晨的两点，这个时间段的数量急剧增加，<strong>所以夜间用餐很容易发胖也是这个原因。</strong></p><h2 id="03、生物钟瘦身法则：早起——所有减肥方法的基础"><a href="#03、生物钟瘦身法则：早起——所有减肥方法的基础" class="headerlink" title="03、生物钟瘦身法则：早起——所有减肥方法的基础"></a>03、生物钟瘦身法则：早起——所有减肥方法的基础</h2><p>之前已经对人体生物钟和生物中遗传因子做了一个简单的介绍。</p><p>为了能够锻炼成不容易变胖体质，我们应该怎么做呢？</p><p>首先就是要做到早起。早起的目的是为了让清晨的光线激活大脑里主要生物中遗传因子。主要生物中遗传因子就像是人体全身的生物中遗传因子的指挥官。各自肩负着向记载着生理规律的末梢部位的生物中遗传因子传递“清晨已经来临”这一信息的职责。所以<strong>消除时差反应最有效的方法就是——沐浴阳光</strong>。</p><p>在治疗失眠的临床研究中也有使用发光二极管的光治疗方法，这也是为了让主要生物中遗传因子开始工作时其能够恢复正常的昼夜节律。</p><p>能够使主要生物中遗传因子正常工作的物质就是清晨的阳光。首先需要让“指挥官”苏醒，然后用一天的时间来指挥身体的这个大型“交响乐团”。因此，让身体有一个良好的开始是非常重要的。如果能够与日出同时出发享受第一缕阳光的话，那是非常理想的状态。当然，不出房门仅仅是在屋子里感受阳光也是可以的，但随着地球的自转，尽可能的早起。感受阳光的沐浴，无论是天气好坏，阳光每天会依旧普照大地，无论是阴天还是雨雪天，阳光对人体产生的效果是一样的。</p><p>昼夜颠倒的轮班制工作者容易变得肥胖，这已经是不产自明的事情了。追踪生活不规律的学生得到的调查结果显示，人体在上午的活动量非常少，而且代谢效率也很低。这都是因为他们没有好好的接受大自然给人类的恩惠——阳光。尽管多数人都是在白天工作的上班族，但也有很多人通勤时间是相对自由的弹性工作制，尤其到了休息日，从工作日的疲劳奔波状态突然过渡到一觉睡到日上三竿的懒散生活如果每天坚持规律地生活在固定的时间起床，那么就很难造成体内的生物钟混乱，并且早晨的时间也会变得很充裕。从而养成每天吃早饭的好习惯，这也是早起的一大优点。</p><h3 id="认真吃早餐是瘦身的秘诀"><a href="#认真吃早餐是瘦身的秘诀" class="headerlink" title="认真吃早餐是瘦身的秘诀"></a>认真吃早餐是瘦身的秘诀</h3><p>吃早餐是瘦身的另一款则包括肝脏在内的全身生物中遗传因子就可以完全的与主要生物中遗传因子进行同步。并且起床后一小时以内吃早餐是调整体内生物钟生理规律的条件。不吃早餐的日子，人体的大脑和身体的生物钟各自运转不相协调。身体虽然开始活动了，但是大脑还没有完全的清醒。</p><p>日本的教育部门针对全国10万人进行了学历测试，其结果显示，每天吃早餐的学生比不吃早餐的学生的成绩要高出20%。吃早餐的学生，每一门功课的学习成绩都比不吃早餐的学生优秀20%。足以可见吃早餐的重要性。</p><p>有些人认为如果不吃饭的话，至少能够减少这一顿饭的热量，这简直是大错特错。与之相反，大脑没有充分的运转起来，反而容易陷入更加肥胖的状态。</p><p>所谓的早餐，不仅仅只是随便喝点饮料或者是营养品就草草了事的，而是尽可能的做到主食主菜，副菜样样俱全。生物钟瘦身法的饮食关键也是由此开始的。</p><p>我们之前已经提到过，构成主要生物中遗传因子的Bmall蛋白是促进脂肪合成的主要物质。Bmall单倍的数量在白天相对减少，在夜间相对增加。所以需要很好的利用这一特点。为了防止晚餐吃的过多，可以尽量的在白天多吃一些。因为在白天，Bmall蛋白不会起作用，所以尽管多吃了一些，也几乎没有脂肪增长的风险。而且晚餐最晚在晚上9点之前想用尽量摄取脂肪含量少的食品，这也是最基本的方法。</p><h3 id="以适度的运动来支撑生物钟的运转"><a href="#以适度的运动来支撑生物钟的运转" class="headerlink" title="以适度的运动来支撑生物钟的运转"></a>以适度的运动来支撑生物钟的运转</h3><p>早睡、早起、吃早餐是生物钟瘦身法的三大支柱。遵循这三大法则可以得到不容易变胖的体质，为了提高人体体内生物钟的调节作用，提高人体代谢效率，进一步达到减肥的效果。我在向大家推荐一套运动瘦身法。</p><p>从人体生物中所记载的生理规律的角度来看，<strong>一天中最适合运动的时间段是傍晚的6点左右。是身体各种机能都达到顶点的黄金时间</strong>。研究表明，在这个时段运动能够更多的分泌促进脂肪代谢的甲状腺刺激激素以及增长肌肉，修复身体组织的成长技术，并且通过运动可以更好的处理体内产生的疲劳物质。如果是同样强度的运动，与早晨相比范围运动的效率相对更高。</p><h3 id="运动得到高质量的睡眠"><a href="#运动得到高质量的睡眠" class="headerlink" title="运动得到高质量的睡眠"></a>运动得到高质量的睡眠</h3><p>并不是说其他时间段的运动就没有意义，如果将能够燃烧脂肪的轻度有氧运动通过刺激肌肉来防止代谢效率下降的简单肌肉训练，提高睡眠质量的睡前伸展运动等多种运动结合起来的话，减肥的效果将是非常显著的。</p><p>运动还发挥着调整自身神经的交感神经与副交感神经之间的平衡作用。白天促进人体活动的交感神经被激活一晚，让人体进入休息状态的副交感神经占到上风，这也是人体生物钟的生理规律之一。但是人如果一直是持续加班吃宵夜、夜猫子的生活方式，要把神经就会一直处于兴奋状态，身体始终无法进入休息状态，所以人也得不到高质量的睡眠。</p><p>交感神经被激活起到主要作用，而运动结束后，副交感神经就会开始进入工作状态。从这个意义上来讲，<strong>傍晚以后的身体运动也是非常重要</strong>的。</p><h3 id="生物钟瘦身法和七个小贴士"><a href="#生物钟瘦身法和七个小贴士" class="headerlink" title="生物钟瘦身法和七个小贴士"></a>生物钟瘦身法和七个小贴士</h3><ol><li>尽量早起沐浴清晨的阳光。</li><li>早餐必须要吃，并且要吃好。</li><li>午餐可以多吃，就算把肚子吃的鼓鼓的也完全OK。</li><li>晚餐要在8点之前吃完。</li><li>晚餐要特别注意摄入低脂肪的食物。</li><li>为了第二天早上能够起来保持头脑清醒，千万不要持续熬夜。</li></ol><p>这样看来，这七条规则都是大家所熟知的基本方法，没有一项是新鲜的，但是如果你最近感觉变得特别容易发胖，说不定就是因为你没有把握住最基本最理所当然的事情。生物中所记载的生理规律去生活的话，我们就不会再为肥胖问题而烦恼了。</p><p>在当今这种快节奏的生活环境里，你可能会认为做到以上几点是非常困难的，而实际上这种正确的生活方式绝对不是你想象的那样遥不可及。一旦养成早起和吃早饭的习惯，你就已经站在了正确的队伍之中。人体内混乱的生物钟得到再一次正确的调整，几天内都会按照正确的生物钟进行运转。</p><p>刚开始的时候，每星期只坚持两至三天也是可以的，比平时早起30分钟努力把早饭吃好，那么你体内的生物钟就会与地球自转相适应，生活节奏也会大有改善，毕竟人体体内本来就拥有一种防止身体发胖的系统。我们应该好好的利用他，努力改正导致肥胖的坏习惯。让我们一起来倾听记载着人体生理规律的生物钟所发出悦耳的滴答声吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 减肥 </tag>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是第8033天的打卡</title>
      <link href="2021/05/22/%E8%BF%99%E6%98%AF%E7%AC%AC8033%E5%A4%A9%E7%9A%84%E6%89%93%E5%8D%A1/"/>
      <url>2021/05/22/%E8%BF%99%E6%98%AF%E7%AC%AC8033%E5%A4%A9%E7%9A%84%E6%89%93%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<img src="https://i.loli.net/2021/05/21/hPnIejsKBOvZMlV.jpg" style="zoom:33%;overflow:hidden"><p>四季交替，日转星移。迈奇依旧唱歌，烛光依旧闪耀。有的人成为了大佬，有的人考上了研究生。大家都奔赴于理想之途，与无边的寂寞相伴，沐浴不同的阳光，也淋着冷漠的雨，只是大家都探寻到了各自奔波的意义，而我还是那个菜鸡。当我发现又过了一年，当我突然领悟歌词的意义…人生啊，第8033天打卡。</p><p>祝自己第22岁生日快乐……</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/22/hello-world/"/>
      <url>2021/05/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>教资中学科目一作文练手《以奋斗创造未来》</title>
      <link href="2021/03/10/zuowen/"/>
      <url>2021/03/10/zuowen/</url>
      
        <content type="html"><![CDATA[<h2 id="考题内容"><a href="#考题内容" class="headerlink" title="考题内容"></a>考题内容</h2><p>阅读下面的材料，按要求写作文。</p><h3 id="【材料一】"><a href="#【材料一】" class="headerlink" title="【材料一】"></a>【材料一】</h3><p>“人的一生应当这样度过，当他回首往事时，不因虚度年华而悔恨，也不因碌碌无为而羞耻……”《钢铁是怎样炼成的》主角保尔·柯察金以其钢铁般的意志和为理想而奋斗的精神，激励了一代代青年投身社会主义建设。</p><h3 id="【材料二】"><a href="#【材料二】" class="headerlink" title="【材料二】"></a>【材料二】</h3><p>“生活不能等待别人来安排，要自己去争取与奋斗！”，《平凡的世界》里的农村青年——孙少平，在苦难面前咬牙坚持，积极抗争，让一代代人从中获得精神的力量，增添了克服困难的勇气。</p><h3 id="写作要求"><a href="#写作要求" class="headerlink" title="写作要求"></a>写作要求</h3><p>1、综合上述材料所引发的思考和感悟，写一篇论说文。</p><p>2、用规范的现代汉语写作，角度自选，立意自定，题目自拟。</p><p>【字数要求】小学800字，中学1000字。</p><hr><h2 id="练手作文详情"><a href="#练手作文详情" class="headerlink" title="练手作文详情"></a>练手作文详情</h2><h3 id="《奋斗创造未来-》作者：chenlx"><a href="#《奋斗创造未来-》作者：chenlx" class="headerlink" title="《奋斗创造未来 》作者：chenlx"></a>《奋斗创造未来 》作者：chenlx</h3><p>古话说“少壮不努力，老大徒伤悲”，“长风破浪会有时，直挂云帆济沧海”。“奋斗”二字，从古至今都有文学写着关于这个词的描绘。对于我们来说，什么才是奋斗呢？ </p><p>奋斗，是一场考试前她的奋笔疾书认真备考，放榜时看到成绩的洋溢着喜悦的笑脸；奋斗，是农民在田野里辛勤地劳作挥洒着汗水，在火红的秋日里丰收时那捧在怀里的稻香；奋斗，是新中国成立后，先辈们通过艰苦拼搏反复尝试，后人们接力共同打造出如今的世界第二大经济体，让百姓可以安居乐业的生活。 </p><p>为什么需要依靠奋斗来创造未来？我们所渴望、所期待的未来生活多姿多样。我们畅想着，在未来，我们不用害怕路上的危险，不用担心敌人的欺凌，不用担心吃不饱穿不暖，不用担心不能在知识的汪洋里遨游。但这一切离不开实力，离不开通过奋斗积累出的实力。</p><p>在西汉年代，有一位特别有学问的人名叫匡衡。可匡衡小时候非常的贫穷，家里连根照明的蜡烛都买不起。但匡衡为了在夜里也可以读书，他得知隔壁人家有光后，便在墙上凿了一个洞，以此偷光读书。后来，匡衡的这个举动感动了他的邻居。后来在大家的帮助下，小少年匡衡终于学有所成。在汉元帝时期，匡衡也被封为了郎中。 </p><p>奋斗的故事在我们现代同样随处可见。2020 年，伴随着我国的北斗定位系统完成了最后一颗卫星的发射，至此，我国终于拥有了自己的全球定位系统。可是这一切，得来的并不容易。</p><p>在我们国家的科学家研发北斗系统之初，我们什么核心技术都没有掌握。在这个几乎等同于从零开始的情况之下，科学家们还必须在规定的时间之前先行发射一颗卫星上去使用定位系统的频段号，否则，国际组织就不承认这个频段号归属北斗所用。算法、硬件、原子钟…… 科学家们在有限的时间里艰苦奋斗，克服重重困难，终于发射出了中国的第一颗北斗。在往后的日子里，科学家们日以夜继，终于在去年完成了北斗系统的组网并成功投入使用。感动中国栏目中组曾这样评价道：“当第五十五颗吉星升上太空，北斗，照亮了中国人的梦”。 所以，美好的未来需要靠我们去努力奋斗。我们不必一口气再造出个北斗，也没有必要 凿光读书。在我们的生活中，每一件事情都值得去奋斗。我们可以勤加锻炼身体，保证奋斗 的基本；认真复习，迎接每一场考试。或者我们可以团结协作，夺得一份荣誉，也可以当志愿者服务百姓，为美好社会献上一份自己的力量。 需要奋斗的事情有很多很多，奋斗的方式也多种多样。奋斗的时间或许有长有短，但一定能通过自己的努力奋斗出满意的结果，创造出自己期望的美好的未来！</p><hr><h2 id="作文点评"><a href="#作文点评" class="headerlink" title="作文点评"></a>作文点评</h2><h3 id="预估分数：39"><a href="#预估分数：39" class="headerlink" title="预估分数：39"></a>预估分数：<strong>39</strong></h3><h3 id="写作亮点"><a href="#写作亮点" class="headerlink" title="写作亮点"></a>写作亮点</h3><ol><li>本文立意清楚，开头结合诗词直接引出立意，首尾呼应。</li><li>结构上层层递进，结合例子，流畅有力。</li></ol><h3 id="写作不足"><a href="#写作不足" class="headerlink" title="写作不足"></a>写作不足</h3><ol><li>不知道是不是电脑显示问题，文章分了8段，段落有些多，基本在4-6就可以了，一般5段最为完美，太多分 段会感觉很分散，可以开头-奋斗是什么-为什么奋斗-怎么去奋斗-结尾分为这五段。</li><li>怎样奋斗可以运用排比句的方式，①奋斗是勤加锻炼身体，奋斗是读书储备知识，奋斗是为社会做贡献， 奋斗可以是任何一件小事，奋斗努力的过程，就是小事迸发出最大的力量的过程。</li><li>结尾可以联系下材料，②奋斗是匡衡、北斗、、、然后加上原文需要到未来这部分会更好。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 作文 </tag>
            
            <tag> 教师资格证 </tag>
            
            <tag> 科目一 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boot链接neo4j遇到的一些报错知识库</title>
      <link href="2021/03/01/boot%E9%93%BE%E6%8E%A5neo4j%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
      <url>2021/03/01/boot%E9%93%BE%E6%8E%A5neo4j%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>org.springframework.data.mapping.MappingException: Error mapping Record</p><p>Caused by: org.springframework.dao.TypeMismatchDataAccessException: Could not convert “” into java.util.List&lt;java.lang.String&gt;; nested exception is org.neo4j.driver.exceptions.value.NotMultiValued: STRING is not iterable</p><p>Caused by: org.neo4j.driver.exceptions.value.NotMultiValued: STRING is not iterable</p><p>解决办法：将该字段类型改成Object即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月25日数据指标项目会议记录</title>
      <link href="2021/02/25/0225%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/25/0225%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>1104监管标准制定（计划3月份开始）</p><p>围绕分析数据标准的流程 方法 机制（主要介绍模板）</p><p>专题优先（e.g 客户 、风险）</p><h2 id="分析数据标准的框架"><a href="#分析数据标准的框架" class="headerlink" title="分析数据标准的框架"></a>分析数据标准的框架</h2><h3 id="框架源自于哪里？"><a href="#框架源自于哪里？" class="headerlink" title="框架源自于哪里？"></a>框架源自于哪里？</h3><p>最初的原型是毕马威，细分（二级）是国际金融体系</p><h3 id="现在要做的1104数据标准在框架里对应的是监管合规吗？"><a href="#现在要做的1104数据标准在框架里对应的是监管合规吗？" class="headerlink" title="现在要做的1104数据标准在框架里对应的是监管合规吗？"></a>现在要做的1104数据标准在框架里对应的是监管合规吗？</h3><h3 id="特殊、通用由谁判断"><a href="#特殊、通用由谁判断" class="headerlink" title="特殊、通用由谁判断"></a>特殊、通用由谁判断</h3><p>分析的时候进行判断。分类框架不是纠结与口径的问题，。为什么单独列出来监管合规，是因为与行里不一样（比较特殊）。指标之间是有关系的。</p><h3 id="运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）"><a href="#运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）" class="headerlink" title="运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）"></a>运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）</h3><p>包含渠道、流程的专题，面向客户、财务分析、（来源于毕马威）</p><p>银行业务 六大类。</p><p>信息管理要单列：</p><p>分类方向不能用专题来分。银行业务四个字有点模糊（所有的东西都算是银行业务、概念太泛）</p><h3 id="毕马威提的银行业务吗、绩效指标放哪里"><a href="#毕马威提的银行业务吗、绩效指标放哪里" class="headerlink" title="毕马威提的银行业务吗、绩效指标放哪里"></a>毕马威提的银行业务吗、绩效指标放哪里</h3><p>不是。提的是业务规模。理论上这个框架跟报告上的框架要么统一，要么</p><h3 id="信息管理要不要单列-有没有那么重要？里面其实指标不多"><a href="#信息管理要不要单列-有没有那么重要？里面其实指标不多" class="headerlink" title="信息管理要不要单列 有没有那么重要？里面其实指标不多"></a>信息管理要不要单列 有没有那么重要？里面其实指标不多</h3><p>系统运维、数据质量指标。<strong>理论上可以放到运维管理</strong>。信息管理可以合并到运营管理。系统运行关注点可能在生产运维。我们要关注偏业务层面的事物。</p><h3 id="资产负债其实是一个很重要的大的专题"><a href="#资产负债其实是一个很重要的大的专题" class="headerlink" title="资产负债其实是一个很重要的大的专题"></a>资产负债其实是一个很重要的大的专题</h3><p>其实可以单列出来。资产负债理论上是讲流动性的事务，资产负债管理是银行非常重要的数据方向。在以前的报告就提现的是。建议信息管理的模块替换或合并成资产负债。</p><p>银行业务原来叫业务规模，原来放在财务绩效（面向部门不是个人的KPI）。建议照样保留业务规模，与财务分析天然就有关联。如果指标过多，可以当成两个专题。</p><p>CRM只涵盖营销部分。</p><h3 id="客户管理客户关系管理的区别是什么。"><a href="#客户管理客户关系管理的区别是什么。" class="headerlink" title="客户管理客户关系管理的区别是什么。"></a>客户管理客户关系管理的区别是什么。</h3><p>认为是一样的。客户管理包括关系管理。分析标准上谈论的客户管理其实就是客户关系管理。加上目前的名称都是4个字，所以干脆就叫客户管理。（叫CRM是想体现银行跟客户的关系）</p><h3 id="监管合规包含运营管理吗"><a href="#监管合规包含运营管理吗" class="headerlink" title="监管合规包含运营管理吗"></a>监管合规包含运营管理吗</h3><p>后面一定会碰到这个的情况的。</p><p>为什么是单列而不是在某个具体的指标进行展开。</p><h3 id="在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。"><a href="#在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。" class="headerlink" title="在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。"></a>在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。</h3><h3 id="在分析数据标准的属性框架图中，业务需要重点关注的点是？"><a href="#在分析数据标准的属性框架图中，业务需要重点关注的点是？" class="headerlink" title="在分析数据标准的属性框架图中，业务需要重点关注的点是？"></a>在分析数据标准的属性框架图中，业务需要重点关注的点是？</h3><p>手工指标建议改成数据元。</p><h3 id="编号后续再继续详细讨论，要保证编码的稳定性"><a href="#编号后续再继续详细讨论，要保证编码的稳定性" class="headerlink" title="编号后续再继续详细讨论，要保证编码的稳定性"></a>编号后续再继续详细讨论，要保证编码的稳定性</h3><h1 id="Excel模板（工作底稿）"><a href="#Excel模板（工作底稿）" class="headerlink" title="Excel模板（工作底稿）"></a>Excel模板（工作底稿）</h1><h3 id="模板的必填项要设置。"><a href="#模板的必填项要设置。" class="headerlink" title="模板的必填项要设置。"></a>模板的必填项要设置。</h3><h3 id="如果有多个部门共同制定的一个指标，这个场景应该怎么处理。"><a href="#如果有多个部门共同制定的一个指标，这个场景应该怎么处理。" class="headerlink" title="如果有多个部门共同制定的一个指标，这个场景应该怎么处理。"></a>如果有多个部门共同制定的一个指标，这个场景应该怎么处理。</h3><p>先按报表主责、或者按部门占比认责。</p><h3 id="如果指标要调整，但是没有主责方，执行层面上应该怎么处理。"><a href="#如果指标要调整，但是没有主责方，执行层面上应该怎么处理。" class="headerlink" title="如果指标要调整，但是没有主责方，执行层面上应该怎么处理。"></a>如果指标要调整，但是没有主责方，执行层面上应该怎么处理。</h3><p>没人负责的情况下，由上一级排版仲裁（数据治理委员会等）</p><h3 id="拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则"><a href="#拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则" class="headerlink" title="拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则"></a>拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则</h3><h2 id="类名实例PPT"><a href="#类名实例PPT" class="headerlink" title="类名实例PPT"></a>类名实例PPT</h2><h3 id="什么叫类？从哪里来的？"><a href="#什么叫类？从哪里来的？" class="headerlink" title="什么叫类？从哪里来的？"></a>什么叫类？从哪里来的？</h3><h3 id="维度不同"><a href="#维度不同" class="headerlink" title="维度不同"></a>维度不同</h3><p>不同角度（维度）进行计算，但是计算结果是一样的。</p><p>从业务层面讲，是一个东西。但从计算角度来讲，计算方式不一样（口径）</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 会议记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
