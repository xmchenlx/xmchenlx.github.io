<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React学习笔记</title>
      <link href="2021/05/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/05/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-React简介"><a href="#1-React简介" class="headerlink" title="1. React简介"></a>1. React简介</h2><blockquote><p>轻量级的视图层<strong>库</strong>！<em>A JavaScript library for building user interfaces</em></p><p>React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；React 主要用于构建UI，可以简单地理解为React 将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。</p></blockquote><h3 id="1-1-组件化"><a href="#1-1-组件化" class="headerlink" title="1.1 组件化"></a>1.1 组件化</h3><ol><li><p><strong>什么是模块化：</strong>是从<strong>代码</strong>的角度来进行分析的；把一些可复用的代码，抽离为单个的模块；便于项目的维护和开发；</p></li><li><p><strong>什么是组件化：</strong> 是从 <strong>UI 界面</strong>的角度 来进行分析的；把一些可复用的UI元素，抽离为单独的组件；便于项目的维护和开发；</p><p><strong>组件化的好处：</strong>随着项目规模的增大，手里的组件越来越多；很方便就能把现有的组件，拼接为一个完整的页面；</p></li><li><p><strong>Vue是如何实现组件化的：</strong> 通过 <code>.vue</code> 文件，来创建对应的组件；</p><ul><li>template  结构</li><li>script        行为</li><li>style          样式</li></ul></li></ol><ol start="5"><li><strong>React如何实现组件化</strong>：大家注意，React中有组件化的概念，但是，并没有像vue这样的组件模板文件；React中，一切都是以js来表现的</li></ol><h3 id="1-2-移动APP"><a href="#1-2-移动APP" class="headerlink" title="1.2 移动APP"></a>1.2 移动APP</h3><ul><li>Vue，结合 Weex 实现移动端App开发</li><li>React，结合 ReactNative 实现移动端App开发</li></ul><h2 id="2-React的虚拟DOM"><a href="#2-React的虚拟DOM" class="headerlink" title="2. React的虚拟DOM"></a>2. React的虚拟DOM</h2><ul><li><p><strong>真实DOM：</strong>是浏览器中的概念是用JS对象来表示页面上的元素，并提供了操作 DOM 对象的API。</p></li><li><p><strong>虚拟DOM</strong>：是框架中的概念是用JS对象来模拟页面上的 DOM 和 DOM嵌套。</p><p><strong>本质：</strong> 用JS对象，来模拟DOM元素和嵌套关系</p><p><strong>目的：</strong> 就是为了实现页面元素的高效更新</p></li><li><p>React 高性能</p></li></ul><ul><li>React Fiber</li></ul><h2 id="3-React的特点和优势"><a href="#3-React的特点和优势" class="headerlink" title="3. React的特点和优势"></a>3. React的特点和优势</h2><ul><li><p>虚拟DOM</p></li><li><p>组件系统</p></li><li><p>单向数据流</p></li><li><p>jsx语法</p></li></ul><h2 id="4-快速构建React开发环境"><a href="#4-快速构建React开发环境" class="headerlink" title="4. 快速构建React开发环境"></a>4. 快速构建React开发环境</h2><ol><li><p>使用 create-react-app脚手架 快速构建 React 开发环境</p></li><li><p>引入react、react-dom</p></li><li><p>创建DOM元素渲染</p></li><li><p>元素与组件</p></li></ol><h2 id="5-JSX的语法"><a href="#5-JSX的语法" class="headerlink" title="5. JSX的语法"></a>5. JSX的语法</h2><ol><li>jsx介绍<ul><li>jsx 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 jsx编写模板更加简单快速。</li></ul></li><li>jsx的使用<ul><li>jsx语法中, 要把js代码写到{}号中</li></ul></li><li>jsx中的注意事项<ul><li>注释推荐使用<code>{ /* 这是注释 */ }</code></li><li>在jsx创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</li><li>在 jsx 语法中，标签必须成对出现，如果是单标签，则必须自闭和</li></ul></li></ol><h2 id="6-React中创建组件"><a href="#6-React中创建组件" class="headerlink" title="6. React中创建组件"></a>6. React中创建组件</h2><ol><li><p>组件的创建方式</p><ol><li>函数式组件(<strong>首字母必须大写</strong>)</li><li>class关键字组件</li></ol></li><li><p> 两种组件的区别:</p></li></ol><ul><li><p>用<strong>函数</strong>创建出来的组件：叫做“无状态组件”</p></li><li><p>用<strong>class关键字</strong>创建出来的组件：叫做“有状态组件”</p></li><li><p>这两种组件<strong>本质区别</strong>就是：有无state属性</p></li></ul><ol start="3"><li>组件之间的组合和嵌套</li></ol><h2 id="7-JSX原理"><a href="#7-JSX原理" class="headerlink" title="7. JSX原理"></a>7. JSX原理</h2><ol><li><p>JS对象构建DOM结构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'app'</span> id=<span class="string">'root'</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">'title'</span>&gt;</span>铁蛋儿很帅<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    昌平小白龙</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>上面这个 HTML 所有的信息我们都可以用 JavaScript 对象来表示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">'div'</span>,</span><br><span class="line">  <span class="attr">attrs</span>: { <span class="attr">className</span>: <span class="string">'app'</span>, <span class="attr">id</span>: <span class="string">'root'</span>},</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">'h1'</span>,</span><br><span class="line">      <span class="attr">attrs</span>: { <span class="attr">className</span>: <span class="string">'title'</span> },</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">'铁蛋很帅'</span>]</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">'p'</span>,</span><br><span class="line">      <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">'昌平小白龙'</span>]</span><br><span class="line">    },</span><br><span class="line">    <span class="string">'123'</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>React中构建DOM结构</p><p>React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、还有子元素等</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  render () {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'app'</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">'title'</span>&gt;</span>欢迎铁蛋儿<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">         昌平小白龙</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>编译之后将得到的代码:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  render () {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      React.createElement(</span><br><span class="line">        <span class="string">"div"</span>,</span><br><span class="line">        {</span><br><span class="line">          <span class="attr">className</span>: <span class="string">'app'</span>,</span><br><span class="line">          <span class="attr">id</span>: <span class="string">'root'</span></span><br><span class="line">        },</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">"h1"</span>,</span><br><span class="line">          { <span class="attr">className</span>: <span class="string">'title'</span> },</span><br><span class="line">          <span class="string">"铁蛋很帅"</span></span><br><span class="line">        ),</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">"p"</span>,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          <span class="string">"昌平小白龙"</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">React.createElement(App),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="8-组件中DOM样式"><a href="#8-组件中DOM样式" class="headerlink" title="8. 组件中DOM样式"></a>8. 组件中DOM样式</h2><ol><li><p>行内样式</p></li><li><p>使用class</p></li><li><p>classnames</p><blockquote><p>npm  install  classnames –save</p></blockquote></li><li><p>styled-components</p><blockquote><p>npm  install  styled-components –save</p></blockquote></li></ol><h2 id="9-组件的属性-props"><a href="#9-组件的属性-props" class="headerlink" title="9. 组件的属性(props)"></a>9. 组件的属性(props)</h2><ol start="2"><li>class组件的属性和默认属性</li><li>函数组件的属性和默认属性</li><li>组件的props.children属性</li><li>使用props-type检查props</li></ol><h2 id="10-组件的状态-state"><a href="#10-组件的状态-state" class="headerlink" title="10. 组件的状态(state)"></a>10. 组件的状态(state)</h2><ol><li><p>创建组件状态的两种方式</p><ul><li>普通方式</li><li>继承方式</li></ul></li><li><p>设置组件状态(setState)</p><p>setState方法(有两个参数)设置状态</p><ul><li><p>第一个参数可以是对象，也可以是方法return一个对象。</p><ul><li>参数是对象</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState({</span><br><span class="line">  <span class="attr">isBool</span>: !<span class="built_in">this</span>.state.isBool</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>参数是方法</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1是上一次的state, 参数2是props</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">isBool</span>: !prevState.isBool</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li><p>setState是异步的,所以想要获取最新的state, 没有办法获取,就有了第二个参数,这是一个可选的回调函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">isBool</span>: !prevState.isBool</span><br><span class="line">  }</span><br><span class="line">}, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'回调里的'</span>,<span class="built_in">this</span>.state.isBool)</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setState外部的'</span>,<span class="built_in">this</span>.state.isBool)</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>渲染数据</p><ul><li>条件渲染</li><li>列表渲染</li><li>dangerouslySetInnerHTML方法</li></ul></li></ol><h2 id="11-属性-VS-状态"><a href="#11-属性-VS-状态" class="headerlink" title="11. 属性 VS 状态"></a>11. 属性 VS 状态</h2><p><strong>属性</strong></p><p><code>props</code> 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。</p><p>它是外部传进来的配置参数，组件内部无法控制也无法修改。</p><p>除非外部组件主动传入新的 <code>props</code>，否则组件的 <code>props</code> 永远保持不变。</p><p><strong>状态</strong>    </p><p> <code>state</code> 的主要作用是用于组件保存、控制、修改自己的可变状态。</p><p> <code>state</code> 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。</p><p> <code>state</code> 是一个局部的、只能被组件自身控制的数据源。</p><p> <code>state</code> 中状态可以通过 <code>this.setState</code>方法进行更新，<code>setState</code> 会导致组件的重新渲染。 </p><blockquote><p>如果搞不清 <code>state</code> 和 <code>props</code> 的使用场景，记住一个简单的规则：**尽量少地用 <code>state</code>，多用 <code>props</code>**。</p><p>没有 state 的组件叫<strong>无状态组件</strong>，设置了 state 的叫做<strong>有状态组件</strong>。</p><p>组件的数据渲染是否被调用者传递的<code>props</code>完全控制，控制则为<strong>受控组件</strong>，否则<strong>非受控组件</strong>。</p><p>因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。</p><p>这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p></blockquote><h2 id="12-事件"><a href="#12-事件" class="headerlink" title="12. 事件"></a>12. 事件</h2><ol><li><p>绑定事件</p><blockquote><p>采用on+事件名的方式来绑定一个事件，React和原生的事件是有区别的，原生的事件全是小写<code>onclick</code>, React中的事件是驼峰<code>onClick</code>，<strong>React的事件并不是原生事件，而是合成事件</strong>。</p></blockquote></li><li><p>事件用法</p><ul><li>直接在render里写行内的箭头函数(不推荐)</li><li>在组件内使用箭头函数定义一个方法(推荐)</li><li>直接在组件内定义一个非箭头函数的方法，然后在render里直接使用<code>onClick={this.handleClick.bind(this)}</code>(不推荐) </li><li>直接在组件内定义一个非箭头函数的方法，然后在constructor里bind(this)(官方推荐)</li></ul></li><li><p>Event对象</p><blockquote><p>和普通浏览器一样，事件handler会被自动传入一个 <code>event</code> 对象，这个对象和普通的浏览器 <code>event</code> 对象所包含的方法和属性都基本一致。不同的是 React中的 <code>event</code> 对象并不是浏览器提供的，而是它自己内部所构建的。它同样具有<code>event.stopPropagation</code>、<code>event.preventDefault</code> 这种常用的方法</p></blockquote></li><li><p>事件的参数传递</p><ul><li>在<code>render</code>里调用方法的地方外面包一层箭头函数 </li><li>在<code>render</code>里通过<code>this.handleEvent.bind(this, 参数)</code>这样的方式来传递</li></ul></li></ol><h2 id="13-用户输入案例"><a href="#13-用户输入案例" class="headerlink" title="13. 用户输入案例"></a>13. 用户输入案例</h2><ol><li>创建用户输入组件</li><li>添加状态绑定事件</li><li>改变状态更新组件</li></ol><h2 id="14-组件的生命周期"><a href="#14-组件的生命周期" class="headerlink" title="14. 组件的生命周期"></a>14. 组件的生命周期</h2><p>React中组件也有生命周期，有很多钩子函数供我们使用, 组件的生命周期，分为四个阶段，初始化、运行中、销毁、错误处理(16.3之后)</p><h4 id="初始化执行"><a href="#初始化执行" class="headerlink" title="初始化执行"></a>初始化执行</h4><ol><li><p>constructor&nbsp;</p></li><li><p>componentWillMount()&nbsp;/&nbsp;UNSAFE_componentWillMount()</p><ul><li> 组件被挂载到页面之前，自动被执行</li></ul></li><li><p>render()&nbsp; </p><ul><li>渲染组件</li></ul></li><li><p>componentDidMount() </p><ul><li>组件被挂载到页面之后，自动被执行</li></ul></li></ol><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p><code>props</code>或<code>state</code>的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法：</p><ol><li><p>componentWillReceiveProps()&nbsp;/&nbsp;UNSAFE_componentWillReceiveProps()&nbsp;</p><ul><li><p>子组件要从父组件接受参数，如果这个组件第一次存在于父组件中,不会执行</p><p>如果这个组件之前已经存在于父组件中，才会执行</p></li></ul></li><li><p>shouldComponentUpdate()&nbsp; </p><ul><li>组件被更新之前，自动执行返回true/false来决定 render是否更新  </li></ul></li><li><p>componentWillUpdate()&nbsp;/&nbsp;UNSAFE_componentWillUpdate()&nbsp;</p><ul><li><p>组件被更新之前它会自动执行但是在shouldComponentUpdate之后执行</p><p>shouldComponentUpdate返回true它才会执行，如果返回false，这个函数就不会被执行</p></li></ul></li><li><p>render()&nbsp;</p></li><li><p>componentDidUpdate()</p><ul><li>组件更新完成以后被执行</li></ul></li></ol><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><ol><li>componentWillUnmount()<ul><li>组件即将被从页面中剔除的时候执行</li></ul></li></ol><h2 id="15-ref属性"><a href="#15-ref属性" class="headerlink" title="15. ref属性"></a>15. ref属性</h2><p>React提供的这个<code>ref</code>属性，表示对组件真正实例的引用，其实就是<code>ReactDOM.render()</code>返回的组件实例,<code>ref</code>可以挂载到组件上也可以是dom元素上。</p><ul><li>挂到组件(<code>class</code>声明的组件)上的ref表示对组件实例的引用。<strong>不能</strong>在函数式组件上使用 ref 属性，因为它们没有实例：</li><li>挂载到dom元素上时表示具体的dom元素节点。</li></ul><h2 id="16-组件通信"><a href="#16-组件通信" class="headerlink" title="16. 组件通信"></a>16. 组件通信</h2><h4 id="父组件与子组件通信"><a href="#父组件与子组件通信" class="headerlink" title="父组件与子组件通信"></a>父组件与子组件通信</h4><ul><li>父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</li><li>父组件利用<code>ref</code>对子组件做标记，通过调用子组件的方法以更改子组件的状态,也可以调用子组件的方法</li></ul><h4 id="子组件与父组件通信"><a href="#子组件与父组件通信" class="headerlink" title="子组件与父组件通信"></a>子组件与父组件通信</h4><ul><li>父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过<code>this.props</code>接收到父组件的方法后调用。</li></ul><h4 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h4><p>在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系。react提供了<code>context</code> api来实现跨组件通信, React 16.3之后的<code>context</code>api较之前的好用。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>实例，使用<code>context</code> 实现购物车中的加减功能</p><blockquote><p>复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，在实际的工作中我们会使用flux、redux、mobx来实现</p></blockquote><h2 id="17-HOC-高阶组件"><a href="#17-HOC-高阶组件" class="headerlink" title="17. HOC(高阶组件)"></a>17. HOC(高阶组件)</h2><blockquote><p>高阶组件是一个函数接受一个组件作为参数，返回一个新的组件</p></blockquote><h2 id="18-React-Router"><a href="#18-React-Router" class="headerlink" title="18. React Router"></a>18. React Router</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>React Router甚至大部分的前端路由都是依赖于<a href="https://github.com/browserstate/history.js"><code>history.js</code></a>的，它是一个独立的第三方js库。可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。</p><ul><li>老浏览器的history: 通过<code>hash</code>来存储在不同状态下的<code>history</code>信息，对应<code>createHashHistory</code>，通过检测<code>location.hash</code>的值的变化，使用<code>location.replace</code>方法来实现url跳转。通过注册监听<code>window</code>对象上的<code>hashChange</code>事件来监听路由的变化，实现历史记录的回退。</li><li>高版本浏览器: 利用HTML5里面的history，对应<code>createBrowserHistory</code>, 使用包括<code>pushState</code>， <code>replaceState</code>方法来进行跳转。通过注册监听<code>window</code>对象上的<code>popstate</code>事件来监听路由的变化，实现历史记录的回退。</li><li>node环境下: 在内存中进行历史记录的存储，对应<code>createMemoryHistory</code>。直接在内存里<code>push</code>和<code>pop</code>状态。</li></ul></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><p>React Router包含了四个包:</p><table><thead><tr><th>包名</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router"><code>react-router</code></a></td><td>React Router核心api</td></tr><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom"><code>react-router-dom</code></a></td><td>React Router的DOM绑定，在浏览器中运行不需要额外安装<code>react-router</code></td></tr><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-native"><code>react-router-native</code></a></td><td><a href="https://facebook.github.io/react-native/">React Native</a> 中使用，而实际的应用中，其实不会使用这个。</td></tr><tr><td><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-config"><code>react-router-config</code></a></td><td>静态路由的配置</td></tr></tbody></table><p><strong>主要使用:</strong><code>react-router-dom</code> </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom --save  <span class="comment">// 5.x的版本主要是针对React Hook做更好的支持</span></span><br></pre></td></tr></tbody></table></figure><p>直接按照<a href="https://reacttraining.com/react-router/web/guides/quick-start">官网</a>的demo就理解 路由的使用方式:</p><blockquote><p>HashRouter、BrowserRouter、Route、Link、exact、404页面处理、Switch、NavLink、params、link的属性（pathname、search、hash、state)、redirect、push、replace、withRouter、prompt</p></blockquote><p>HashRouter和BrowserRouter</p><ul><li>HashRouter:锚点链接</li><li>BrowserRouter:H5的新特性（history）如果上线之后，需要后台做一些处理:<strong>重定向处理404bug</strong></li></ul><h2 id="19-redux"><a href="#19-redux" class="headerlink" title="19. redux"></a>19. redux</h2><h3 id="传统MVC框架的缺陷"><a href="#传统MVC框架的缺陷" class="headerlink" title="传统MVC框架的缺陷"></a>传统MVC框架的缺陷</h3><p><strong>什么是MVC？</strong></p><p><img src="img/mvc-base.png"></p><p><code>MVC</code>的全名是<code>Model View Controller</code>，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。</p><p><code>V</code>即View视图是指用户看到并与之交互的界面。</p><p><code>M</code>即Model模型是管理数据 ，很多业务逻辑都在模型中完成。在MVC的三个部件中，模型拥有最多的处理任务。</p><p><code>C</code>即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p><p><strong>MVC只是看起来很美</strong></p><p>MVC框架的数据流很理想，请求先到Controller, 由Controller调用Model中的数据交给View进行渲染，但是在实际的项目中，又是允许Model和View直接通信的。然后就出现了这样的结果：</p><p><img src="img/defect-of-mvc.png"></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。</p><ul><li>代码结构 </li><li>组件之间的通信</li></ul><p>2013年 Facebook 提出了 Flux 架构的思想，引发了很多的实现。2015年，Redux 出现，将 Flux 与<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">函数式编程</a>结合一起，很短时间内就成为了最热门的前端架构。</p><p>如果你不知道是否需要 Redux，那就是不需要它</p><p>只有遇到 React 实在解决不了的问题，你才需要 Redux</p><p>简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。</p><ul><li>用户的使用方式非常简单</li><li>用户之间没有协作</li><li>不需要与服务器大量交互，也没有使用 WebSocket</li><li>视图层（View）只从单一来源获取数据</li></ul><p><strong>需要使用Redux的项目:</strong></p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p><strong>从组件层面考虑，什么样子的需要Redux：</strong></p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><p><strong>Redux的设计思想：</strong></p><ol><li>Web 应用是一个状态机，视图与状态是一一对应的。</li><li>所有的状态，保存在一个对象里面（唯一数据源）。</li></ol><blockquote><p>注意：flux、redux都不是必须和react搭配使用的，因为flux和redux是完整的架构，在学习react的时候，只是将react的组件作为redux中的视图层去使用了。</p></blockquote><p><strong>Redux的使用的三大原则：</strong></p><ul><li><p>Single Source of Truth(唯一的数据源)</p></li><li><p>State is read-only(状态是只读的)</p></li><li><p>Changes are made with pure function(数据的改变必须通过纯函数完成)</p><blockquote><p>什么是纯函数:</p><p>纯函数指的是 给定固定的输入就一定会有固定的输出，而且不会有任何副作用。</p><p>不固定的话像日期对象、ajax请求、异步操作就不是纯函数了</p><p>副作用是对接受的参数进行修改。我们可以复制一份修改复制的</p></blockquote></li></ul><h2 id="20-redux和react-redux区别"><a href="#20-redux和react-redux区别" class="headerlink" title="20. redux和react-redux区别"></a>20. redux和react-redux区别</h2><blockquote><p>redux:js的状态管理</p><p>react-redux:为了在react中方便实用redux</p></blockquote><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>教程:<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p><p><img src="img/3.jpeg"></p><ul><li><p>createStore:(创建store)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createStore} <span class="keyword">from</span> <span class="string">"redux"</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(Reducer)</span><br></pre></td></tr></tbody></table></figure></li><li><p>applyMiddleware:(处理中间件)</p><blockquote><p>一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</p><p>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span> <span class="comment">// 处理异步的中间件</span></span><br><span class="line"><span class="keyword">const</span>  store = createStore(Reducer, applyMiddleware(thunk)</span><br></pre></td></tr></tbody></table></figure><ul><li>引入react-thunk的异步操作（注意:异步一定要放在aciton操作)</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入react-thunk模块</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'react-thunk'</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,applyMiddleware(thunk))</span><br><span class="line"><span class="comment">// action里的异步操作 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function"><span class="params">num</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// 因为是一个对象就不用return</span></span><br><span class="line">      dispatch({</span><br><span class="line">        <span class="attr">type</span>: <span class="string">"DECREMENT"</span>,</span><br><span class="line">        num</span><br><span class="line">      });</span><br><span class="line">    }, <span class="number">1000</span>);</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意:定时器、网络请求、事件监听、在组件被销毁前都应得到相应的处理</p></li></ul><h3 id="实战Redux实现TodoList"><a href="#实战Redux实现TodoList" class="headerlink" title="实战Redux实现TodoList"></a>实战Redux实现TodoList</h3><ol><li>使用Antd搭建todoList</li><li>创建store</li><li>创建action和reducer实现添加功能</li><li>实现删除功能 </li><li>actionTypes的拆分</li><li>使用actionCreators拆分action</li><li>UI组件和容器组件</li><li>无状态组件</li><li>redux中使用异步</li><li>redux-thunk</li><li>redux-sage</li></ol><h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux:"></a>react-redux:</h3><p>注意版本问题:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"react"</span>: <span class="string">"^16.12.0"</span>,</span><br><span class="line"><span class="string">"react-dom"</span>: <span class="string">"^16.12.0"</span>,</span><br><span class="line"><span class="string">"react-redux"</span>: <span class="string">"^7.1.3"</span>,</span><br><span class="line"><span class="string">"react-scripts"</span>: <span class="string">"3.4.0"</span>,</span><br><span class="line"><span class="string">"redux"</span>: <span class="string">"^4.0.5"</span>,</span><br></pre></td></tr></tbody></table></figure><ul><li><p>Provider</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createStore} <span class="keyword">from</span> <span class="string">"redux"</span></span><br><span class="line"><span class="keyword">import</span> { Provider } <span class="keyword">from</span> <span class="string">"react-redux"</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">{</span> <span class="attr">store</span> }&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Children</span> /&gt;</span>   // 子组件就可以接受store到 但是还不能直接用 </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></tbody></table></figure></li><li><p>connect</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> { connect } <span class="keyword">from</span> <span class="string">"react-redux"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 连接高级组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispachToProps)(Children) </span><br></pre></td></tr></tbody></table></figure><ul><li><p>mapStateToProps（将state映射到 UI 组件的参数（props))</p><blockquote><p>mapStateToProps是一个函数,它的作用是建立一个从（外部的）state对象到（UI 组件的props对象的映射关系,传入connect中相当于立即执行,返回一个对象,里面的每一个键值对就是一个映射</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapStateToProps 可以传入两个参数state、ownProps（本组件的props）</span></span><br><span class="line"><span class="comment">// 第一个参数</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">todoList</span>: state.todoList</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第二个参数</span></span><br><span class="line"><span class="comment">//    &lt;FilterLink filter="All"&gt;</span></span><br><span class="line"><span class="comment">//      All</span></span><br><span class="line"><span class="comment">//    &lt;/FilterLink&gt;</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">active</span>: ownProps.filter === state.filter</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>mapDispachToProps（输出逻辑，即将用户对 UI 组件的操作映射成 Action。）</p><blockquote><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p></blockquote><ol><li><p>mapDispatchToProps为函数的用法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params"> dispatch, ownProps</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">          <span class="attr">onClick</span>: <span class="function">() =&gt;</span> {</span><br><span class="line">            dispatch({ <span class="comment">// action</span></span><br><span class="line">              <span class="attr">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">              <span class="attr">filter</span>: ownProps.filter</span><br><span class="line">            });</span><br><span class="line">          }</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>mapDispatchToProps为对象的用法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = {</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> {</span><br><span class="line">    <span class="attr">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">    <span class="attr">filter</span>: filter</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">import</span> {onClick} <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,{onClick})(App);</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ul></li><li><p>bindActionCreators:（作用是将一个或多个action和dispatch组合起来生成mapDispatchToProps需要生成的内容）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {increment,decrement}  <span class="keyword">from</span> <span class="string">"./actions"</span>;</span><br><span class="line"><span class="keyword">import</span> { bindActionCreators } <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">const</span> mapDispatchProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> {</span><br><span class="line">   <span class="comment">// 单个用法</span></span><br><span class="line">   <span class="comment">//return {</span></span><br><span class="line">      <span class="attr">increment</span>:bindActionCreators(increment,dispatch),</span><br><span class="line">      <span class="attr">decrement</span>:bindActionCreators(decrement,dispatch)</span><br><span class="line">  <span class="comment">// }</span></span><br><span class="line">  <span class="comment">// 多个用法</span></span><br><span class="line">  <span class="keyword">return</span> bindActionCreators({increment,decrement},dispatch)</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 注意：事件触发函数直接调用不用加() 假如要传递参数 事件要多加一层然后执行传入参数（参数）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>combineReducers:（合并多个reducer）</p><blockquote><p>reducer存放过多的数据 可能造成代码的不可维护 最好把reducer拆分</p><p>用redux内置的combinReducers函数进行拆分</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入函数</span></span><br><span class="line"><span class="keyword">import</span> { combineReducers } <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="comment">// 合并reducer</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers({</span><br><span class="line">  reducer1,</span><br><span class="line">  reducer2</span><br><span class="line">});</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer; <span class="comment">// 导出</span></span><br><span class="line"><span class="comment">// 传入state合并好的reducer</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"><span class="comment">// 在组件中调用reducer</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">counter</span>: state.reducer1,</span><br><span class="line">    <span class="attr">user</span>: state.reducer2</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="21-React-Hooks"><a href="#21-React-Hooks" class="headerlink" title="21. React Hooks"></a>21. React Hooks</h2><p>教程:<a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html?tdsourcetag=s_pctim_aiomsg">http://www.ruanyifeng.com/blog/2019/09/react-hooks.html?tdsourcetag=s_pctim_aiomsg</a></p><p><strong>什么是hooks:</strong></p><blockquote><p>​    React一直都提倡使用函数组件，但是有时候需要使用 state 或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有.</p><p>Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性.</p><p>如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks. 凡是 use 开头的 React API 都是 Hooks.</p></blockquote><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h3><p>  <code>useState</code>可以让我们在函数式组件中定义一个state和一个用来修改state的方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count状态、setCount修改状态、useState(默认值)</span></span><br><span class="line"><span class="keyword">let</span> [ count,setCount ] = useState( count的初始值 )</span><br></pre></td></tr></tbody></table></figure><h3 id="2-useContext"><a href="#2-useContext" class="headerlink" title="2. useContext"></a>2. useContext</h3><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。<br> 有部分小伙伴应该使用props属性进行组件向下传值的操作。当多个组件嵌套时候。你就需要慢慢向上寻找最初的值是什么</p><p><strong>React.createContext：</strong>创建一个上下文的容器(组件), defaultValue可以设置共享的默认数据</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {Provider, Consumer} = React.<span class="built_in">createContext</span>(defaultValue);</span><br></pre></td></tr></tbody></table></figure><p><strong>Provider(生产者)</strong>: 和它的名字一样。用于生产共享数据的地方。生产什么呢？ 那就看value定义的是什么了。value:放置共享的数据。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider <span class="keyword">value</span>={<span class="comment">/*共享的数据*/</span>}&gt;</span><br><span class="line">    <span class="comment">/*里面可以渲染对应的内容*/</span></span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>Consumer(消费者)</strong>:这个可以理解为消费者。 它是专门消费供应商(<strong>Provider</strong> 上面提到的)产生数据。Consumer需要嵌套在生产者下面。才能通过回调的方式拿到共享的数据源。当然也可以单独使用，那就只能消费到上文提到的defaultValue</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">  {<span class="keyword">value</span> =&gt; <span class="comment">/*根据上下文  进行渲染相应内容*/</span>}</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>useContext</strong></p><p>如果需要在组件之间共享状态，可以使用<code>useContext()</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> locale = useContext(LocaleContext);</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>useContext 的入参是某个 Provider 提供的 context，如果 context 发生变化的话，返回值也会立即发生变化。</p><h3 id="3-useReducer"><a href="#3-useReducer" class="headerlink" title="3. useReducer"></a>3. useReducer</h3><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p><p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是<code>(state, action) =&gt; newState</code>。</p><p><code>useReducers()</code>钩子用来引入 Reducer 功能。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></tbody></table></figure><p>上面是<code>useReducer()</code>的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的<code>dispatch</code>函数。</p><h3 id="4-useEffect"><a href="#4-useEffect" class="headerlink" title="4. useEffect"></a>4. useEffect</h3><p><code>Effect Hook</code>可以使得你在函数组件中执行一些带有副作用的方法。</p><blockquote><p>数据获取，设置订阅以及手动更改<code>React</code>组件中的<code>DOM</code>都是副作用的示例。无论你是否习惯于将这些操作称为“副作用”（或仅仅是“效果”），但你之前可能已经在组件中执行了这些操作。</p><p><strong>提示：</strong> 如果你熟悉<code>React</code>类生命周期方法，则可以将<code>useEffect Hook</code>视为<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的组合。</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()  =&gt;</span>  {</span><br><span class="line">  <span class="comment">// Async Action</span></span><br><span class="line">}, [dependencies])</span><br></pre></td></tr></tbody></table></figure><p><code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p><h3 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h3><p>React组件的构造函数在挂载之前被调用。</p><p>在实现<code>React.Component</code>构造函数时，需要先在添加其他内容前，调用<code>super(props)</code>，</p><p>用来将父组件传来的<code>props</code>绑定到这个类中，使用<code>this.props</code>将会得到。</p><p>官方建议不要在<code>constructor</code>引入任何具有副作用和订阅功能的代码，这些应当使用<code>componentDidMount()</code>。</p><p><code>constructor</code>中应当做些初始化的动作，如：初始化<code>state</code>，将事件处理函数绑定到类实例上，但也不要使用<code>setState()</code>。如果没有必要初始化state或绑定方法，则不需要构造<code>constructor</code>，或者把这个组件换成纯函数写法。</p><p>当然也可以利用<code>props</code>初始化<code>state</code>，在之后修改<code>state</code>不会对<code>props</code>造成任何修改，但仍然建议大家提升状态到父组件中，或使用<code>redux</code>统一进行状态管理。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> {</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">this</span>.state = {</span><br><span class="line">    <span class="attr">isBool</span>: props.isBool</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h3><p><code>getDerivedStateFromProps</code> 是react16.3之后新增，在组件实例化后，和接受新的<code>props</code>后被调用。他必须返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。</p><p>如果是由于父组件的<code>props</code>更改，所带来的重新渲染，也会触发此方法。</p><p>调用<code>setState()</code>不会触发<code>getDerivedStateFromProps()</code>。</p><p>之前这里都是使用<code>constructor</code>+<code>componentWillRecieveProps</code>完成相同的功能的</p><h3 id="componentWillMount-UNSAFE-componentWillMount"><a href="#componentWillMount-UNSAFE-componentWillMount" class="headerlink" title="componentWillMount() / UNSAFE_componentWillMount()"></a>componentWillMount() / UNSAFE_componentWillMount()</h3><p><code>componentWillMount()</code>将在React未来版本(官方说法 17.0)中被弃用。<code>UNSAFE_componentWillMount()</code>在组件挂载前被调用，在这个方法中调用<code>setState()</code>不会起作用，是由于他在<code>render()</code>前被调用。</p><p>为了避免副作用和其他的订阅，官方都建议使用<code>componentDidMount()</code>代替。这个方法是用于在服务器渲染上的唯一方法。这个方法因为是在渲染之前被调用，也是惟一一个可以直接同步修改state的地方。</p><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p>render()方法是必需的。当他被调用时，他将计算<code>this.props</code>和<code>this.state</code>，并返回以下一种类型：</p><ol><li>React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。&nbsp;</li><li>字符串或数字。他们将会以文本节点形式渲染到dom中。&nbsp;</li><li>Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。&nbsp;</li><li>null，什么也不渲染&nbsp;</li><li>布尔值。也是什么都不渲染。</li></ol><p><code>render()</code>方法必须是一个纯函数，他不应该改变<code>state</code>，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 </p><p>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>render()</code>不会被调用。</p><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p><code>componentDidMount</code>在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。</p><p><strong>通常在这里进行ajax请求</strong></p><p>如果要初始化第三方的dom库，也在这里进行初始化。只有到这里才能获取到真实的dom.</p><h3 id="componentWillReceiveProps-UNSAFE-componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-UNSAFE-componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)</h3><p>官方建议使用<code>getDerivedStateFromProps</code>函数代替<code>componentWillReceiveProps</code>。当组件挂载后，接收到新的<code>props</code>后会被调用。如果需要更新<code>state</code>来响应<code>props</code>的更改，则可以进行<code>this.props</code>和<code>nextProps</code>的比较，并在此方法中使用<code>this.setState()</code>。</p><p>如果父组件会让这个组件重新渲染，即使<code>props</code>没有改变，也会调用这个方法。</p><p>React不会在组件初始化props时调用这个方法。调用<code>this.setState</code>也不会触发。</p><h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>调用<code>shouldComponentUpdate</code>使React知道，组件的输出是否受<code>state</code>和<code>props</code>的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。</p><p>在渲染新的<code>props</code>或<code>state</code>前，<code>shouldComponentUpdate</code>会被调用。默认为<code>true</code>。这个方法不会在初始化时被调用，也不会在<code>forceUpdate()</code>时被调用。返回<code>false</code>不会阻止子组件在<code>state</code>更改时重新渲染。</p><p>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>componentWillUpdate</code>,<code>render</code>和<code>componentDidUpdate</code>不会被调用。</p><blockquote><p>官方并不建议在<code>shouldComponentUpdate()</code>中进行深度查询或使用<code>JSON.stringify()</code>，他效率非常低，并且损伤性能。</p></blockquote><h3 id="UNSAFE-componentWillUpdate-nextProps-nextState"><a href="#UNSAFE-componentWillUpdate-nextProps-nextState" class="headerlink" title="UNSAFE_componentWillUpdate(nextProps, nextState)"></a>UNSAFE_componentWillUpdate(nextProps, nextState)</h3><p>在渲染新的<code>state</code>或<code>props</code>时，<code>UNSAFE_componentWillUpdate</code>会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。</p><p>*不能在这里使用this.setState()*，也不能做会触发视图更新的操作。如果需要更新<code>state</code>或<code>props</code>，调用<code>getDerivedStateFromProps</code>。</p><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a>getSnapshotBeforeUpdate()</h3><p>在react <code>render()</code>后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。</p><h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h3><p>在更新发生后立即调用<code>componentDidUpdate()</code>。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。</p><p>如果组件实现<code>getSnapshotBeforeUpdate()</code>生命周期，则它返回的值将作为第三个“快照”参数传递给<code>componentDidUpdate()</code>。否则，这个参数是<code>undefined</code>。</p><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p>在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在<code>componentDidMount</code>中创建的任何监听。</p><h3 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a>componentDidCatch(error, info)</h3><p>错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。</p><p>如果类组件定义了此生命周期方法，则它将成错误边界。在它中调用<code>setState()</code>可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复; 不要试图将它们用于控制流程。</p><p>错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p><code>PureComponnet</code>里如果接收到的新属性或者是更改后的状态和原属性、原状态相同的话，就不会去重新render了<br>在里面也可以使用<code>shouldComponentUpdate</code>，而且。是否重新渲染以<code>shouldComponentUpdate</code>的返回值为最终的决定因素。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { PureComponent } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>{</span><br><span class="line">  ……</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不错的文章: <a href="https://www.jianshu.com/p/514fe21b9914">https://www.jianshu.com/p/514fe21b9914</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个时间吃不胖</title>
      <link href="2021/05/26/zgsjcbp/"/>
      <url>2021/05/26/zgsjcbp/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：『饮食时间』是瘦身的关键"><a href="#第一章：『饮食时间』是瘦身的关键" class="headerlink" title="第一章：『饮食时间』是瘦身的关键"></a>第一章：『饮食时间』是瘦身的关键</h1><h2 id="01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！"><a href="#01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！" class="headerlink" title="01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！"></a>01、今天早上吃早饭了吗？生物钟瘦身的秘密就在于此哦！</h2><p>一听说穷只卷心菜的热量低，你就立刻订购，一旦是相交成的瘦身减肥的流行趋势，你就大量的购买香蕉，每天不停地吃。尽管试验了很多种减肥的方法，但都没能坚持长久，刚刚瘦了一点点，马上又反弹，简直就陷入无止境的反复中。</p><p>其实，你的这些努力反而正在故意的增肥呢。人体原本自身拥有一套系统，能够维持健壮而不肥胖的体质，如果违反了这套系统中的运行规律，将会在体内储存多余的脂肪。再加上不合理的减肥方法，长此以往将会变成易胖体质，这简直就是一种恶性循环。</p><p>那么在这里我有一个问题要问问你。</p><p>今天早上你吃早餐了吗？不会是一个星期有一半以上的时间都没吃早餐吧？</p><p>来自日本卫生部的数据显示，20<del>30岁，30</del>40岁的女性中，不吃早餐的人数比例呈现逐年上升的趋势。与20年前相比，不吃早餐或者只是简单吃点营养品和饮料来代替早餐的人数大幅度增加。特别是20~30岁的女性，不吃早餐的人数增加了一成以上。也就是大概四个人中就会有一个人没有认真吃早餐。</p><h3 id="遵循身体自身的生理规律就不会发胖"><a href="#遵循身体自身的生理规律就不会发胖" class="headerlink" title="遵循身体自身的生理规律就不会发胖"></a>遵循身体自身的生理规律就不会发胖</h3><p>早在上古时代，人类的身体自身就牢牢地记在了一定的生理规律清晨睁开双眼。真心开始了一天的劳作，从白天到傍晚，身体的活动量达到顶点，日落之后，慢慢的进入了休息状态，最后进入梦乡。只要遵循这种自然的生理规律，保持劳作与休息的平衡，那么从食物中获取的能量与劳动中消耗的能量也就能保持一种平衡的关系。</p><p>造成肥胖的原因可以理解为从食物中获取的能量没有被彻底的消耗掉，它们在体内形成脂肪后被储存起来。身体自身所记载的生理规律一旦遭到破坏，摄入的能量和消耗的能量就无法达到“收支平衡”，结果造成了肥胖。</p><p>把握身体生理规律的关键就是<strong>吃早餐</strong>。这一点请一定要牢记哦。</p><h3 id="晚上9点以后才开始吃晚餐的人要注意啦"><a href="#晚上9点以后才开始吃晚餐的人要注意啦" class="headerlink" title="晚上9点以后才开始吃晚餐的人要注意啦"></a>晚上9点以后才开始吃晚餐的人要注意啦</h3><p>同样是来自日本卫生部的数据，他们分别对吃早餐的人群和不吃早餐的人群的晚餐时间进行了调查，其结果显示：真正与后者相比，晚餐的时间相对较早。30-40岁的女性人群中，吃早餐的人大部分在晚上8点之前结束当日的晚餐。而在不吃早餐的人群中，有两成左右的人在晚上9点以后才吃晚餐。在20岁至30岁的女性人群中，这个比例占到三成左右。在10-50岁不吃早餐的男性人群中，有三层以上的人在晚上9点以后才吃晚餐。</p><p>对于工作或者娱乐的原因，不知不觉中回家的时间被向后拖延了，享用完姗姗来迟的晚餐之后，已是别接近晚上11点了。在整理一下随身的物品，洗澡，身体护理，写写博客等等，一晃也就到了凌晨一两点钟。像这样的事情早已司空见惯，这样以来，次日早晨早早的起床，好好的吃个早饭简直是不可能的。</p><p>不吃早餐→拖延晚餐时间→次日仍旧不吃早餐，这已经形成了一种恶性循环，身体自身的生理规律遭到了实质性的破坏，晚睡导致了晚起不吃早餐又造成了身体能量不充足，最后导致整个上午的活动量无法提升。并且由于饥饿感在午餐时间达到了顶点，所以午餐容易吃的过多。</p><p>拖延了晚餐时间，不仅仅打破了身体自身的生理规律，同时也成为导致肥胖的直接原因。<strong>晚餐时间与就寝时间相隔太近的话，即使身体吸收的营养转化为能量了，也没有时间再去把它消耗掉</strong>。无家可归的能量被脂肪细胞所接收，从而形成的脂肪贮存在了人体的内部。</p><p>不仅如此，与就寝时间无关，单单是晚餐时间被拖延也会导致体内脂肪的堆积，后面我会对此再进行详细的说明。即便是同样的菜单，同样热量的晚餐越早食用越不容易发胖。</p><p>自己肯定不是一个很能吃的人，可是稍不留神立刻就会变胖，更何况自己平时就是一个很注意热量摄入值的人，对油腻的食物或者甜品的摄入都很节制，然而还是瘦不下来。如果你觉得自己属于这样的人群，那么就要请你回想一下，这个星期每天都是几点吃的晚餐呢？</p><h3 id="轮班工作者容易发胖，原因是什么呢？"><a href="#轮班工作者容易发胖，原因是什么呢？" class="headerlink" title="轮班工作者容易发胖，原因是什么呢？"></a>轮班工作者容易发胖，原因是什么呢？</h3><p>最后是等昼夜交替的轮班工作者和仅在白天工作的人的肥胖指数进行了调查和对比。我们得到一个耐人寻味的数据结果。以身高和体重比例计算得出的肥胖指数BMI（Body Mass Index）中19~22表示标准体重，25以上认定为肥胖。 将调查数据进行比较之后，我们看到轮班工作者的BMI达到26以上的比例是仅在白天工作的人的比例的五倍以上。通过这个数据，基本上证明了<strong>昼夜颠倒且不规律的作息时间增加了，成为肥胖体质的概率</strong>。</p><p>作息时间的变化,当然不仅仅是轮班制工作者所独有的问题，日本NHK电视台曾经作过的一项调查结果显示，夜间11点就请的人数从1970年占日本人口的70%~2005年占40%左右，比例大幅下降。就请时间向后拖延，对就餐时间也产生了影响，使得身体自身的生理规律遭到破坏，变得容易发胖。</p><p>记载人体每天的生理规律的载体，我们称之为生物钟。它并不是用来让人们知晓时间的，而是具有自主的记载一定的生育规律并督促细胞按时进行活动的作用。同时，生物钟也发挥着调节各种激素分泌量的作用。因此，即便是在没有时钟的环境下，也可以与平时一样，在相同的时间睡觉，在相同的时间起床。</p><h3 id="身体的时差反应导致人体容易发胖"><a href="#身体的时差反应导致人体容易发胖" class="headerlink" title="身体的时差反应导致人体容易发胖"></a>身体的时差反应导致人体容易发胖</h3><p>生物钟在正常运转的情况下，各种蛋白质就会向细胞传达讯息，使得人那样代谢得到提升，并在运动中形成必要的肌肉，大脑活动也就被进一步激活。这种运转机制已经在近期的研究中得到了证实。燃鹅，如果生物中所记载的生理规律错乱的话，就会导致与上述情况相反的结果。身体代谢变缓，体力下降，思维混乱，简直就像陷入了时差反应的状态。</p><p>拖延晚餐且不吃早餐的生活方式迫使身体全年处于倒时差的状态之中，因此无论怎么控制摄入体内的热量，都很难达到减肥的效果。实际上肥胖的原因与其在于说“吃什么”，还不如说在于“什么时间吃”。</p><h2 id="02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。"><a href="#02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。" class="headerlink" title="02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。"></a>02、生物钟是一个精密的运转系统，这也是生物自身了不起的功能。</h2><p>睡眠、觉醒等这些被人体生物钟牢牢记载的生理规律被称为“昼夜节律”。“昼夜节律”于拉丁语表示大约一天的意思。如果以一天为单位来看，身体状态不断上升，逐渐达到顶点，然后慢慢下降。一切身体活动都是受生物钟所记载的昼夜节律所控制的，例如体温在下午3点左右达到最高值，运动能力，肺活量等在傍晚时分能达到顶点。</p><p>人体为什么需要这种生理规律呢？我们认为这是人体为了适应由地球自转引起的生活环境变化而形成的规律。昼夜节律就是生物题与地球自转同步的生理规律。生物钟是人体为了适应环境而保留下来的财富，是生物自身逐步进化得到的运转系统。</p><p>如果你的生活习惯与这种生理规律背道而驰，就会使身体产生各种不适。人体的肥胖现象就是这类不适反应的一种。</p><h3 id="生物中遗传因子掌握着开启生物钟的钥匙"><a href="#生物中遗传因子掌握着开启生物钟的钥匙" class="headerlink" title="生物中遗传因子掌握着开启生物钟的钥匙"></a>生物中遗传因子掌握着开启生物钟的钥匙</h3><p>生物钟系统在各个领域都备受瞩目，特别是生物钟与饮食的关系。已经逐步成为一门学问，被称为“时间营养学”。其在饮食教育、预防医学，健康科学等众多领域都被广泛研究。</p><p>给大家介绍一下生物钟是怎样运转的吧。</p><p>大约在十年前，人类发现了一种蛋白物质，称之为“生物中遗传因子”，经研究发现，它在人体内发挥着推动生物钟运转的作用，大脑视神经交叉的地方，也就是在被称为“视交叉上核”的部位上存在着主要生物中遗传因子。主要生物中遗传因子自主地记载着以大约25小时为周期的昼夜节律，从早晨起床时睁开眼睛，接受到第一缕阳光的讯息，开始自动地与地球自转的24小时周期相结合。人体每日沐浴阳光，并由此来调整每一天的体内生物钟。如果长期在黑暗中生活的话，主要生物中遗传因子就会一直按照25小时的周期来不断运转。人体的生理规律相对于地球的自转周期就会一直向后推延。</p><p>此外，在末梢部位也存在着生物中遗传因子，同时存在于肝脏，心脏，肾脏，肺，肌肉等人体的各个部位，分别记载着各自的生理规律，并且并不是光线在调节这些生物中因子，而是人们平时的饮食。早晨起床后一个小时内吃早餐可以调整末梢部位的生物中遗传因子，使其主要的生物中遗传因子同步。  </p><p>全身的生物中遗传因子如果得不到很好的调整，就会各自随意的运转，例如大脑已经清醒而身体还在沉睡之中，所以吃早餐是调节人体生理规律所不可缺少的一项。</p><h3 id="吃早餐会使代谢能力自动增强"><a href="#吃早餐会使代谢能力自动增强" class="headerlink" title="吃早餐会使代谢能力自动增强"></a>吃早餐会使代谢能力自动增强</h3><p>由于食物的刺激，末梢部位的生物中遗传因子一旦开始计算时间，就会增加体内的某种蛋白质，这种蛋白质能够增加用来消耗能量的细胞中的小器官——线粒体，使其促进肌肉合成。它是一种能够提高代谢效率的重要蛋白质。并且，不是白天，也不是夜晚，而是早餐的刺激才能激活起自身的作用。</p><p>也就是说，不吃早餐就不能调节末梢部位的生物中遗传因子，因此身体代谢效率下降，逐渐变成了容易肥胖的体质。</p><h3 id="蛋白质的增减调节着生物钟的节奏"><a href="#蛋白质的增减调节着生物钟的节奏" class="headerlink" title="蛋白质的增减调节着生物钟的节奏"></a>蛋白质的增减调节着生物钟的节奏</h3><p>让我们更加详细的看一下生物中遗传因子的运转机制吧。</p><p>大脑的视交叉上核里存在的主要生物中遗传因子里存在着Clock蛋白和Bmall蛋白，然后产生叫做Per蛋白和Cry蛋白的物质。而实际上Per蛋白和Cry蛋白又是妨碍Clock蛋白和Bmal;蛋白运转的物质。</p><p>Per蛋白和Cry蛋白的增加会削弱Clock蛋白和Bmall的蛋白的作用，这种削弱同时也会使per蛋白和Cry蛋白的含量减少。Bmall蛋白和Clock蛋白又被再次激活。这样看来，他们的运转机制就像拔河运动一样。在这些物质中，描绘增减曲线的主要物质是Bmall蛋白。据研究发现，这种物质能够起到促进脂肪合成的作用，在下午2点~4点这个时间段数量最少，而在夜间的10点到第二天凌晨的两点，这个时间段的数量急剧增加，<strong>所以夜间用餐很容易发胖也是这个原因。</strong></p><h2 id="03、生物钟瘦身法则：早起——所有减肥方法的基础"><a href="#03、生物钟瘦身法则：早起——所有减肥方法的基础" class="headerlink" title="03、生物钟瘦身法则：早起——所有减肥方法的基础"></a>03、生物钟瘦身法则：早起——所有减肥方法的基础</h2><p>之前已经对人体生物钟和生物中遗传因子做了一个简单的介绍。</p><p>为了能够锻炼成不容易变胖体质，我们应该怎么做呢？</p><p>首先就是要做到早起。早起的目的是为了让清晨的光线激活大脑里主要生物中遗传因子。主要生物中遗传因子就像是人体全身的生物中遗传因子的指挥官。各自肩负着向记载着生理规律的末梢部位的生物中遗传因子传递“清晨已经来临”这一信息的职责。所以<strong>消除时差反应最有效的方法就是——沐浴阳光</strong>。</p><p>在治疗失眠的临床研究中也有使用发光二极管的光治疗方法，这也是为了让主要生物中遗传因子开始工作时其能够恢复正常的昼夜节律。</p><p>能够使主要生物中遗传因子正常工作的物质就是清晨的阳光。首先需要让“指挥官”苏醒，然后用一天的时间来指挥身体的这个大型“交响乐团”。因此，让身体有一个良好的开始是非常重要的。如果能够与日出同时出发享受第一缕阳光的话，那是非常理想的状态。当然，不出房门仅仅是在屋子里感受阳光也是可以的，但随着地球的自转，尽可能的早起。感受阳光的沐浴，无论是天气好坏，阳光每天会依旧普照大地，无论是阴天还是雨雪天，阳光对人体产生的效果是一样的。</p><p>昼夜颠倒的轮班制工作者容易变得肥胖，这已经是不产自明的事情了。追踪生活不规律的学生得到的调查结果显示，人体在上午的活动量非常少，而且代谢效率也很低。这都是因为他们没有好好的接受大自然给人类的恩惠——阳光。尽管多数人都是在白天工作的上班族，但也有很多人通勤时间是相对自由的弹性工作制，尤其到了休息日，从工作日的疲劳奔波状态突然过渡到一觉睡到日上三竿的懒散生活如果每天坚持规律地生活在固定的时间起床，那么就很难造成体内的生物钟混乱，并且早晨的时间也会变得很充裕。从而养成每天吃早饭的好习惯，这也是早起的一大优点。</p><h3 id="认真吃早餐是瘦身的秘诀"><a href="#认真吃早餐是瘦身的秘诀" class="headerlink" title="认真吃早餐是瘦身的秘诀"></a>认真吃早餐是瘦身的秘诀</h3><p>吃早餐是瘦身的另一款则包括肝脏在内的全身生物中遗传因子就可以完全的与主要生物中遗传因子进行同步。并且起床后一小时以内吃早餐是调整体内生物钟生理规律的条件。不吃早餐的日子，人体的大脑和身体的生物钟各自运转不相协调。身体虽然开始活动了，但是大脑还没有完全的清醒。</p><p>日本的教育部门针对全国10万人进行了学历测试，其结果显示，每天吃早餐的学生比不吃早餐的学生的成绩要高出20%。吃早餐的学生，每一门功课的学习成绩都比不吃早餐的学生优秀20%。足以可见吃早餐的重要性。</p><p>有些人认为如果不吃饭的话，至少能够减少这一顿饭的热量，这简直是大错特错。与之相反，大脑没有充分的运转起来，反而容易陷入更加肥胖的状态。</p><p>所谓的早餐，不仅仅只是随便喝点饮料或者是营养品就草草了事的，而是尽可能的做到主食主菜，副菜样样俱全。生物钟瘦身法的饮食关键也是由此开始的。</p><p>我们之前已经提到过，构成主要生物中遗传因子的Bmall蛋白是促进脂肪合成的主要物质。Bmall单倍的数量在白天相对减少，在夜间相对增加。所以需要很好的利用这一特点。为了防止晚餐吃的过多，可以尽量的在白天多吃一些。因为在白天，Bmall蛋白不会起作用，所以尽管多吃了一些，也几乎没有脂肪增长的风险。而且晚餐最晚在晚上9点之前想用尽量摄取脂肪含量少的食品，这也是最基本的方法。</p><h3 id="以适度的运动来支撑生物钟的运转"><a href="#以适度的运动来支撑生物钟的运转" class="headerlink" title="以适度的运动来支撑生物钟的运转"></a>以适度的运动来支撑生物钟的运转</h3><p>早睡、早起、吃早餐是生物钟瘦身法的三大支柱。遵循这三大法则可以得到不容易变胖的体质，为了提高人体体内生物钟的调节作用，提高人体代谢效率，进一步达到减肥的效果。我在向大家推荐一套运动瘦身法。</p><p>从人体生物中所记载的生理规律的角度来看，<strong>一天中最适合运动的时间段是傍晚的6点左右。是身体各种机能都达到顶点的黄金时间</strong>。研究表明，在这个时段运动能够更多的分泌促进脂肪代谢的甲状腺刺激激素以及增长肌肉，修复身体组织的成长技术，并且通过运动可以更好的处理体内产生的疲劳物质。如果是同样强度的运动，与早晨相比范围运动的效率相对更高。</p><h3 id="运动得到高质量的睡眠"><a href="#运动得到高质量的睡眠" class="headerlink" title="运动得到高质量的睡眠"></a>运动得到高质量的睡眠</h3><p>并不是说其他时间段的运动就没有意义，如果将能够燃烧脂肪的轻度有氧运动通过刺激肌肉来防止代谢效率下降的简单肌肉训练，提高睡眠质量的睡前伸展运动等多种运动结合起来的话，减肥的效果将是非常显著的。</p><p>运动还发挥着调整自身神经的交感神经与副交感神经之间的平衡作用。白天促进人体活动的交感神经被激活一晚，让人体进入休息状态的副交感神经占到上风，这也是人体生物钟的生理规律之一。但是人如果一直是持续加班吃宵夜、夜猫子的生活方式，要把神经就会一直处于兴奋状态，身体始终无法进入休息状态，所以人也得不到高质量的睡眠。</p><p>交感神经被激活起到主要作用，而运动结束后，副交感神经就会开始进入工作状态。从这个意义上来讲，<strong>傍晚以后的身体运动也是非常重要</strong>的。</p><h3 id="生物钟瘦身法和七个小贴士"><a href="#生物钟瘦身法和七个小贴士" class="headerlink" title="生物钟瘦身法和七个小贴士"></a>生物钟瘦身法和七个小贴士</h3><ol><li>尽量早起沐浴清晨的阳光。</li><li>早餐必须要吃，并且要吃好。</li><li>午餐可以多吃，就算把肚子吃的鼓鼓的也完全OK。</li><li>晚餐要在8点之前吃完。</li><li>晚餐要特别注意摄入低脂肪的食物。</li><li>为了第二天早上能够起来保持头脑清醒，千万不要持续熬夜。</li></ol><p>这样看来，这七条规则都是大家所熟知的基本方法，没有一项是新鲜的，但是如果你最近感觉变得特别容易发胖，说不定就是因为你没有把握住最基本最理所当然的事情。生物中所记载的生理规律去生活的话，我们就不会再为肥胖问题而烦恼了。</p><p>在当今这种快节奏的生活环境里，你可能会认为做到以上几点是非常困难的，而实际上这种正确的生活方式绝对不是你想象的那样遥不可及。一旦养成早起和吃早饭的习惯，你就已经站在了正确的队伍之中。人体内混乱的生物钟得到再一次正确的调整，几天内都会按照正确的生物钟进行运转。</p><p>刚开始的时候，每星期只坚持两至三天也是可以的，比平时早起30分钟努力把早饭吃好，那么你体内的生物钟就会与地球自转相适应，生活节奏也会大有改善，毕竟人体体内本来就拥有一种防止身体发胖的系统。我们应该好好的利用他，努力改正导致肥胖的坏习惯。让我们一起来倾听记载着人体生理规律的生物钟所发出悦耳的滴答声吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 减肥 </tag>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是第8033天的打卡</title>
      <link href="2021/05/22/%E8%BF%99%E6%98%AF%E7%AC%AC8033%E5%A4%A9%E7%9A%84%E6%89%93%E5%8D%A1/"/>
      <url>2021/05/22/%E8%BF%99%E6%98%AF%E7%AC%AC8033%E5%A4%A9%E7%9A%84%E6%89%93%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<img src="https://i.loli.net/2021/05/21/hPnIejsKBOvZMlV.jpg" style="zoom:33%;overflow:hidden"><p>四季交替，日转星移。迈奇依旧唱歌，烛光依旧闪耀。有的人成为了大佬，有的人考上了研究生。大家都奔赴于理想之途，与无边的寂寞相伴，沐浴不同的阳光，也淋着冷漠的雨，只是大家都探寻到了各自奔波的意义，而我还是那个菜鸡。当我发现又过了一年，当我突然领悟歌词的意义…人生啊，第8033天打卡。</p><p>祝自己第22岁生日快乐……</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/22/hello-world/"/>
      <url>2021/05/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>教资中学科目一作文练手《以奋斗创造未来》</title>
      <link href="2021/03/10/zuowen/"/>
      <url>2021/03/10/zuowen/</url>
      
        <content type="html"><![CDATA[<h2 id="考题内容"><a href="#考题内容" class="headerlink" title="考题内容"></a>考题内容</h2><p>阅读下面的材料，按要求写作文。</p><h3 id="【材料一】"><a href="#【材料一】" class="headerlink" title="【材料一】"></a>【材料一】</h3><p>“人的一生应当这样度过，当他回首往事时，不因虚度年华而悔恨，也不因碌碌无为而羞耻……”《钢铁是怎样炼成的》主角保尔·柯察金以其钢铁般的意志和为理想而奋斗的精神，激励了一代代青年投身社会主义建设。</p><h3 id="【材料二】"><a href="#【材料二】" class="headerlink" title="【材料二】"></a>【材料二】</h3><p>“生活不能等待别人来安排，要自己去争取与奋斗！”，《平凡的世界》里的农村青年——孙少平，在苦难面前咬牙坚持，积极抗争，让一代代人从中获得精神的力量，增添了克服困难的勇气。</p><h3 id="写作要求"><a href="#写作要求" class="headerlink" title="写作要求"></a>写作要求</h3><p>1、综合上述材料所引发的思考和感悟，写一篇论说文。</p><p>2、用规范的现代汉语写作，角度自选，立意自定，题目自拟。</p><p>【字数要求】小学800字，中学1000字。</p><hr><h2 id="练手作文详情"><a href="#练手作文详情" class="headerlink" title="练手作文详情"></a>练手作文详情</h2><h3 id="《奋斗创造未来-》作者：chenlx"><a href="#《奋斗创造未来-》作者：chenlx" class="headerlink" title="《奋斗创造未来 》作者：chenlx"></a>《奋斗创造未来 》作者：chenlx</h3><p>古话说“少壮不努力，老大徒伤悲”，“长风破浪会有时，直挂云帆济沧海”。“奋斗”二字，从古至今都有文学写着关于这个词的描绘。对于我们来说，什么才是奋斗呢？ </p><p>奋斗，是一场考试前她的奋笔疾书认真备考，放榜时看到成绩的洋溢着喜悦的笑脸；奋斗，是农民在田野里辛勤地劳作挥洒着汗水，在火红的秋日里丰收时那捧在怀里的稻香；奋斗，是新中国成立后，先辈们通过艰苦拼搏反复尝试，后人们接力共同打造出如今的世界第二大经济体，让百姓可以安居乐业的生活。 </p><p>为什么需要依靠奋斗来创造未来？我们所渴望、所期待的未来生活多姿多样。我们畅想着，在未来，我们不用害怕路上的危险，不用担心敌人的欺凌，不用担心吃不饱穿不暖，不用担心不能在知识的汪洋里遨游。但这一切离不开实力，离不开通过奋斗积累出的实力。</p><p>在西汉年代，有一位特别有学问的人名叫匡衡。可匡衡小时候非常的贫穷，家里连根照明的蜡烛都买不起。但匡衡为了在夜里也可以读书，他得知隔壁人家有光后，便在墙上凿了一个洞，以此偷光读书。后来，匡衡的这个举动感动了他的邻居。后来在大家的帮助下，小少年匡衡终于学有所成。在汉元帝时期，匡衡也被封为了郎中。 </p><p>奋斗的故事在我们现代同样随处可见。2020 年，伴随着我国的北斗定位系统完成了最后一颗卫星的发射，至此，我国终于拥有了自己的全球定位系统。可是这一切，得来的并不容易。</p><p>在我们国家的科学家研发北斗系统之初，我们什么核心技术都没有掌握。在这个几乎等同于从零开始的情况之下，科学家们还必须在规定的时间之前先行发射一颗卫星上去使用定位系统的频段号，否则，国际组织就不承认这个频段号归属北斗所用。算法、硬件、原子钟…… 科学家们在有限的时间里艰苦奋斗，克服重重困难，终于发射出了中国的第一颗北斗。在往后的日子里，科学家们日以夜继，终于在去年完成了北斗系统的组网并成功投入使用。感动中国栏目中组曾这样评价道：“当第五十五颗吉星升上太空，北斗，照亮了中国人的梦”。 所以，美好的未来需要靠我们去努力奋斗。我们不必一口气再造出个北斗，也没有必要 凿光读书。在我们的生活中，每一件事情都值得去奋斗。我们可以勤加锻炼身体，保证奋斗 的基本；认真复习，迎接每一场考试。或者我们可以团结协作，夺得一份荣誉，也可以当志愿者服务百姓，为美好社会献上一份自己的力量。 需要奋斗的事情有很多很多，奋斗的方式也多种多样。奋斗的时间或许有长有短，但一定能通过自己的努力奋斗出满意的结果，创造出自己期望的美好的未来！</p><hr><h2 id="作文点评"><a href="#作文点评" class="headerlink" title="作文点评"></a>作文点评</h2><h3 id="预估分数：39"><a href="#预估分数：39" class="headerlink" title="预估分数：39"></a>预估分数：<strong>39</strong></h3><h3 id="写作亮点"><a href="#写作亮点" class="headerlink" title="写作亮点"></a>写作亮点</h3><ol><li>本文立意清楚，开头结合诗词直接引出立意，首尾呼应。</li><li>结构上层层递进，结合例子，流畅有力。</li></ol><h3 id="写作不足"><a href="#写作不足" class="headerlink" title="写作不足"></a>写作不足</h3><ol><li>不知道是不是电脑显示问题，文章分了8段，段落有些多，基本在4-6就可以了，一般5段最为完美，太多分 段会感觉很分散，可以开头-奋斗是什么-为什么奋斗-怎么去奋斗-结尾分为这五段。</li><li>怎样奋斗可以运用排比句的方式，①奋斗是勤加锻炼身体，奋斗是读书储备知识，奋斗是为社会做贡献， 奋斗可以是任何一件小事，奋斗努力的过程，就是小事迸发出最大的力量的过程。</li><li>结尾可以联系下材料，②奋斗是匡衡、北斗、、、然后加上原文需要到未来这部分会更好。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 作文 </tag>
            
            <tag> 教师资格证 </tag>
            
            <tag> 科目一 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boot链接neo4j遇到的一些报错知识库</title>
      <link href="2021/03/01/boot%E9%93%BE%E6%8E%A5neo4j%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
      <url>2021/03/01/boot%E9%93%BE%E6%8E%A5neo4j%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>org.springframework.data.mapping.MappingException: Error mapping Record</p><p>Caused by: org.springframework.dao.TypeMismatchDataAccessException: Could not convert “” into java.util.List&lt;java.lang.String&gt;; nested exception is org.neo4j.driver.exceptions.value.NotMultiValued: STRING is not iterable</p><p>Caused by: org.neo4j.driver.exceptions.value.NotMultiValued: STRING is not iterable</p><p>解决办法：将该字段类型改成Object即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月25日数据指标项目会议记录</title>
      <link href="2021/02/25/0225%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/25/0225%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>1104监管标准制定（计划3月份开始）</p><p>围绕分析数据标准的流程 方法 机制（主要介绍模板）</p><p>专题优先（e.g 客户 、风险）</p><h2 id="分析数据标准的框架"><a href="#分析数据标准的框架" class="headerlink" title="分析数据标准的框架"></a>分析数据标准的框架</h2><h3 id="框架源自于哪里？"><a href="#框架源自于哪里？" class="headerlink" title="框架源自于哪里？"></a>框架源自于哪里？</h3><p>最初的原型是毕马威，细分（二级）是国际金融体系</p><h3 id="现在要做的1104数据标准在框架里对应的是监管合规吗？"><a href="#现在要做的1104数据标准在框架里对应的是监管合规吗？" class="headerlink" title="现在要做的1104数据标准在框架里对应的是监管合规吗？"></a>现在要做的1104数据标准在框架里对应的是监管合规吗？</h3><h3 id="特殊、通用由谁判断"><a href="#特殊、通用由谁判断" class="headerlink" title="特殊、通用由谁判断"></a>特殊、通用由谁判断</h3><p>分析的时候进行判断。分类框架不是纠结与口径的问题，。为什么单独列出来监管合规，是因为与行里不一样（比较特殊）。指标之间是有关系的。</p><h3 id="运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）"><a href="#运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）" class="headerlink" title="运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）"></a>运营管理为什么也是单独分裂（为什么不是跟风险管理同一个级别）</h3><p>包含渠道、流程的专题，面向客户、财务分析、（来源于毕马威）</p><p>银行业务 六大类。</p><p>信息管理要单列：</p><p>分类方向不能用专题来分。银行业务四个字有点模糊（所有的东西都算是银行业务、概念太泛）</p><h3 id="毕马威提的银行业务吗、绩效指标放哪里"><a href="#毕马威提的银行业务吗、绩效指标放哪里" class="headerlink" title="毕马威提的银行业务吗、绩效指标放哪里"></a>毕马威提的银行业务吗、绩效指标放哪里</h3><p>不是。提的是业务规模。理论上这个框架跟报告上的框架要么统一，要么</p><h3 id="信息管理要不要单列-有没有那么重要？里面其实指标不多"><a href="#信息管理要不要单列-有没有那么重要？里面其实指标不多" class="headerlink" title="信息管理要不要单列 有没有那么重要？里面其实指标不多"></a>信息管理要不要单列 有没有那么重要？里面其实指标不多</h3><p>系统运维、数据质量指标。<strong>理论上可以放到运维管理</strong>。信息管理可以合并到运营管理。系统运行关注点可能在生产运维。我们要关注偏业务层面的事物。</p><h3 id="资产负债其实是一个很重要的大的专题"><a href="#资产负债其实是一个很重要的大的专题" class="headerlink" title="资产负债其实是一个很重要的大的专题"></a>资产负债其实是一个很重要的大的专题</h3><p>其实可以单列出来。资产负债理论上是讲流动性的事务，资产负债管理是银行非常重要的数据方向。在以前的报告就提现的是。建议信息管理的模块替换或合并成资产负债。</p><p>银行业务原来叫业务规模，原来放在财务绩效（面向部门不是个人的KPI）。建议照样保留业务规模，与财务分析天然就有关联。如果指标过多，可以当成两个专题。</p><p>CRM只涵盖营销部分。</p><h3 id="客户管理客户关系管理的区别是什么。"><a href="#客户管理客户关系管理的区别是什么。" class="headerlink" title="客户管理客户关系管理的区别是什么。"></a>客户管理客户关系管理的区别是什么。</h3><p>认为是一样的。客户管理包括关系管理。分析标准上谈论的客户管理其实就是客户关系管理。加上目前的名称都是4个字，所以干脆就叫客户管理。（叫CRM是想体现银行跟客户的关系）</p><h3 id="监管合规包含运营管理吗"><a href="#监管合规包含运营管理吗" class="headerlink" title="监管合规包含运营管理吗"></a>监管合规包含运营管理吗</h3><p>后面一定会碰到这个的情况的。</p><p>为什么是单列而不是在某个具体的指标进行展开。</p><h3 id="在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。"><a href="#在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。" class="headerlink" title="在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。"></a>在监管合规不要分口径子项目。不要体现口径二字。在框架图里，不谈论具体的指标。对于每一个具体的事项要能避免歧义、解释清楚。改成指标。</h3><h3 id="在分析数据标准的属性框架图中，业务需要重点关注的点是？"><a href="#在分析数据标准的属性框架图中，业务需要重点关注的点是？" class="headerlink" title="在分析数据标准的属性框架图中，业务需要重点关注的点是？"></a>在分析数据标准的属性框架图中，业务需要重点关注的点是？</h3><p>手工指标建议改成数据元。</p><h3 id="编号后续再继续详细讨论，要保证编码的稳定性"><a href="#编号后续再继续详细讨论，要保证编码的稳定性" class="headerlink" title="编号后续再继续详细讨论，要保证编码的稳定性"></a>编号后续再继续详细讨论，要保证编码的稳定性</h3><h1 id="Excel模板（工作底稿）"><a href="#Excel模板（工作底稿）" class="headerlink" title="Excel模板（工作底稿）"></a>Excel模板（工作底稿）</h1><h3 id="模板的必填项要设置。"><a href="#模板的必填项要设置。" class="headerlink" title="模板的必填项要设置。"></a>模板的必填项要设置。</h3><h3 id="如果有多个部门共同制定的一个指标，这个场景应该怎么处理。"><a href="#如果有多个部门共同制定的一个指标，这个场景应该怎么处理。" class="headerlink" title="如果有多个部门共同制定的一个指标，这个场景应该怎么处理。"></a>如果有多个部门共同制定的一个指标，这个场景应该怎么处理。</h3><p>先按报表主责、或者按部门占比认责。</p><h3 id="如果指标要调整，但是没有主责方，执行层面上应该怎么处理。"><a href="#如果指标要调整，但是没有主责方，执行层面上应该怎么处理。" class="headerlink" title="如果指标要调整，但是没有主责方，执行层面上应该怎么处理。"></a>如果指标要调整，但是没有主责方，执行层面上应该怎么处理。</h3><p>没人负责的情况下，由上一级排版仲裁（数据治理委员会等）</p><h3 id="拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则"><a href="#拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则" class="headerlink" title="拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则"></a>拿到一个报表需求，定义出来的指标，往下拆解（分析过程）。怎么拆解？拆解的原则</h3><h2 id="类名实例PPT"><a href="#类名实例PPT" class="headerlink" title="类名实例PPT"></a>类名实例PPT</h2><h3 id="什么叫类？从哪里来的？"><a href="#什么叫类？从哪里来的？" class="headerlink" title="什么叫类？从哪里来的？"></a>什么叫类？从哪里来的？</h3><h3 id="维度不同"><a href="#维度不同" class="headerlink" title="维度不同"></a>维度不同</h3><p>不同角度（维度）进行计算，但是计算结果是一样的。</p><p>从业务层面讲，是一个东西。但从计算角度来讲，计算方式不一样（口径）</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 会议记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
